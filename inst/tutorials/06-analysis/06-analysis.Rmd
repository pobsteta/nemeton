---
title: "Tutorial 06 : Analyse Multi-Critères — 12 Familles + Export"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Visualisation (cartes, radar, corrélations), identification des hotspots,
  clustering des parcelles, et export des résultats nemeton.
---

```{r setup, include=FALSE}
library(learnr)
library(sf)
library(terra)
library(ggplot2)

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

# Répertoire cache
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

## Introduction

### Objectifs du Tutorial

Bienvenue dans le **sixième et dernier tutoriel** de la série nemeton !

Vous avez calculé tous les indicateurs des 12 familles dans les tutoriels précédents. Maintenant, vous allez apprendre à :

1. **Visualiser** les résultats avec des cartes thématiques
2. **Analyser** les profils multi-critères avec des diagrammes radar
3. **Explorer** les synergies et compromis entre familles
4. **Identifier** les hotspots et parcelles Pareto-optimales
5. **Clustériser** les parcelles par profil similaire
6. **Exporter** les résultats en GeoPackage, CSV et carte interactive

### Prérequis

Ce tutoriel utilise les données produites par le Tutorial 05 :

```
~/nemeton_tutorial_data/
└── parcelles.gpkg
    ├── Indicateurs normalisés (*_norm)
    ├── Moyennes par famille (family_C, family_B, ...)
    └── Indice composite (I_nemeton)
```

---

## Section 1 : Cartes Thématiques

### Exercice 1.1 : Carte par famille

Créez des cartes thématiques montrant la distribution spatiale de chaque famille d'indicateurs.

```{r ex-1-1-setup, include=FALSE}
library(sf)
library(ggplot2)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-1-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=40, exercise.setup="ex-1-1-setup", fig.width=8, fig.height=6}
# === CARTES THÉMATIQUES PAR FAMILLE ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Carte pour la famille Carbone (family_C)
carte_carbone <- ggplot(parcelles) +
  geom_sf(aes(fill = family_C), color = "white", linewidth = 0.2) +
  scale_fill_viridis_c(
    name = "Score Carbone",
    option = "D",
    limits = c(0, 1)
  ) +
  theme_minimal() +
  labs(
    title = "Famille Carbone (C)",
    subtitle = "Score normalisé [0-1]"
  )

print(carte_carbone)

# === ANALYSE DE LA DISTRIBUTION ===
cat("\n========== ANALYSE FAMILLE CARBONE ==========\n\n")

cat(sprintf("Parcelles analysées : %d\n\n", nrow(parcelles)))

# Statistiques descriptives
cat("STATISTIQUES :\n")
cat(sprintf("  Moyenne : %.2f\n", mean(parcelles$family_C, na.rm = TRUE)))
cat(sprintf("  Médiane : %.2f\n", median(parcelles$family_C, na.rm = TRUE)))
cat(sprintf("  Écart-type : %.2f\n", sd(parcelles$family_C, na.rm = TRUE)))
cat(sprintf("  Min : %.2f | Max : %.2f\n", min(parcelles$family_C, na.rm = TRUE), max(parcelles$family_C, na.rm = TRUE)))

# Classification
cat("\nDISTRIBUTION PAR CLASSE :\n")
parcelles$classe_C <- cut(parcelles$family_C, breaks = c(0, 0.25, 0.5, 0.75, 1),
                          labels = c("Faible", "Moyen", "Bon", "Excellent"), include.lowest = TRUE)
print(table(parcelles$classe_C))
```



### Exercice 1.2 : Multi-cartes des 12 familles

Créez un panneau de 12 cartes montrant toutes les familles :

```{r ex-1-2-setup, include=FALSE}
library(sf)
library(ggplot2)
library(patchwork)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-1-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-1-2-setup", fig.width=10, fig.height=8}
# === PANNEAU MULTI-CARTES ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Définir les familles et leurs noms
familles <- c("C" = "Carbone", "B" = "Biodiversité", "W" = "Eau", "A" = "Air",
              "F" = "Fertilité", "L" = "Paysage", "T" = "Trame", "R" = "Résilience",
              "S" = "Santé", "P" = "Production", "E" = "Énergie", "N" = "Naturalité")

# Fonction pour créer une mini-carte
create_mini_map <- function(data, famille, titre) {
  col_name <- paste0("family_", famille)
  if (!col_name %in% names(data)) return(NULL)

  ggplot(data) +
    geom_sf(aes(fill = .data[[col_name]]), color = NA) +
    scale_fill_viridis_c(limits = c(0, 1), guide = "none") +
    theme_void() +
    labs(title = titre) +
    theme(plot.title = element_text(size = 8, hjust = 0.5))
}

# Créer les 12 cartes
cartes <- lapply(names(familles), function(f) {
  create_mini_map(parcelles, f, familles[f])
})

# Assembler avec patchwork
if (requireNamespace("patchwork", quietly = TRUE)) {
  combined <- patchwork::wrap_plots(cartes, ncol = 4)
  print(combined)
}

# === ANALYSE COMPARATIVE DES 12 FAMILLES ===
cat("\n\n========== SYNTHÈSE DES 12 FAMILLES ==========\n\n")

parcelles_df <- st_drop_geometry(parcelles)
cols_family <- grep("^family_", names(parcelles_df), value = TRUE)

# Calculer les moyennes par famille
moyennes <- sapply(cols_family, function(col) mean(parcelles_df[[col]], na.rm = TRUE))
names(moyennes) <- gsub("family_", "", names(moyennes))

# Trier par score moyen
moyennes_tri <- sort(moyennes, decreasing = TRUE)

cat("CLASSEMENT DES FAMILLES (score moyen) :\n")
for (i in seq_along(moyennes_tri)) {
  nom_famille <- familles[names(moyennes_tri)[i]]
  cat(sprintf("  %2d. %s (%s) : %.2f\n", i, names(moyennes_tri)[i], nom_famille, moyennes_tri[i]))
}

cat("\nINTERPRÉTATION :\n")
cat(sprintf("  Meilleure famille : %s (%.2f)\n", familles[names(moyennes_tri)[1]], moyennes_tri[1]))
cat(sprintf("  Famille à améliorer : %s (%.2f)\n", familles[names(moyennes_tri)[12]], moyennes_tri[12]))
```


---

## Section 2 : Profils Radar

### Le diagramme radar (spider chart)

Le diagramme radar permet de visualiser le profil multi-critères d'une parcelle sur les 12 familles simultanément.

### Exercice 2.1 : Créer un radar pour une parcelle

```{r ex-2-1-setup, include=FALSE}
library(sf)
library(purrr)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-2-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-2-1-setup", fig.width=8, fig.height=8}
# === DIAGRAMME RADAR AVEC fmsb ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Sélectionner une parcelle (première ligne)
parcelle_idx <- 1

# Extraire les scores par famille
familles <- c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N")
noms_familles <- c("Carbone", "Biodiv", "Eau", "Air", "Fertilité", "Paysage",
                   "Trame", "Résilience", "Santé", "Production", "Énergie", "Naturalité")

parcelles_df <- as.data.frame(st_drop_geometry(parcelles))
scores <- map_dbl(familles, ~as.numeric(parcelles_df[parcelle_idx, paste0("family_", .x)]))
names(scores) <- familles

# Créer le radar avec fmsb
radar_data <- as.data.frame(rbind(
  rep(1, 12),   # Max
  rep(0, 12),   # Min
  scores
))
colnames(radar_data) <- noms_familles

fmsb::radarchart(radar_data,
  axistype = 1, pcol = "forestgreen",
  pfcol = rgb(0.2, 0.5, 0.3, 0.5), plwd = 2,
  cglcol = "grey", cglty = 1, axislabcol = "grey",
  caxislabels = seq(0, 1, 0.25), vlcex = 0.7,
  title = paste("Profil Parcelle", parcelle_idx)
)

# === ANALYSE DU PROFIL ===
cat("\n\n========== ANALYSE DU PROFIL ==========\n\n")

cat(sprintf("Score moyen : %.2f\n", mean(scores, na.rm = TRUE)))
cat(sprintf("Indice nemeton (I) : %.2f\n\n", parcelles_df[parcelle_idx, "I_nemeton"]))

# Points forts et faibles
scores_tri <- sort(scores, decreasing = TRUE)
cat("POINTS FORTS (Top 3) :\n")
for (i in 1:3) {
  cat(sprintf("  %s (%s) : %.2f\n", names(scores_tri)[i], noms_familles[match(names(scores_tri)[i], familles)], scores_tri[i]))
}

cat("\nPOINTS À AMÉLIORER (Top 3) :\n")
for (i in 10:12) {
  cat(sprintf("  %s (%s) : %.2f\n", names(scores_tri)[i], noms_familles[match(names(scores_tri)[i], familles)], scores_tri[i]))
}
```


### Exercice 2.2 : Comparer plusieurs parcelles

```{r ex-2-2-setup, include=FALSE}
library(sf)
library(purrr)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-2-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-2-2-setup", fig.width=6, fig.height=6}
# === COMPARAISON MULTI-PARCELLES ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Sélectionner 3 parcelles à comparer (lignes 1, 2, 3)
parcelles_idx <- c(1, 2, 3)

# Extraire les scores pour chaque parcelle
familles <- c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N")
parcelles_df <- as.data.frame(st_drop_geometry(parcelles))

extract_scores <- function(df, idx) {
  map_dbl(familles, ~{
    col_name <- paste0("family_", .x)
    if (col_name %in% names(df)) as.numeric(df[idx, col_name])
    else NA_real_
  })
}

scores_list <- map(parcelles_idx, ~extract_scores(parcelles_df, .x))

# Radar multi-parcelles avec fmsb
if (requireNamespace("fmsb", quietly = TRUE)) {
  radar_data <- rbind(
    rep(1, 12),   # Max
    rep(0, 12),   # Min
    do.call(rbind, scores_list)
  )
  colnames(radar_data) <- c("Carbone", "Biodiv", "Eau", "Air", "Sol", "Paysage",
                            "Temporel", "Risques", "Social", "Prod", "Énergie", "Natural")
  radar_data <- as.data.frame(radar_data)

  # Couleurs distinctes
  colors <- c("forestgreen", "steelblue", "coral")

  fmsb::radarchart(radar_data,
    axistype = 1,
    pcol = colors,
    pfcol = adjustcolor(colors, alpha.f = 0.3),
    plwd = 2,
    cglcol = "grey",
    cglty = 1,
    vlcex = 0.7,
    title = "Comparaison de parcelles"
  )

  legend("topright",
    legend = paste("Parcelle", parcelles_idx),
    col = colors,
    lwd = 2,
    bty = "n"
  )
}

# === ANALYSE COMPARATIVE ===
cat("\n\n========== ANALYSE COMPARATIVE DES PARCELLES ==========\n\n")

noms_familles <- c("Carbone", "Biodiv", "Eau", "Air", "Fertilité", "Paysage",
                   "Trame", "Résilience", "Santé", "Production", "Énergie", "Naturalité")

# Calculer les scores moyens de chaque parcelle
scores_moyens <- sapply(scores_list, mean, na.rm = TRUE)
cat("SCORES MOYENS PAR PARCELLE :\n")
for (i in seq_along(parcelles_idx)) {
  cat(sprintf("  Parcelle %d : %.2f\n", parcelles_idx[i], scores_moyens[i]))
}

# Identifier la meilleure parcelle globale
best_idx <- which.max(scores_moyens)
cat(sprintf("\nMeilleure parcelle globale : Parcelle %d (%.2f)\n", parcelles_idx[best_idx], scores_moyens[best_idx]))

# Analyser les points forts de chaque parcelle
cat("\nPOINTS FORTS PAR PARCELLE (famille avec le meilleur score) :\n")
for (i in seq_along(parcelles_idx)) {
  best_fam_idx <- which.max(scores_list[[i]])
  cat(sprintf("  Parcelle %d : %s (%s) = %.2f\n",
              parcelles_idx[i], familles[best_fam_idx], noms_familles[best_fam_idx], scores_list[[i]][best_fam_idx]))
}

# Calculer les écarts entre parcelles
cat("\nÉCART MAXIMAL ENTRE PARCELLES PAR FAMILLE :\n")
scores_matrix <- do.call(rbind, scores_list)
ecarts <- apply(scores_matrix, 2, function(x) max(x) - min(x))
names(ecarts) <- familles
ecarts_tri <- sort(ecarts, decreasing = TRUE)
for (i in 1:min(3, length(ecarts_tri))) {
  cat(sprintf("  %s (%s) : écart de %.2f\n",
              names(ecarts_tri)[i], noms_familles[match(names(ecarts_tri)[i], familles)], ecarts_tri[i]))
}
```


---

## Section 3 : Matrice de Corrélation

### Synergies et compromis entre familles

L'analyse des corrélations entre familles révèle :
- **Synergies** (r > 0.5) : améliorer une famille améliore l'autre
- **Compromis** (r < -0.5) : améliorer une famille dégrade l'autre
- **Indépendance** (-0.3 < r < 0.3) : pas de relation

### Exercice 3.1 : Calculer la matrice de corrélation

```{r ex-3-1-setup, include=FALSE}
library(sf)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-3-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-3-1-setup"}
# === MATRICE DE CORRÉLATION ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Extraire les colonnes de scores par famille
cols_familles <- grep("^family_", names(parcelles), value = TRUE)
data_familles <- st_drop_geometry(parcelles)[, cols_familles]

# Renommer les colonnes pour lisibilité
colnames(data_familles) <- gsub("family_", "", colnames(data_familles))

# Calculer la matrice de corrélation
cor_matrix <- cor(data_familles, use = "pairwise.complete.obs")

# Afficher la matrice
cat("=== Matrice de Corrélation entre Familles ===\n\n")
print(round(cor_matrix, 2))

# === ANALYSE DE LA MATRICE DE CORRÉLATION ===
cat("\n\n========== ANALYSE DES CORRÉLATIONS ==========\n\n")

# Dictionnaire des noms de familles
noms_familles <- c(
  C = "Carbone", B = "Biodiversité", W = "Eau", A = "Air",
  F = "Fertilité", L = "Paysage", T = "Trame", R = "Résilience",
  S = "Santé", P = "Production", E = "Énergie", N = "Naturalité"
)

# Extraire les paires de corrélations
cor_pairs <- which(upper.tri(cor_matrix), arr.ind = TRUE)
cor_values <- data.frame(
  Famille1 = rownames(cor_matrix)[cor_pairs[, 1]],
  Famille2 = colnames(cor_matrix)[cor_pairs[, 2]],
  Correlation = cor_matrix[cor_pairs]
)
cor_values <- cor_values[order(-cor_values$Correlation), ]

# Synergies (corrélations positives > 0.5)
cat("SYNERGIES (r > 0.5) :\n")
synergies <- cor_values[cor_values$Correlation > 0.5, ]
if (nrow(synergies) > 0) {
  for (i in seq_len(nrow(synergies))) {
    f1 <- synergies$Famille1[i]
    f2 <- synergies$Famille2[i]
    cat(sprintf("  %s (%s) - %s (%s) : r = %.2f\n",
                f1, noms_familles[f1], f2, noms_familles[f2], synergies$Correlation[i]))
  }
} else {
  cat("  Aucune synergie forte détectée\n")
}

# Compromis (corrélations négatives < -0.3)
cat("\nCOMPROMIS (r < -0.3) :\n")
compromis <- cor_values[cor_values$Correlation < -0.3, ]
if (nrow(compromis) > 0) {
  compromis <- compromis[order(compromis$Correlation), ]
  for (i in seq_len(nrow(compromis))) {
    f1 <- compromis$Famille1[i]
    f2 <- compromis$Famille2[i]
    cat(sprintf("  %s (%s) - %s (%s) : r = %.2f\n",
                f1, noms_familles[f1], f2, noms_familles[f2], compromis$Correlation[i]))
  }
} else {
  cat("  Aucun compromis significatif détecté\n")
}

# Statistiques globales
cat("\nSTATISTIQUES :\n")
cat(sprintf("  Corrélation moyenne : %.2f\n", mean(cor_values$Correlation)))
cat(sprintf("  Écart-type : %.2f\n", sd(cor_values$Correlation)))
cat(sprintf("  Min : %.2f | Max : %.2f\n", min(cor_values$Correlation), max(cor_values$Correlation)))
```


### Exercice 3.2 : Visualiser avec corrplot

```{r ex-3-2-setup}
library(sf)

cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

set.seed(42)
n <- 50
create_grid_polygons <- function(n, xmin = 0, ymin = 0, size = 100) {
  ncol <- ceiling(sqrt(n))
  polys <- vector("list", n)
  for (i in seq_len(n)) {
    row <- (i - 1) %/% ncol
    col <- (i - 1) %% ncol
    x1 <- xmin + col * size
    y1 <- ymin + row * size
    polys[[i]] <- st_polygon(list(matrix(c(x1, y1, x1+size, y1, x1+size, y1+size,
                                            x1, y1+size, x1, y1), ncol = 2, byrow = TRUE)))
  }
  st_sfc(polys, crs = 2154)
}

base_eco <- runif(n, 0.3, 0.8)
base_prod <- runif(n, 0.3, 0.8)

parcelles_sim <- st_sf(
  id = 1:n,
  family_C = base_eco + rnorm(n, 0, 0.1),
  family_B = base_eco + rnorm(n, 0, 0.15),
  family_N = base_eco + rnorm(n, 0, 0.12),
  family_P = base_prod + rnorm(n, 0, 0.1),
  family_E = base_prod + rnorm(n, 0, 0.12),
  family_W = runif(n, 0.25, 0.8),
  family_A = runif(n, 0.4, 0.75),
  family_F = runif(n, 0.35, 0.85),
  family_L = runif(n, 0.3, 0.8),
  family_T = runif(n, 0.4, 0.9),
  family_R = 1 - base_eco + rnorm(n, 0, 0.1),
  family_S = runif(n, 0.3, 0.75),
  I_nemeton = runif(n, 0.35, 0.75),
  geometry = create_grid_polygons(n)
)

for (col in grep("^family_", names(parcelles_sim), value = TRUE)) {
  vals <- parcelles_sim[[col]]
  parcelles_sim[[col]] <- (vals - min(vals)) / (max(vals) - min(vals))
}
```

```{r ex-3-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-3-2-setup", fig.width=8, fig.height=8}
# === VISUALISATION CORRPLOT ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Extraire et préparer les données
cols_familles <- grep("^family_", names(parcelles), value = TRUE)
data_familles <- st_drop_geometry(parcelles)[, cols_familles]
colnames(data_familles) <- gsub("family_", "", colnames(data_familles))

# Matrice de corrélation
cor_matrix <- cor(data_familles, use = "pairwise.complete.obs")

# Visualiser avec corrplot
if (requireNamespace("corrplot", quietly = TRUE)) {
  corrplot::corrplot(cor_matrix,
    method = "color",
    type = "upper",
    order = "hclust",
    addCoef.col = "black",
    number.cex = 0.7,
    tl.col = "black",
    tl.srt = 45,
    title = "Corrélations entre familles d'indicateurs",
    mar = c(0, 0, 2, 0)
  )
}

# === ANALYSE DES CORRÉLATIONS ===
cat("\n\n========== ANALYSE DES CORRÉLATIONS ==========\n\n")

# Dictionnaire des noms de familles
noms_familles <- c(
  C = "Carbone", B = "Biodiversité", W = "Eau", A = "Air",
  F = "Fertilité", L = "Paysage", T = "Trame", R = "Résilience",
  S = "Santé", P = "Production", E = "Énergie", N = "Naturalité"
)

# Extraire les paires de corrélations (triangle supérieur)
cor_pairs <- which(upper.tri(cor_matrix), arr.ind = TRUE)
cor_values <- data.frame(
  Famille1 = rownames(cor_matrix)[cor_pairs[, 1]],
  Famille2 = colnames(cor_matrix)[cor_pairs[, 2]],
  Correlation = cor_matrix[cor_pairs]
)
cor_values <- cor_values[order(-abs(cor_values$Correlation)), ]

# Top 5 synergies (corrélations positives)
cat("TOP 5 SYNERGIES (corrélations positives) :\n")
synergies <- head(cor_values[cor_values$Correlation > 0, ], 5)
for (i in seq_len(nrow(synergies))) {
  f1 <- synergies$Famille1[i]
  f2 <- synergies$Famille2[i]
  cat(sprintf("  %s (%s) - %s (%s) : r = %.2f\n",
              f1, noms_familles[f1], f2, noms_familles[f2], synergies$Correlation[i]))
}

# Top 5 compromis (corrélations négatives)
cat("\nTOP 5 COMPROMIS (corrélations négatives) :\n")
compromis <- head(cor_values[cor_values$Correlation < 0, ], 5)
if (nrow(compromis) > 0) {
  for (i in seq_len(nrow(compromis))) {
    f1 <- compromis$Famille1[i]
    f2 <- compromis$Famille2[i]
    cat(sprintf("  %s (%s) - %s (%s) : r = %.2f\n",
                f1, noms_familles[f1], f2, noms_familles[f2], compromis$Correlation[i]))
  }
} else {
  cat("  Aucun compromis significatif détecté\n")
}

cat("\nINTERPRÉTATION :\n")
cat("- Synergies : améliorer une famille améliore aussi l'autre\n")
cat("- Compromis : améliorer une famille peut dégrader l'autre\n")
cat("- Ces relations guident les priorités de gestion forestière\n")
```


---

## Section 4 : Identification des Hotspots

### Qu'est-ce qu'un hotspot ?

Un **hotspot** est une parcelle dont l'indice composite dépasse un seuil critique (ex: top 10%, ou I > 0.7).

Ces parcelles représentent des zones à **haute valeur** pour les services écosystémiques forestiers.

### Exercice 4.1 : Identifier les hotspots

```{r ex-4-1-setup, include=FALSE}
library(sf)
library(ggplot2)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-4-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-4-1-setup"}
# === IDENTIFICATION DES HOTSPOTS ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Définir le seuil de hotspot (percentile 90)
seuil_hotspot <- quantile(parcelles$I_nemeton, probs = 0.90, na.rm = TRUE)
cat("Seuil hotspot (P90):", round(seuil_hotspot, 3), "\n\n")

# Identifier les hotspots
parcelles$is_hotspot <- parcelles$I_nemeton >= seuil_hotspot

# Résumé
cat("=== Résumé Hotspots ===\n")
cat("Nombre total de parcelles:", nrow(parcelles), "\n")
cat("Nombre de hotspots:", sum(parcelles$is_hotspot), "\n")
cat("Surface hotspots (ha):", round(sum(parcelles$surface_ha[parcelles$is_hotspot]), 1), "\n")

# Afficher les hotspots
cat("\n=== Top 5 Hotspots ===\n")
hotspots <- parcelles[parcelles$is_hotspot, ]
hotspots_sorted <- hotspots[order(-hotspots$I_nemeton), ]
print(st_drop_geometry(hotspots_sorted)[1:min(5, nrow(hotspots_sorted)),
                                         c("id", "surface_ha", "I_nemeton")])

# === ANALYSE DES HOTSPOTS ===
cat("\n\n========== ANALYSE DES HOTSPOTS ==========\n\n")

# Dictionnaire des noms de familles
noms_familles <- c(
  C = "Carbone", B = "Biodiversité", W = "Eau", A = "Air",
  F = "Fertilité", L = "Paysage", T = "Trame", R = "Résilience",
  S = "Santé", P = "Production", E = "Énergie", N = "Naturalité"
)
familles <- names(noms_familles)

# Statistiques comparatives hotspots vs non-hotspots
n_hotspots <- sum(parcelles$is_hotspot)
n_total <- nrow(parcelles)
surface_hotspots <- sum(parcelles$surface_ha[parcelles$is_hotspot], na.rm = TRUE)
surface_totale <- sum(parcelles$surface_ha, na.rm = TRUE)

cat("COUVERTURE :\n")
cat(sprintf("  Hotspots : %d parcelles (%.1f%% du total)\n", n_hotspots, 100 * n_hotspots / n_total))
cat(sprintf("  Surface : %.1f ha (%.1f%% de la surface totale)\n", surface_hotspots, 100 * surface_hotspots / surface_totale))

# Profil moyen des hotspots vs reste
cat("\nPROFIL MOYEN PAR FAMILLE :\n")
cat(sprintf("  %-12s | Hotspots | Autres | Écart\n", "Famille"))
cat("  -------------|----------|--------|-------\n")

parcelles_df <- st_drop_geometry(parcelles)
for (fam in familles) {
  col <- paste0("family_", fam)
  if (col %in% names(parcelles_df)) {
    mean_hs <- mean(parcelles_df[[col]][parcelles_df$is_hotspot], na.rm = TRUE)
    mean_other <- mean(parcelles_df[[col]][!parcelles_df$is_hotspot], na.rm = TRUE)
    ecart <- mean_hs - mean_other
    cat(sprintf("  %-12s |   %.2f   |  %.2f  | %+.2f\n", noms_familles[fam], mean_hs, mean_other, ecart))
  }
}

cat("\nINTERPRÉTATION :\n")
cat("  Les hotspots représentent les zones à haute valeur écosystémique.\n")
cat("  Ils méritent une attention particulière pour la conservation.\n")
```


### Exercice 4.2 : Cartographier les hotspots

```{r ex-4-2-setup, include=FALSE}
library(sf)
library(ggplot2)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-4-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-4-2-setup", fig.width=6, fig.height=6}
# === CARTE DES HOTSPOTS ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Identifier les hotspots
seuil_hotspot <- quantile(parcelles$I_nemeton, probs = 0.90, na.rm = TRUE)
parcelles$is_hotspot <- parcelles$I_nemeton >= seuil_hotspot

# Créer la carte
carte_hotspots <- ggplot() +
  # Toutes les parcelles en fond
  geom_sf(data = parcelles, aes(fill = I_nemeton), color = "grey50", linewidth = 0.3) +
  scale_fill_viridis_c(name = "Indice\nnemeton", limits = c(0, 1)) +
  # Contour des hotspots en rouge
  geom_sf(data = parcelles[parcelles$is_hotspot, ],
          fill = NA, color = "red", linewidth = 1.0) +
  theme_minimal() +
  labs(
    title = "Carte des Hotspots nemeton",
    subtitle = paste("Seuil P90 =", round(seuil_hotspot, 2)),
    caption = "Contour rouge = hotspots"
  )

print(carte_hotspots)

# === ANALYSE DE LA DISTRIBUTION SPATIALE ===
cat("\n\n========== ANALYSE DE LA DISTRIBUTION SPATIALE ==========\n\n")

# Nombre et surface des hotspots
n_hotspots <- sum(parcelles$is_hotspot)
n_total <- nrow(parcelles)
surface_hotspots <- sum(parcelles$surface_ha[parcelles$is_hotspot], na.rm = TRUE)
surface_totale <- sum(parcelles$surface_ha, na.rm = TRUE)

cat("RÉSUMÉ :\n")
cat(sprintf("  Seuil P90 : %.3f\n", seuil_hotspot))
cat(sprintf("  Hotspots : %d / %d parcelles (%.1f%%)\n", n_hotspots, n_total, 100 * n_hotspots / n_total))
cat(sprintf("  Surface hotspots : %.1f / %.1f ha (%.1f%%)\n", surface_hotspots, surface_totale, 100 * surface_hotspots / surface_totale))

# Indice I_nemeton des hotspots
hotspots <- parcelles[parcelles$is_hotspot, ]
cat("\nSCORES DES HOTSPOTS :\n")
cat(sprintf("  Indice min : %.3f\n", min(hotspots$I_nemeton)))
cat(sprintf("  Indice max : %.3f\n", max(hotspots$I_nemeton)))
cat(sprintf("  Indice moyen : %.3f\n", mean(hotspots$I_nemeton)))

# Surface moyenne
cat("\nSURFACE DES HOTSPOTS :\n")
cat(sprintf("  Surface min : %.2f ha\n", min(hotspots$surface_ha, na.rm = TRUE)))
cat(sprintf("  Surface max : %.2f ha\n", max(hotspots$surface_ha, na.rm = TRUE)))
cat(sprintf("  Surface moyenne : %.2f ha\n", mean(hotspots$surface_ha, na.rm = TRUE)))

cat("\nINTERPRÉTATION :\n")
cat("  Les contours rouges délimitent les zones à plus haute valeur.\n")
cat("  Ces parcelles sont prioritaires pour la conservation.\n")
```


---

## Section 5 : Analyse des Compromis et Front de Pareto

### Qu'est-ce qu'un front de Pareto ?

Le **front de Pareto** identifie les parcelles optimales où on ne peut améliorer une dimension sans dégrader une autre.

### Exercice 5.1 : Visualiser les compromis

```{r ex-5-1-setup, include=FALSE}
library(sf)
library(ggplot2)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-5-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-5-1-setup", fig.width=8, fig.height=6}
# === GRAPHIQUE DES COMPROMIS ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Extraire les données pour le scatter plot
data_plot <- st_drop_geometry(parcelles)

# Compromis Production vs Biodiversité
compromis_plot <- ggplot(data_plot, aes(x = family_P, y = family_B)) +
  geom_point(aes(color = I_nemeton, size = surface_ha), alpha = 0.7) +
  scale_color_viridis_c(name = "Indice\nnemeton") +
  scale_size_continuous(name = "Surface (ha)", range = c(2, 8)) +
  geom_smooth(method = "lm", se = TRUE, color = "red", linetype = "dashed") +
  theme_minimal() +
  labs(
    title = "Compromis Production vs Biodiversité",
    x = "Score Production (P)",
    y = "Score Biodiversité (B)",
    subtitle = "Corrélation négative = compromis"
  )

print(compromis_plot)

# === ANALYSE DU COMPROMIS ===
cat("\n\n========== ANALYSE DU COMPROMIS ==========\n\n")

# Calculer la corrélation
cor_PB <- cor(data_plot$family_P, data_plot$family_B, use = "complete.obs")
cat("Corrélation Production-Biodiversité : r =", round(cor_PB, 2), "\n\n")

# Interpréter la corrélation
if (cor_PB < -0.3) {
  cat("COMPROMIS FORT détecté :\n")
  cat("  Les parcelles productives tendent à avoir une biodiversité plus faible.\n")
  cat("  La gestion doit arbitrer entre ces deux objectifs.\n")
} else if (cor_PB > 0.3) {
  cat("SYNERGIE détectée :\n")
  cat("  Production et biodiversité évoluent ensemble positivement.\n")
  cat("  Les deux objectifs peuvent être poursuivis simultanément.\n")
} else {
  cat("RELATION FAIBLE :\n")
  cat("  Pas de compromis marqué entre production et biodiversité.\n")
  cat("  Les deux dimensions sont relativement indépendantes.\n")
}

# Identifier les parcelles exemplaires
cat("\nPARCELLES EXEMPLAIRES :\n")
# Parcelles équilibrées (bon score sur les deux)
data_plot$equilibre <- (data_plot$family_P + data_plot$family_B) / 2
top_equilibrees <- head(data_plot[order(-data_plot$equilibre), ], 3)
cat("  Top 3 équilibrées (P+B élevés) :\n")
for (i in 1:3) {
  cat(sprintf("    Parcelle %s : P=%.2f, B=%.2f\n",
              top_equilibrees$id[i],
              top_equilibrees$family_P[i], top_equilibrees$family_B[i]))
}
```


### Exercice 5.2 : Identifier le front de Pareto

```{r ex-5-2-setup, include=FALSE}
library(sf)
library(ggplot2)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-5-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=75, exercise.setup="ex-5-2-setup", fig.width=8, fig.height=6}
# === FRONT DE PARETO ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

data_plot <- st_drop_geometry(parcelles)

# Fonction pour identifier les points Pareto-optimaux (2D)
identify_pareto <- function(x, y) {
  n <- length(x)
  is_pareto <- logical(n)

  for (i in seq_len(n)) {
    is_pareto[i] <- TRUE
    for (j in seq_len(n)) {
      if (i != j) {
        # j domine i si j est meilleur ou égal sur les deux dimensions
        # et strictement meilleur sur au moins une
        if (x[j] >= x[i] && y[j] >= y[i] && (x[j] > x[i] || y[j] > y[i])) {
          is_pareto[i] <- FALSE
          break
        }
      }
    }
  }
  return(is_pareto)
}

# Identifier le front de Pareto pour P vs B
data_plot$is_pareto <- identify_pareto(data_plot$family_P, data_plot$family_B)

# Visualiser
pareto_plot <- ggplot(data_plot, aes(x = family_P, y = family_B)) +
  geom_point(aes(color = is_pareto), size = 3, alpha = 0.7) +
  scale_color_manual(values = c("FALSE" = "grey60", "TRUE" = "red"),
                     labels = c("Dominé", "Pareto-optimal"),
                     name = "Statut") +
  theme_minimal() +
  labs(
    title = "Front de Pareto : Production vs Biodiversité",
    x = "Score Production (P)",
    y = "Score Biodiversité (B)",
    subtitle = "Points rouges = optimaux (non dominés)"
  )

print(pareto_plot)

# === ANALYSE DU FRONT DE PARETO ===
cat("\n\n========== ANALYSE DU FRONT DE PARETO ==========\n\n")

n_pareto <- sum(data_plot$is_pareto)
n_total <- nrow(data_plot)
pct_pareto <- round(100 * n_pareto / n_total, 1)

cat(sprintf("Parcelles Pareto-optimales : %d / %d (%.1f%%)\n\n", n_pareto, n_total, pct_pareto))

# Extraire les parcelles Pareto
pareto_parcelles <- data_plot[data_plot$is_pareto, ]

# Caractériser le front
cat("CARACTÉRISTIQUES DU FRONT :\n")
cat(sprintf("  Production (P) : min=%.2f, max=%.2f\n",
            min(pareto_parcelles$family_P), max(pareto_parcelles$family_P)))
cat(sprintf("  Biodiversité (B) : min=%.2f, max=%.2f\n",
            min(pareto_parcelles$family_B), max(pareto_parcelles$family_B)))

# Identifier les profils extrêmes sur le front
cat("\nPROFILS EXTRÊMES SUR LE FRONT :\n")

# Meilleur en Production
best_P <- pareto_parcelles[which.max(pareto_parcelles$family_P), ]
cat(sprintf("  Spécialiste Production : P=%.2f, B=%.2f\n", best_P$family_P, best_P$family_B))

# Meilleur en Biodiversité
best_B <- pareto_parcelles[which.max(pareto_parcelles$family_B), ]
cat(sprintf("  Spécialiste Biodiversité : P=%.2f, B=%.2f\n", best_B$family_P, best_B$family_B))

# Meilleur compromis (somme P+B)
pareto_parcelles$somme_PB <- pareto_parcelles$family_P + pareto_parcelles$family_B
best_compromis <- pareto_parcelles[which.max(pareto_parcelles$somme_PB), ]
cat(sprintf("  Meilleur compromis (P+B max) : P=%.2f, B=%.2f\n",
            best_compromis$family_P, best_compromis$family_B))

cat("\nINTERPRÉTATION :\n")
cat("  Les parcelles Pareto-optimales représentent les meilleurs compromis possibles.\n")
cat("  Aucune autre parcelle n'est meilleure sur les deux critères simultanément.\n")
cat("  Le choix final dépend des priorités de gestion (production vs conservation).\n")
```


---

## Section 6 : Clustering des Parcelles

### Principe du clustering

Le clustering permet de regrouper les parcelles ayant des profils multi-critères similaires.

### Exercice 6.1 : Clustering hiérarchique

```{r ex-6-1-setup, include=FALSE}
library(sf)
library(ggplot2)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-6-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=40, exercise.setup="ex-6-1-setup"}
# === CLUSTERING HIÉRARCHIQUE ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Extraire les colonnes de scores
cols_familles <- grep("^family_", names(parcelles), value = TRUE)
data_cluster <- st_drop_geometry(parcelles)[, cols_familles]

# Standardiser les données
data_scaled <- scale(data_cluster)

# Clustering hiérarchique
dist_matrix <- dist(data_scaled)
hc <- hclust(dist_matrix, method = "ward.D2")

# Couper en k clusters
k <- 4
parcelles$cluster <- as.factor(cutree(hc, k = k))

# Résumé par cluster
cat("=== Profils des Clusters ===\n\n")
for (cl in 1:k) {
  parcelles_cl <- parcelles[parcelles$cluster == cl, ]
  n_cl <- nrow(parcelles_cl)
  mean_score <- mean(parcelles_cl$I_nemeton, na.rm = TRUE)
  cat(sprintf("Cluster %d: %d parcelles, score moyen = %.2f\n", cl, n_cl, mean_score))
}

# Dendrogramme
plot(hc, labels = FALSE, main = "Dendrogramme - Clustering Parcelles")
rect.hclust(hc, k = k, border = 2:5)

# === ANALYSE DES CLUSTERS ===
cat("\n\n========== ANALYSE DES CLUSTERS ==========\n\n")

# Dictionnaire des noms de familles
noms_familles <- c(
  C = "Carbone", B = "Biodiversité", W = "Eau", A = "Air",
  F = "Fertilité", L = "Paysage", T = "Trame", R = "Résilience",
  S = "Santé", P = "Production", E = "Énergie", N = "Naturalité"
)

parcelles_df <- st_drop_geometry(parcelles)

cat("TAILLE DES CLUSTERS :\n")
for (cl in 1:k) {
  n_cl <- sum(parcelles_df$cluster == cl)
  pct <- 100 * n_cl / nrow(parcelles_df)
  cat(sprintf("  Cluster %d : %d parcelles (%.1f%%)\n", cl, n_cl, pct))
}

cat("\nPROFIL MOYEN PAR CLUSTER :\n")
for (cl in 1:k) {
  parcelles_cl <- parcelles_df[parcelles_df$cluster == cl, ]

  # Calculer le score moyen par famille
  scores_cl <- sapply(cols_familles, function(col) mean(parcelles_cl[[col]], na.rm = TRUE))
  names(scores_cl) <- gsub("family_", "", names(scores_cl))

  # Identifier les points forts et faibles
  best <- names(which.max(scores_cl))
  worst <- names(which.min(scores_cl))

  cat(sprintf("\n  Cluster %d :\n", cl))
  cat(sprintf("    Score nemeton moyen : %.2f\n", mean(parcelles_cl$I_nemeton, na.rm = TRUE)))
  cat(sprintf("    Point fort : %s (%s) = %.2f\n", best, noms_familles[best], scores_cl[best]))
  cat(sprintf("    Point faible : %s (%s) = %.2f\n", worst, noms_familles[worst], scores_cl[worst]))
}

cat("\nINTERPRÉTATION :\n")
cat("  Chaque cluster regroupe des parcelles au profil similaire.\n")
cat("  Cela permet d'identifier des typologies de gestion forestière.\n")
```


### Exercice 6.2 : Cartographier les clusters

```{r ex-6-2-setup, include=FALSE}
library(sf)
library(ggplot2)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-6-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=25, exercise.setup="ex-6-2-setup"}
# === CARTE DES CLUSTERS ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Clustering hiérarchique
cols_familles <- grep("^family_", names(parcelles), value = TRUE)
data_cluster <- st_drop_geometry(parcelles)[, cols_familles]
data_scaled <- scale(data_cluster)
hc <- hclust(dist(data_scaled), method = "ward.D2")
parcelles$cluster <- as.factor(cutree(hc, k = 4))

# Carte des clusters
carte_clusters <- ggplot(parcelles) +
  geom_sf(aes(fill = cluster), color = "white", linewidth = 0.3) +
  scale_fill_brewer(palette = "Set2", name = "Cluster") +
  theme_minimal() +
  labs(
    title = "Carte des Clusters de Parcelles",
    subtitle = "Regroupement par profil multi-critères similaire"
  )

print(carte_clusters)

# === ANALYSE SPATIALE DES CLUSTERS ===
cat("\n\n========== ANALYSE SPATIALE DES CLUSTERS ==========\n\n")

# Dictionnaire des noms de familles
noms_familles <- c(
  C = "Carbone", B = "Biodiversité", W = "Eau", A = "Air",
  F = "Fertilité", L = "Paysage", T = "Trame", R = "Résilience",
  S = "Santé", P = "Production", E = "Énergie", N = "Naturalité"
)

k <- 4
parcelles_df <- st_drop_geometry(parcelles)
cols_familles <- grep("^family_", names(parcelles_df), value = TRUE)

cat("SYNTHÈSE PAR CLUSTER :\n\n")
cat(sprintf("  %-10s | %-6s | %-10s | %-10s | %-15s\n", "Cluster", "N", "Surface(ha)", "I_nemeton", "Point fort"))
cat("  -----------|--------|------------|------------|----------------\n")

for (cl in 1:k) {
  parcelles_cl <- parcelles[parcelles$cluster == cl, ]
  n_cl <- nrow(parcelles_cl)
  surface_cl <- sum(parcelles_cl$surface_ha, na.rm = TRUE)
  mean_I <- mean(parcelles_cl$I_nemeton, na.rm = TRUE)

  # Point fort
  scores_cl <- sapply(cols_familles, function(col) mean(st_drop_geometry(parcelles_cl)[[col]], na.rm = TRUE))
  names(scores_cl) <- gsub("family_", "", names(scores_cl))
  best <- names(which.max(scores_cl))

  cat(sprintf("  Cluster %-2d |  %4d  |   %7.1f  |    %.2f    | %s (%s)\n",
              cl, n_cl, surface_cl, mean_I, best, noms_familles[best]))
}

# Comparaison des indices nemeton par cluster
cat("\nCLASSEMENT DES CLUSTERS (par I_nemeton moyen) :\n")
cluster_means <- sapply(1:k, function(cl) mean(parcelles$I_nemeton[parcelles$cluster == cl], na.rm = TRUE))
cluster_order <- order(-cluster_means)
for (i in seq_along(cluster_order)) {
  cl <- cluster_order[i]
  cat(sprintf("  %d. Cluster %d : %.3f\n", i, cl, cluster_means[cl]))
}

cat("\nINTERPRÉTATION :\n")
cat("  La distribution spatiale révèle des zones homogènes.\n")
cat("  Chaque cluster peut correspondre à un type de gestion distinct.\n")
cat("  Cette information guide les recommandations par secteur.\n")
```


---

## Section 7 : Export GeoPackage et CSV

### Exercice 7.1 : Export GeoPackage final

```{r ex-7-1-setup, include=FALSE}
library(sf)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-7-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-7-1-setup"}
# === EXPORT GEOPACKAGE FINAL ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Ajouter les colonnes d'analyse si absentes
if (!"is_hotspot" %in% names(parcelles)) {
  seuil <- quantile(parcelles$I_nemeton, 0.9, na.rm = TRUE)
  parcelles$is_hotspot <- parcelles$I_nemeton >= seuil
}

if (!"classe" %in% names(parcelles)) {
  parcelles$classe <- cut(parcelles$I_nemeton,
    breaks = c(0, 0.4, 0.55, 0.7, 1),
    labels = c("Faible", "Moyen", "Bon", "Excellent"))
}

# Afficher le résumé avant export
cat("=== Résumé des données à exporter ===\n")
cat("Nombre de parcelles:", nrow(parcelles), "\n")
cat("Nombre de colonnes:", ncol(parcelles), "\n")
cat("CRS:", st_crs(parcelles)$epsg, "\n\n")

cat("Distribution par classe:\n")
print(table(parcelles$classe))

# Code d'export (commenté pour le tutoriel)
# output_path <- file.path(cache_dir, "analyse_finale.gpkg")
# st_write(parcelles, output_path, delete_dsn = TRUE)
# cat("\nExport réussi:", output_path)

cat("\n\nFichier serait exporté vers:", file.path(cache_dir, "analyse_finale.gpkg"))
```


### Exercice 7.2 : Export CSV des attributs

```{r ex-7-2-setup, include=FALSE}
library(sf)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-7-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=25, exercise.setup="ex-7-2-setup"}
# === EXPORT CSV ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)
data_export <- st_drop_geometry(parcelles)

# Sélectionner les colonnes pertinentes
cols_export <- c("id", "surface_ha",
                 grep("^family_", names(data_export), value = TRUE),
                 "I_nemeton", "classe")
cols_present <- intersect(cols_export, names(data_export))

data_csv <- data_export[, cols_present]

# Aperçu
cat("=== Aperçu des données CSV ===\n")
print(head(data_csv, 10))

# Code d'export
# csv_path <- file.path(cache_dir, "indicateurs_nemeton.csv")
# write.csv(data_csv, csv_path, row.names = FALSE)
# cat("\nExport CSV réussi:", csv_path)

cat("\n\nFichier CSV serait exporté vers:", file.path(cache_dir, "indicateurs_nemeton.csv"))
```


---

## Section 8 : Carte Interactive Leaflet

### Exercice 8.1 : Créer une carte Leaflet

```{r ex-8-1-setup, include=FALSE}
library(sf)
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r ex-8-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-8-1-setup", fig.width=8, fig.height=6}
# === CARTE LEAFLET INTERACTIVE ===

parcelles_path <- file.path(cache_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Reprojeter en WGS84 pour Leaflet
parcelles <- st_transform(parcelles, 4326)

# Créer la carte avec Leaflet
if (requireNamespace("leaflet", quietly = TRUE)) {

  # Palette de couleurs
  pal <- leaflet::colorNumeric(
    palette = "YlGn",
    domain = parcelles$I_nemeton
  )

  # Créer les popups
  parcelles$popup <- paste0(
    "<b>Parcelle ", parcelles$id, "</b><br>",
    "Surface: ", round(parcelles$surface_ha, 2), " ha<br>",
    "Indice nemeton: ", round(parcelles$I_nemeton, 2), "<br>",
    "Classe: ", parcelles$classe
  )

  # Créer la carte
  carte <- leaflet::leaflet(parcelles) |>
    leaflet::addProviderTiles("OpenStreetMap") |>
    leaflet::addPolygons(
      fillColor = ~pal(I_nemeton),
      fillOpacity = 0.7,
      color = "white",
      weight = 1,
      popup = ~popup
    ) |>
    leaflet::addLegend(
      position = "bottomright",
      pal = pal,
      values = ~I_nemeton,
      title = "Indice nemeton"
    )

  carte

} else {
  cat("Le package leaflet n'est pas installé.\n")
  cat("Installez-le avec: install.packages('leaflet')")
}

# === ANALYSE DE LA CARTE INTERACTIVE ===
cat("\n\n========== ANALYSE DE LA CARTE INTERACTIVE ==========\n\n")

# Statistiques générales
cat("DONNÉES CARTOGRAPHIÉES :\n")
cat(sprintf("  Nombre de parcelles : %d\n", nrow(parcelles)))
cat(sprintf("  Surface totale : %.1f ha\n", sum(parcelles$surface_ha, na.rm = TRUE)))

# Distribution de l'indice nemeton
cat("\nDISTRIBUTION DE L'INDICE NEMETON :\n")
cat(sprintf("  Min : %.3f\n", min(parcelles$I_nemeton, na.rm = TRUE)))
cat(sprintf("  Max : %.3f\n", max(parcelles$I_nemeton, na.rm = TRUE)))
cat(sprintf("  Moyenne : %.3f\n", mean(parcelles$I_nemeton, na.rm = TRUE)))
cat(sprintf("  Médiane : %.3f\n", median(parcelles$I_nemeton, na.rm = TRUE)))

# Distribution par classe si disponible
if ("classe" %in% names(parcelles)) {
  cat("\nRÉPARTITION PAR CLASSE :\n")
  tab_classe <- table(parcelles$classe)
  for (cl in names(tab_classe)) {
    pct <- 100 * tab_classe[cl] / sum(tab_classe)
    cat(sprintf("  %s : %d parcelles (%.1f%%)\n", cl, tab_classe[cl], pct))
  }
}

# Emprise géographique
bbox <- st_bbox(parcelles)
cat("\nEMPRISE GÉOGRAPHIQUE (WGS84) :\n")
cat(sprintf("  Longitude : %.4f° à %.4f°\n", bbox["xmin"], bbox["xmax"]))
cat(sprintf("  Latitude : %.4f° à %.4f°\n", bbox["ymin"], bbox["ymax"]))

cat("\nFONCTIONNALITÉS DE LA CARTE :\n")
cat("  - Cliquez sur une parcelle pour voir ses détails\n")
cat("  - Utilisez la molette pour zoomer\n")
cat("  - La légende indique l'échelle de couleurs (vert = meilleur score)\n")
```


---

## Section 9 : Quiz Final

```{r quiz-final, echo=FALSE}
quiz(
  caption = "Testez vos connaissances",
  question("Qu'est-ce qu'un hotspot dans l'analyse nemeton ?",
    answer("Une parcelle avec un indice faible"),
    answer("Une parcelle dont l'indice dépasse un seuil élevé (ex: P90)", correct = TRUE),
    answer("Une parcelle avec beaucoup de biodiversité"),
    answer("Une parcelle à risque incendie"),
    correct = "Les hotspots sont les parcelles ayant les meilleurs scores globaux.",
    incorrect = "Un hotspot est une parcelle avec un indice composite très élevé.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Que signifie une corrélation négative entre Production et Biodiversité ?",
    answer("Ces deux familles n'ont aucun lien"),
    answer("Améliorer la production améliore la biodiversité"),
    answer("Il existe un compromis entre les deux", correct = TRUE),
    answer("Les données sont incorrectes"),
    correct = "Une corrélation négative indique un compromis : optimiser une dimension peut dégrader l'autre.",
    incorrect = "Une corrélation négative révèle un compromis entre les deux dimensions.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Qu'est-ce que le front de Pareto ?",
    answer("L'ensemble des parcelles les plus grandes"),
    answer("L'ensemble des solutions optimales non dominées", correct = TRUE),
    answer("L'ensemble des parcelles à risque"),
    answer("La moyenne des indicateurs"),
    correct = "Le front de Pareto identifie les solutions où on ne peut améliorer une dimension sans dégrader une autre.",
    incorrect = "Les points Pareto-optimaux sont ceux qui ne sont dominés par aucun autre point.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Pourquoi utilise-t-on le clustering des parcelles ?",
    answer("Pour réduire le nombre de parcelles"),
    answer("Pour regrouper les parcelles avec des profils similaires", correct = TRUE),
    answer("Pour augmenter la précision des indicateurs"),
    answer("Pour corriger les erreurs de calcul"),
    correct = "Le clustering permet d'identifier des groupes de parcelles partageant des caractéristiques communes.",
    incorrect = "Le clustering regroupe les parcelles ayant des profils multi-critères similaires.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Quel format est recommandé pour exporter des données spatiales avec leurs attributs ?",
    answer("CSV uniquement"),
    answer("PNG"),
    answer("GeoPackage (.gpkg)", correct = TRUE),
    answer("Word document"),
    correct = "Le GeoPackage préserve à la fois la géométrie et les attributs dans un format standard.",
    incorrect = "Le GeoPackage est le format moderne recommandé pour les données géospatiales.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  )
)
```

---

## Conclusion

### Félicitations !

Vous avez terminé la série complète des tutoriels nemeton !

### Récapitulatif de la série

| Tutorial | Contenu | Indicateurs |
|----------|---------|-------------|
| T01 | Acquisition données | Zone d'étude, cache |
| T02 | Traitement LiDAR | C1, P1, P3, B2, E1, A1 |
| T03 | Indicateurs terrain | W1-W3, R1-R3, S1-S3, P2, F1 |
| T04 | Indicateurs écologiques | B1-B3, L1-L2, T1-T2, A2, F2, N1-N3 |
| T05 | Assemblage & normalisation | Indices famille, I_nemeton |
| T06 | Analyse & export | Cartes, radar, hotspots, Pareto |

### Compétences acquises

- Télécharger et gérer des données géographiques françaises
- Traiter des nuages de points LiDAR HD
- Calculer 40+ indicateurs forestiers
- Normaliser et agréger en indices composites
- Visualiser avec des cartes thématiques et radars
- Identifier hotspots et solutions Pareto-optimales
- Exporter en GeoPackage, CSV et carte interactive

### Prochaines étapes

1. **Appliquer** nemeton à votre propre territoire
2. **Personnaliser** les pondérations selon vos priorités
3. **Explorer** les fonctions avancées du package
4. **Contribuer** au projet sur GitHub

### Ressources

- [Documentation nemeton](https://forestsoils.github.io/nemeton/)
- [GitHub nemeton](https://github.com/forestsoils/nemeton)
- [Référentiel des 12 familles](https://forestsoils.github.io/nemeton/articles/complete-referential_fr.html)

```{r conclusion, echo=FALSE}
cat("
╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║   Merci d'avoir suivi la série de tutoriels nemeton !        ║
║                                                               ║
║   Pour toute question ou contribution, visitez :              ║
║   https://github.com/forestsoils/nemeton                      ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝
")
```

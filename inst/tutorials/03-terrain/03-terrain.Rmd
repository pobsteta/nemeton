---
title: "Tutorial 03 : Terrain — Familles W, R, S, F (11 indicateurs)"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Calcul de 11 indicateurs terrain : W1-3 (eau/TWI), R1-4 (risques),
  S1-3 (accessibilité sociale), F1 (érosion sol).
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
gradethis::gradethis_setup()
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
options(tutorial.exercise.timelimit = 300)

# Configuration des timeouts réseau (5 minutes)
NETWORK_TIMEOUT <- 300
options(
  timeout = NETWORK_TIMEOUT,
  HTTPUserAgent = "nemeton-tutorial/1.0"
)

# Configuration httr (connect + request timeout)
if (requireNamespace("httr", quietly = TRUE)) {
  httr::set_config(httr::config(
    connecttimeout = NETWORK_TIMEOUT,
    timeout = NETWORK_TIMEOUT
  ))
}

# Configuration GDAL/curl pour happign
Sys.setenv(
  GDAL_HTTP_TIMEOUT = as.character(NETWORK_TIMEOUT),
  GDAL_HTTP_CONNECTTIMEOUT = as.character(NETWORK_TIMEOUT),
  CURL_SSL_BACKEND = "openssl"
)
```

## Bienvenue

### Objectifs du tutoriel

Ce tutoriel vous guide dans le calcul des **indicateurs terrain** pour les familles nemeton :

- **W** (Eau) : TWI, réseau hydrographique, zones humides
- **R** (Risques) : feu, tempête, sécheresse
- **S** (Social) : accessibilité, proximité, sentiers
- **F1** (Érosion) : risque érosion

### Prérequis

Données du Tutorial 01 :
- `mnt.tif` : Modèle Numérique de Terrain
- `parcelles.gpkg` : Parcelles cadastrales
- `routes.gpkg` : Réseau routier (BD TOPO)
- `cours_eau.gpkg` : Cours d'eau (BD TOPO)

---

## Section 1 : Dérivés topographiques et érosion (F1)

### Exercice 1.1 : Pente et exposition

La **pente** et l'**exposition** sont les dérivés de base du MNT.

```{r ex-1-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-1-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=25, exercise.setup="ex-1-1-setup"}
# === CALCUL PENTE ET EXPOSITION ===

mnt_path <- file.path(data_dir, "mnt.tif")

if (file.exists(mnt_path)) {
  mnt <- rast(mnt_path)

  # Calculer la pente (en degrés)
  pente <- terrain(mnt, v = "slope", unit = "degrees")

  # Calculer l'exposition (0 = Nord, 90 = Est, etc.)
  exposition <- terrain(mnt, v = "aspect", unit = "degrees")

  cat("=== Pente ===\n")
  stats_pente <- global(pente, c("min", "max", "mean"), na.rm = TRUE)
  cat("Min:", round(stats_pente$min, 1), "°\n")
  cat("Max:", round(stats_pente$max, 1), "°\n")
  cat("Moyenne:", round(stats_pente$mean, 1), "°\n")

  # Sauvegarder
  writeRaster(pente, file.path(data_dir, "pente.tif"), overwrite = TRUE)
  writeRaster(exposition, file.path(data_dir, "exposition.tif"), overwrite = TRUE)
  cat("\nRasters sauvegardés.\n")
} else {
  cat("MNT non trouvé. Exécutez le Tutorial 01.\n")
}
```

### Exercice 1.2 : Risque d'érosion F1 (RUSLE simplifié)

L'indicateur **F1** évalue le risque d'érosion des sols selon une version simplifiée de l'équation **RUSLE** (Revised Universal Soil Loss Equation) :

```
A = R × K × LS × C × P
```

| Facteur | Description | Valeur utilisée |
|---------|-------------|-----------------|
| **R** | Érosivité des pluies | 1.0 (normalisé) |
| **K** | Érodabilité du sol | 0.3 (sol moyen) |
| **LS** | Facteur pente/longueur | Calculé depuis MNT |
| **C** | Couverture végétale | 0.01 (forêt) à 1.0 (sol nu) |
| **P** | Pratiques conservation | 1.0 (pas de pratiques) |

Pour simplifier, nous calculons :
```
F1 = LS × C_forest
```

Où **LS** est dérivé de la pente et **C_forest** est inversement proportionnel à la couverture forestière.

```{r ex-1-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-1-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=75, exercise.setup="ex-1-2-setup"}
# === CALCUL F1 - RISQUE ÉROSION (RUSLE SIMPLIFIÉ) ===

mnt_path <- file.path(data_dir, "mnt.tif")
parcelles_path <- file.path(data_dir, "parcelles.gpkg")
bdforet_path <- file.path(data_dir, "bd_foret.gpkg")

if (file.exists(mnt_path) && file.exists(parcelles_path)) {
  mnt <- rast(mnt_path)
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul F1 (RUSLE simplifié) ===\n\n")

  # 1. Calculer la pente en radians
  pente_deg <- terrain(mnt, v = "slope", unit = "degrees")
  pente_rad <- pente_deg * pi / 180

  # 2. Calculer le facteur LS (McCool et al., 1987)
  # LS = (flow_accumulation / 22.13)^0.4 × (sin(pente) / 0.0896)^1.3
  # Version simplifiée sans accumulation de flux :
  # LS = (pente_deg / 9)^1.4 pour pente < 9%
  # LS = (sin(pente) / 0.0896)^1.3 pour pente >= 9%

  cat("1. Calcul du facteur LS (longueur-pente)...\n")
  LS <- ifel(
    pente_deg < 5,
    (pente_deg / 5)^1.2,
    (sin(pente_rad) / 0.0896)^1.3
  )
  LS <- clamp(LS, lower = 0, upper = 20) # Limiter les valeurs extrêmes

  cat("   LS min:", round(global(LS, "min", na.rm = TRUE)$min, 2), "\n")
  cat("   LS max:", round(global(LS, "max", na.rm = TRUE)$max, 2), "\n")
  cat("   LS moyen:", round(global(LS, "mean", na.rm = TRUE)$mean, 2), "\n")

  # 3. Calculer le facteur C (couverture végétale)
  # C = 0.01 pour forêt dense, 0.1 pour forêt claire, 1.0 pour sol nu
  cat("\n2. Calcul du facteur C (couverture)...\n")

  if (file.exists(bdforet_path)) {
    bd_foret <- st_read(bdforet_path, quiet = TRUE)
    # Rasteriser la BD Forêt (1 = forêt, 0 = non-forêt)
    foret_raster <- rasterize(vect(bd_foret), mnt, field = 1, background = 0)
    # C = 0.01 pour forêt, 0.5 pour non-forêt (prairie/culture)
    C_factor <- ifel(foret_raster == 1, 0.01, 0.5)
    cat("   BD Forêt utilisée pour le facteur C\n")
  } else {
    # Si pas de BD Forêt, utiliser une valeur par défaut (forêt)
    C_factor <- mnt * 0 + 0.05 # Valeur intermédiaire forêt
    cat("   BD Forêt non disponible, C = 0.05 (forêt moyenne)\n")
  }

  # 4. Calculer F1 = LS × C (normalisé 0-1)
  cat("\n3. Calcul de F1 = LS × C...\n")
  F1_raster <- LS * C_factor

  # Normaliser entre 0 et 1 (0 = pas d'érosion, 1 = érosion maximale)
  F1_max <- global(F1_raster, "max", na.rm = TRUE)$max
  F1_raster <- F1_raster / F1_max
  F1_raster <- clamp(F1_raster, lower = 0, upper = 1)

  cat("\n=== Résultats F1 (raster) ===\n")
  cat("F1 min:", round(global(F1_raster, "min", na.rm = TRUE)$min, 3), "\n")
  cat("F1 max:", round(global(F1_raster, "max", na.rm = TRUE)$max, 3), "\n")
  cat("F1 moyen:", round(global(F1_raster, "mean", na.rm = TRUE)$mean, 3), "\n")

  # Sauvegarder le raster F1
  writeRaster(F1_raster, file.path(data_dir, "erosion_f1.tif"), overwrite = TRUE)
  cat("\nRaster F1 sauvegardé: erosion_f1.tif\n")

  # 5. Extraire F1 par parcelle
  cat("\n4. Extraction F1 par parcelle...\n")
  if (requireNamespace("exactextractr", quietly = TRUE)) {
    parcelles$F1 <- exactextractr::exact_extract(F1_raster, parcelles, fun = "mean")
  } else {
    parcelles$F1 <- terra::extract(F1_raster, vect(parcelles), fun = mean, na.rm = TRUE)[, 2]
  }

  cat("\n=== F1 par parcelle ===\n")
  cat("F1 min:", round(min(parcelles$F1, na.rm = TRUE), 3), "\n")
  cat("F1 max:", round(max(parcelles$F1, na.rm = TRUE), 3), "\n")
  cat("F1 moyen:", round(mean(parcelles$F1, na.rm = TRUE), 3), "\n")

  # Sauvegarder les parcelles avec F1
  output_path <- file.path(data_dir, "metriques_erosion_f1.gpkg")
  st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
  st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
  cat("\n=== Métriques F1 érosion exportées ===\n")
  cat("Fichier:", output_path, "\n")
  cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
} else {
  cat("Fichiers non trouvés. Exécutez le Tutorial 01.\n")
}
```

### Interprétation de F1

| Score F1 | Classe | Description |
|----------|--------|-------------|
| 0.0 - 0.1 | Très faible | Risque négligeable (forêt dense, pente faible) |
| 0.1 - 0.3 | Faible | Risque limité (bonne couverture) |
| 0.3 - 0.5 | Modéré | Vigilance requise |
| 0.5 - 0.7 | Élevé | Risque significatif |
| 0.7 - 1.0 | Très élevé | Risque majeur (pente forte, sol nu) |

---

## Section 2 : TWI - Indice d'Humidité Topographique (W3)

### Principe du TWI

Le **TWI** (Topographic Wetness Index) prédit l'accumulation d'eau en fonction de la topographie :

```
TWI = ln(a / tan(β))
```

Où `a` = aire drainée amont (Specific Catchment Area), `β` = pente locale.

Le calcul correct du TWI nécessite :
1. **Remplissage des dépressions** du MNT
2. **Direction d'écoulement** (flow direction)
3. **Accumulation de flux** (flow accumulation)
4. **Calcul final** : TWI = ln(SCA / tan(pente))

Nous utilisons **fasterRaster** qui interface GRASS GIS pour ces calculs hydrologiques.

```{r ex-2-1-setup}
library(sf)
library(terra)
library(fasterRaster)
faster(grassDir = "/usr/lib/grass84")
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-2-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=65, exercise.setup="ex-2-1-setup", exercise.timelimit=600}
# === CALCUL DU TWI AVEC fasterRaster ===
mnt_path <- file.path(data_dir, "mnt.tif")
parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(mnt_path)) {
  mnt <- rast(mnt_path)
  cat("MNT chargé:", ncol(mnt), "x", nrow(mnt), "pixels\n")
  cat("Résolution:", res(mnt)[1], "m\n\n")

  # Convertir le MNT en GRaster (format GRASS)
  cat("=== Conversion vers GRASS ===\n")
  elev <- fast(mnt)
  cat("GRaster créé:", nrow(elev), "x", ncol(elev), "\n\n")

  # Calculer le TWI avec la fonction wetness()
  # Cette fonction calcule automatiquement :
  # - L'accumulation de flux (Specific Catchment Area)
  # - La pente locale
  # - Le TWI = ln(SCA / tan(pente))
  cat("=== Calcul du TWI ===\n")
  twi_grass <- wetness(elev)

  # Convertir en terra raster pour export
  twi_terra <- rast(twi_grass)

  cat("\n=== Résultats TWI (raster) ===\n")
  stats <- global(twi_terra, c("min", "max", "mean", "sd"), na.rm = TRUE)
  cat("TWI min:", round(stats$min, 2), "\n")
  cat("TWI max:", round(stats$max, 2), "\n")
  cat("TWI moyen:", round(stats$mean, 2), "\n")
  cat("TWI écart-type:", round(stats$sd, 2), "\n")

  # Sauvegarder le raster
  twi_path <- file.path(data_dir, "twi.tif")
  writeRaster(twi_terra, twi_path, overwrite = TRUE)
  cat("\nTWI raster sauvegardé:", twi_path, "\n")

  # === EXTRACTION PAR PARCELLE (W3) ===
  if (file.exists(parcelles_path)) {
    parcelles <- st_read(parcelles_path, quiet = TRUE)

    cat("\n=== Extraction W3 par parcelle ===\n")
    cat("Parcelles:", nrow(parcelles), "\n")

    # Extraire le TWI moyen par parcelle avec exactextractr
    library(exactextractr)
    parcelles$W3 <- exact_extract(twi_terra, parcelles, fun = "mean")

    cat("\n=== Indicateur W3 (TWI moyen par parcelle) ===\n")
    cat("W3 min:", round(min(parcelles$W3, na.rm = TRUE), 2), "\n")
    cat("W3 max:", round(max(parcelles$W3, na.rm = TRUE), 2), "\n")
    cat("W3 moyen:", round(mean(parcelles$W3, na.rm = TRUE), 2), "\n")

    # Sauvegarder les parcelles avec W3
    output_path <- file.path(data_dir, "metriques_twi_w3.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("\n=== Métriques W3 TWI exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  }
} else {
  cat("MNT non trouvé. Exécutez le Tutorial 01.\n")
}
```


### Interprétation du TWI

| Valeur TWI | Interprétation | Caractéristiques |
|------------|----------------|------------------|
| < 6 | Très sec | Crêtes, pentes fortes |
| 6-9 | Sec | Versants bien drainés |
| 9-12 | Intermédiaire | Mi-pente |
| 12-15 | Humide | Bas de pente, convergence |
| > 15 | Très humide | Fonds de vallée, zones humides |

---

## Section 3 : Réseau hydrographique (W1, W2)

### Exercice 3.1 : Densité du réseau hydrographique (W1)

```{r ex-3-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-3-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-3-1-setup"}
# === DENSITÉ DU RÉSEAU HYDROGRAPHIQUE (W1) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
cours_eau_path <- file.path(data_dir, "cours_eau.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  if (file.exists(cours_eau_path)) {
    # Charger les cours d'eau (téléchargés dans Tutorial 01)
    cours_eau <- st_read(cours_eau_path, quiet = TRUE)
    cat("Cours d'eau chargés:", nrow(cours_eau), "entités\n\n")

    if (nrow(cours_eau) > 0) {
      # Calculer la densité du réseau hydro (m/ha) pour chaque parcelle
      calc_w1 <- function(i) {
        hydro_in <- st_intersection(cours_eau, parcelles[i, ])
        if (nrow(hydro_in) > 0) {
          longueur_m <- sum(st_length(hydro_in))
          surface_ha <- as.numeric(st_area(parcelles[i, ])) / 10000
          as.numeric(longueur_m / surface_ha)
        } else {
          0
        }
      }

      # Parallélisation avec furrr si disponible
      if (requireNamespace("furrr", quietly = TRUE) && requireNamespace("future", quietly = TRUE)) {
        library(furrr)
        library(future)
        plan(multisession, workers = max(1, availableCores() - 1))
        cat("Mode parallèle (furrr,", nbrOfWorkers(), "workers)...\n")
        parcelles$W1 <- future_map_dbl(seq_len(nrow(parcelles)), calc_w1, .progress = TRUE)
        plan(sequential)
      } else if (requireNamespace("purrr", quietly = TRUE)) {
        library(purrr)
        cat("Mode séquentiel (purrr)...\n")
        parcelles$W1 <- map_dbl(seq_len(nrow(parcelles)), calc_w1)
      } else {
        cat("Mode séquentiel (base R)...\n")
        parcelles$W1 <- sapply(seq_len(nrow(parcelles)), calc_w1)
      }

      cat("=== Indicateur W1 (Densité réseau hydro) ===\n")
      cat("Densité min:", round(min(parcelles$W1), 1), "m/ha\n")
      cat("Densité max:", round(max(parcelles$W1), 1), "m/ha\n")
      cat("Densité moyenne:", round(mean(parcelles$W1), 1), "m/ha\n")

      # Sauvegarder
      output_path <- file.path(data_dir, "metriques_densite_hydro_w1.gpkg")
      st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
      st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
      cat("\n=== Métriques W1 Densité réseau hydro exportées ===\n")
      cat("Fichier:", output_path, "\n")
      cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
    } else {
      cat("Aucun cours d'eau dans la zone.\n")
    }
  } else {
    cat("Fichier cours_eau.gpkg non trouvé.\n")
    cat("Exécutez l'exercice 4.3 du Tutorial 01.\n")
  }
} else {
  cat("Parcelles non trouvées. Exécutez le Tutorial 01.\n")
}
```


### Exercice 3.2 : Couverture en zones humides (W2)

```{r ex-3-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-3-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=40, exercise.setup="ex-3-2-setup"}
# === COUVERTURE EN ZONES HUMIDES (W2) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
twi_path <- file.path(data_dir, "twi.tif")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  if (file.exists(twi_path)) {
    twi <- rast(twi_path)

    # Les zones humides sont identifiées par un TWI élevé (> 12)
    # Seuil basé sur la littérature (Beven & Kirkby)
    seuil_zh <- 12
    zones_humides <- twi > seuil_zh

    # Calculer le pourcentage de zones humides par parcelle
    if (requireNamespace("exactextractr", quietly = TRUE)) {
      parcelles$W2 <- exactextractr::exact_extract(
        zones_humides, parcelles,
        fun = "mean"
      ) * 100
    } else {
      # Fallback avec terra
      parcelles$W2 <- sapply(seq_len(nrow(parcelles)), function(i) {
        vals <- extract(zones_humides, vect(parcelles[i, ]))[[2]]
        mean(vals, na.rm = TRUE) * 100
      })
    }

    cat("=== Indicateur W2 (Couverture zones humides) ===\n")
    cat("Seuil TWI utilisé:", seuil_zh, "\n\n")
    cat("% zones humides min:", round(min(parcelles$W2, na.rm = TRUE), 1), "%\n")
    cat("% zones humides max:", round(max(parcelles$W2, na.rm = TRUE), 1), "%\n")
    cat("% zones humides moyen:", round(mean(parcelles$W2, na.rm = TRUE), 1), "%\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_couverture_zone_humide_w2.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("\n=== Métriques W2 Couverture zones humides exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("TWI non trouvé. Exécutez d'abord l'exercice 2.1.\n")
  }
} else {
  cat("Parcelles non trouvées. Exécutez le Tutorial 01.\n")
}
```


---

## Section 4 : Indicateurs de risque (R1, R2, R3, R4)

### Exercice 4.1 : Exposition au feu (R1)

L'**exposition au feu** mesure la proportion de végétation combustible dans un rayon donné autour de chaque cellule. Nous utilisons le package **fireexposuR** qui implémente la méthodologie de Beverly et al.

Le métrique d'exposition varie de 0 à 1 :
- **0** = aucune végétation combustible à proximité
- **1** = 100% de végétation combustible dans le rayon d'analyse

```{r ex-4-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-4-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-4-1-setup", exercise.timelimit=600}
# === EXPOSITION AU FEU (R1) avec fireexposuR ===

mnt_path <- file.path(data_dir, "mnt.tif")
parcelles_path <- file.path(data_dir, "parcelles.gpkg")
bdforet_path <- file.path(data_dir, "bd_foret.gpkg")

if (file.exists(mnt_path) && file.exists(parcelles_path) && file.exists(bdforet_path)) {
  mnt <- rast(mnt_path)
  parcelles <- st_read(parcelles_path, quiet = TRUE)
  bd_foret <- st_read(bdforet_path, quiet = TRUE)

  cat("=== Préparation des données ===\n")
  cat("Parcelles:", nrow(parcelles), "\n")
  cat("Polygones BD Forêt:", nrow(bd_foret), "\n\n")

  # Créer le raster binaire de danger (forêt = 1, non-forêt = 0)
  # Rasteriser la BD Forêt sur la grille du MNT
  cat("Création du raster de danger (végétation combustible)...\n")
  hazard <- rasterize(vect(bd_foret), mnt, field = 1, background = 0)
  names(hazard) <- "hazard"

  if (requireNamespace("fireexposuR", quietly = TRUE)) {
    library(fireexposuR)

    # Calculer l'exposition au feu (distance 500m par défaut)
    cat("Calcul de l'exposition au feu (rayon 500m)...\n")
    exposure <- fire_exp(hazard, t_dist = 500)

    cat("\n=== Résultats exposition au feu ===\n")
    stats <- global(exposure, c("min", "max", "mean", "sd"), na.rm = TRUE)
    cat("Exposition min:", round(stats$min, 3), "\n")
    cat("Exposition max:", round(stats$max, 3), "\n")
    cat("Exposition moyenne:", round(stats$mean, 3), "\n")

    # Extraire par parcelle
    if (requireNamespace("exactextractr", quietly = TRUE)) {
      parcelles$R1 <- exactextractr::exact_extract(exposure, parcelles, fun = "mean")

      cat("\n=== Exposition par parcelle ===\n")
      cat("R1 min:", round(min(parcelles$R1, na.rm = TRUE), 3), "\n")
      cat("R1 max:", round(max(parcelles$R1, na.rm = TRUE), 3), "\n")
      cat("R1 moyenne:", round(mean(parcelles$R1, na.rm = TRUE), 3), "\n")
    }

    # Sauvegarder le raster d'exposition
    writeRaster(exposure, file.path(data_dir, "fire_exposure.tif"), overwrite = TRUE)
    cat("\nRaster d'exposition sauvegardé.\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_exposition_feu_r1.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("\n=== Métriques R1 Exposition au feu exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Package fireexposuR non installé.\n")
    cat("Installation: install.packages('fireexposuR')\n")
  }
} else {
  cat("Fichiers non trouvés. Vérifiez le Tutorial 01.\n")
}
```


### Interprétation de l'exposition au feu

| Exposition | Niveau de risque | Recommandation |
|------------|------------------|----------------|
| < 0.2 | Faible | Zone tampon efficace |
| 0.2-0.5 | Modéré | Surveillance normale |
| 0.5-0.8 | Élevé | Débroussaillage recommandé |
| > 0.8 | Très élevé | Priorité de gestion |

### Exercice 4.2 : Risque tempête (R2)

Le **risque tempête** est modélisé avec :
- **nasapower** : données climatiques NASA POWER (vitesse et direction du vent)
- **microclima** : coefficient d'abri au vent (`windcoef`)

L'exposition au vent est calculée par :
1. La **direction du vent dominant** (données NASA POWER climatologie)
2. Le **coefficient d'abri** (microclima) : 0 = totalement exposé, 1 = totalement abrité
3. **R2 = 1 - coefficient d'abri** : zones exposées = risque élevé

```{r ex-4-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-4-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=95, exercise.setup="ex-4-2-setup", exercise.timelimit=600}
# === RISQUE TEMPÊTE (R2) avec nasapower + microclima ===

mnt_path <- file.path(data_dir, "mnt.tif")
parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(mnt_path) && file.exists(parcelles_path)) {
  mnt <- rast(mnt_path)
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  # Coordonnées du centroïde en WGS84
  centroid_wgs84 <- st_coordinates(st_centroid(st_transform(st_union(parcelles), 4326)))
  lon <- centroid_wgs84[1, "X"]
  lat <- centroid_wgs84[1, "Y"]

  # === 1. Données de vent avec nasapower ===
  # Pour le risque tempête : vitesse MAX (pas moyenne)
  wind_dir <- 270
  wind_speed_max <- 15

  if (requireNamespace("nasapower", quietly = TRUE)) {
    library(nasapower)
    cat("=== Téléchargement données vent (NASA POWER) ===\n")

    wind_data <- tryCatch(
      {
        # Climatologie mensuelle (moyenne 30 ans)
        # WS10M_MAX = vitesse maximale du vent à 10m
        # WD10M = direction du vent à 10m
        nasapower::get_power(
          community = "ag",
          lonlat = c(lon, lat),
          pars = c("WS10M_MAX", "WD10M"),
          temporal_api = "climatology"
        )
      },
      error = function(e) {
        cat("Erreur nasapower:", conditionMessage(e), "\n")
        NULL
      }
    )

    if (!is.null(wind_data) && nrow(wind_data) > 0) {
      # Extraire les valeurs mensuelles (colonnes JAN à DEC = 4:15)
      wd_values <- as.numeric(wind_data[wind_data$PARAMETER == "WD10M", 4:15])
      ws_max_values <- as.numeric(wind_data[wind_data$PARAMETER == "WS10M_MAX", 4:15])

      # Direction dominante = moyenne pondérée par la vitesse max
      wind_dir <- round(weighted.mean(wd_values, ws_max_values, na.rm = TRUE))
      # Vitesse max = maximum des maximums mensuels (pire cas sur 30 ans)
      wind_speed_max <- round(max(ws_max_values, na.rm = TRUE), 1)

      cat("✓ Direction dominante:", wind_dir, "° (climatologie MERRA-2)\n")
      cat("✓ Vitesse max enregistrée:", wind_speed_max, "m/s\n")
      cat("  Source: NASA POWER WS10M_MAX (max sur 30 ans)\n")
    } else {
      cat("⚠ Données non disponibles, valeurs par défaut\n")
    }
  } else {
    cat("nasapower non installé, valeurs par défaut\n")
    cat("Installez nasapower: install.packages('nasapower')\n")
  }

  cat("Direction utilisée:", wind_dir, "° | Vitesse max:", wind_speed_max, "m/s\n")

  # === 2. Coefficient d'abri au vent avec microclima ===
  cat("\n=== Calcul coefficient d'abri (microclima) ===\n")

  reso <- res(mnt)[1] # Résolution du MNT

  if (requireNamespace("microclima", quietly = TRUE)) {
    library(microclima)

    # windcoef calcule le coefficient d'abri (0-1)
    # 0.5 = vitesse du vent réduite de 50%
    shelter_coef <- tryCatch(
      {
        windcoef(
          dsm = mnt,
          direction = wind_dir,
          hgt = 10, # Hauteur de mesure (10m standard)
          reso = reso # Résolution du MNT
        )
      },
      error = function(e) {
        cat("Erreur microclima:", conditionMessage(e), "\n")
        NULL
      }
    )

    if (!is.null(shelter_coef)) {
      # Convertir en SpatRaster si nécessaire
      if (!inherits(shelter_coef, "SpatRaster")) {
        shelter_coef <- rast(shelter_coef)
        crs(shelter_coef) <- crs(mnt)
        ext(shelter_coef) <- ext(mnt)
      }

      # R2 = 1 - shelter_coef (exposé = faible abri)
      R2_raster <- 1 - shelter_coef
      cat("Méthode: microclima::windcoef\n")
    } else {
      R2_raster <- NULL
    }
  } else {
    cat("microclima non installé\n")
    R2_raster <- NULL
  }

  # === 3. Fallback si microclima non disponible ===
  if (is.null(R2_raster)) {
    cat("Utilisation méthode alternative (dérivés MNT)...\n")

    aspect <- terrain(mnt, v = "aspect", unit = "degrees")
    pente <- terrain(mnt, v = "slope", unit = "degrees")
    tri <- terrain(mnt, v = "TRI")

    # Exposition face au vent
    diff_angle <- abs(aspect - wind_dir)
    diff_angle <- min(diff_angle, 360 - diff_angle)
    expo_vent <- 1 - (diff_angle / 180)

    # Normaliser pente et TRI
    pente_norm <- clamp(pente / 45, lower = 0, upper = 1)
    tri_norm <- clamp(tri / global(tri, "max", na.rm = TRUE)$max, lower = 0, upper = 1)

    R2_raster <- expo_vent * (0.6 * pente_norm + 0.4 * tri_norm)
  }

  R2_raster <- clamp(R2_raster, lower = 0, upper = 1)

  cat("\nR2 raster min:", round(global(R2_raster, "min", na.rm = TRUE)$min, 3), "\n")
  cat("R2 raster max:", round(global(R2_raster, "max", na.rm = TRUE)$max, 3), "\n")

  # === 4. Extraire par parcelle ===
  cat("\n=== R2 par parcelle ===\n")
  if (requireNamespace("exactextractr", quietly = TRUE)) {
    parcelles$R2 <- exactextractr::exact_extract(R2_raster, parcelles, fun = "mean")
  } else {
    parcelles$R2 <- extract(R2_raster, vect(parcelles), fun = mean, na.rm = TRUE)[, 2]
  }
  cat("R2 min:", round(min(parcelles$R2, na.rm = TRUE), 3), "\n")
  cat("R2 max:", round(max(parcelles$R2, na.rm = TRUE), 3), "\n")
  cat("R2 moyenne:", round(mean(parcelles$R2, na.rm = TRUE), 3), "\n")

  # Sauvegarder
  writeRaster(R2_raster, file.path(data_dir, "storm_exposure.tif"), overwrite = TRUE)
  cat("\nRaster sauvegardé: storm_exposure.tif\n")

  # Sauvegarder
  output_path <- file.path(data_dir, "metriques_exposition_tempete_r2.gpkg")
  st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
  st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
  cat("\n=== Métriques R2 Exposition au tempête exportées ===\n")
  cat("Fichier:", output_path, "\n")
  cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
} else {
  cat("Fichiers non trouvés.\n")
}
```


### Interprétation de l'exposition aux tempêtes

| Valeur R2 | Statut | Description |
|-----------|--------|-------------|
| 0 | Protégé | Zone abritée par le relief |
| 1 | Exposé | Zone face au vent dominant |

### Exercice 4.3 : Risque sécheresse (R3)

Le **risque sécheresse** combine :
1. **Indice climatique** (SPEI) : même pour toute la zone d'étude
2. **Modulation topographique** : varie par parcelle selon :
   - **Exposition** : sud = plus d'évaporation = risque accru
   - **Pente** : forte pente = ruissellement = moins de rétention
   - **TWI** : faible TWI = terrain sec = risque accru

Formule : `R3 = 0.6 × R3_climat + 0.4 × R3_topo`

Packages utilisés :
- **SPEI** : calcul de l'indice SPEI (évapotranspiration Hargreaves)
- **terra** : dérivés topographiques (aspect, pente, TWI)

```{r ex-4-3-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-4-3, exercise=TRUE, exercise.eval=FALSE, exercise.lines=110, exercise.setup="ex-4-3-setup", exercise.timelimit=900}
# === RISQUE SÉCHERESSE (R3) avec SPEI + modulation topographique ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
mnt_path <- file.path(data_dir, "mnt.tif")
twi_path <- file.path(data_dir, "twi.tif")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)
  bbox_wgs84 <- st_bbox(st_transform(parcelles, 4326))
  lat_mean <- mean(bbox_wgs84[c("ymin", "ymax")])

  # === 1. Indice climatique de base (SPEI) ===
  R3_climat <- 0.5 # Valeur par défaut

  if (requireNamespace("SPEI", quietly = TRUE)) {
    library(SPEI)
    cat("=== Calcul indice climatique (SPEI) ===\n")

    # Données simulées (remplacer par QBMS si configuré)
    set.seed(42)
    precip <- rnorm(60, mean = 70, sd = 30)
    temp <- 10 + 8 * sin(seq(0, 10 * pi, length.out = 60))

    # ETP Hargreaves et SPEI-3
    pet <- hargreaves(Tmin = temp - 3, Tmax = temp + 3, lat = lat_mean)
    bal <- precip - pet
    spei_3 <- spei(ts(bal, frequency = 12), scale = 3)

    spei_recent <- mean(tail(spei_3$fitted, 12), na.rm = TRUE)
    R3_climat <- max(0, min(1, (-spei_recent + 2) / 4))
    cat("SPEI-3 récent:", round(spei_recent, 2), "\n")
    cat("R3 climatique:", round(R3_climat, 3), "\n")
  } else {
    cat("SPEI non installé, R3 climat = 0.5\n")
  }

  # === 2. Modulation topographique par parcelle ===
  cat("\n=== Modulation topographique ===\n")

  # Le risque sécheresse varie selon:
  # - TWI faible = terrain sec = risque +
  # - Exposition sud = plus d'évaporation = risque +
  # - Pente forte = ruissellement = risque +

  if (file.exists(mnt_path)) {
    mnt <- rast(mnt_path)

    # Aspect (exposition solaire)
    aspect <- terrain(mnt, v = "aspect", unit = "degrees")
    # Sud (180°) = max risque, Nord (0°/360°) = min risque
    aspect_risk <- (1 + cos((aspect - 180) * pi / 180)) / 2

    # Pente (ruissellement)
    pente <- terrain(mnt, v = "slope", unit = "degrees")
    pente_risk <- clamp(pente / 30, lower = 0, upper = 1)

    # TWI inversé (faible TWI = sec = risque élevé)
    if (file.exists(twi_path)) {
      twi <- rast(twi_path)
      twi_norm <- (twi - global(twi, "min", na.rm = TRUE)$min) /
        (global(twi, "max", na.rm = TRUE)$max - global(twi, "min", na.rm = TRUE)$min)
      twi_risk <- 1 - twi_norm # Inverser: faible TWI = risque élevé
    } else {
      twi_risk <- 0.5
      cat("TWI non trouvé, utilisation valeur par défaut\n")
    }

    # Combiner: 40% aspect + 30% pente + 30% TWI
    topo_risk <- 0.4 * aspect_risk + 0.3 * pente_risk + 0.3 * twi_risk
    topo_risk <- clamp(topo_risk, lower = 0, upper = 1)

    # Extraire par parcelle
    if (requireNamespace("exactextractr", quietly = TRUE)) {
      parcelles$topo_risk <- exactextractr::exact_extract(topo_risk, parcelles, fun = "mean")
    } else {
      parcelles$topo_risk <- extract(topo_risk, vect(parcelles), fun = mean, na.rm = TRUE)[, 2]
    }

    cat("Risque topo min:", round(min(parcelles$topo_risk, na.rm = TRUE), 3), "\n")
    cat("Risque topo max:", round(max(parcelles$topo_risk, na.rm = TRUE), 3), "\n")

    # === 3. R3 final = climat × topographie (raster) ===
    cat("\n=== R3 final (climat × topographie) ===\n")

    # Créer raster R3 combiné
    R3_raster <- 0.6 * R3_climat + 0.4 * topo_risk
    R3_raster <- clamp(R3_raster, lower = 0, upper = 1)
    names(R3_raster) <- "R3"

    # Sauvegarder le raster R3
    R3_path <- file.path(data_dir, "drought_risk.tif")
    writeRaster(R3_raster, R3_path, overwrite = TRUE)
    cat("Raster R3 sauvegardé:", R3_path, "\n")

    # Extraire par parcelle
    if (requireNamespace("exactextractr", quietly = TRUE)) {
      parcelles$R3 <- exactextractr::exact_extract(R3_raster, parcelles, fun = "mean")
    } else {
      parcelles$R3 <- extract(R3_raster, vect(parcelles), fun = mean, na.rm = TRUE)[, 2]
    }

    cat("\nR3 par parcelle:\n")
    cat("- Min:", round(min(parcelles$R3, na.rm = TRUE), 3), "\n")
    cat("- Max:", round(max(parcelles$R3, na.rm = TRUE), 3), "\n")
    cat("- Moyenne:", round(mean(parcelles$R3, na.rm = TRUE), 3), "\n")
    cat("- Écart-type:", round(sd(parcelles$R3, na.rm = TRUE), 3), "\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_risque_secheresse_r3.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("\n=== Métriques R3 Risque sécheresse exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("MNT non trouvé, pas de modulation topographique\n")
    parcelles$R3 <- 0.6 * R3_climat + 0.4 * 0.5 # Valeur par défaut
  }
} else {
  cat("Parcelles non trouvées.\n")
}
```


### Interprétation des indices de sécheresse

| SPI / SPEI | Classification | Risque R3 |
|------------|----------------|-----------|
| > 2.0 | Extrêmement humide | 0.0 |
| 1.0 à 2.0 | Humide | 0.0 - 0.25 |
| -1.0 à 1.0 | Normal | 0.25 - 0.5 |
| -1.5 à -1.0 | Modérément sec | 0.5 - 0.75 |
| < -2.0 | Extrêmement sec | 0.75 - 1.0 |

**Configuration QBMS :**
```r
# Documentation: https://icarda-git.github.io/QBMS/
library(QBMS)
set_qbms_config("https://votre-serveur.org/brapi/v2", token = "VOTRE_TOKEN")
```

### Exercice 4.4 : Pression gibier (R4)

L'indicateur **R4** évalue la **pression d'abroutissement** par les ongulés (cervidés, sangliers) sur les parcelles forestières.

| Composante | Description | Poids |
|------------|-------------|-------|
| **Palatabilité** | Appétence des essences pour le gibier | 35% |
| **Vulnérabilité** | Jeunes peuplements (<10m) plus exposés | 30% |
| **Effet lisière** | Abroutissement concentré en bordure | 20% |
| **Densité gibier** | Tableaux de chasse départementaux | 15% |

**Source des données de chasse :**
- data.gouv.fr : Tableaux de chasse départementaux (OFB)
- 8 espèces pondérées selon leur impact sur la forêt :

| Espèce | Poids | Impact principal |
|--------|-------|------------------|
| Chevreuil | 30% | Broutage régénération |
| Cerf élaphe | 25% | Écorçage + broutage |
| Sanglier | 15% | Racines, graines |
| Chamois | 8% | Zones alpines |
| Mouflon | 7% | Zones méditerranéennes |
| Daim | 6% | Broutage localisé |
| Isard | 5% | Pyrénées |
| Cerf sika | 4% | Écorçage, limité |

```{r ex-4-4-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-4-4, exercise=TRUE, exercise.eval=FALSE, exercise.lines=180, exercise.setup="ex-4-4-setup", exercise.timelimit=900}
# === PRESSION GIBIER (R4) avec données de chasse (parallélisé) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
bd_foret_path <- file.path(data_dir, "bd_foret.gpkg")

if (!file.exists(parcelles_path)) {
  stop("Parcelles non trouvées. Exécutez d'abord le Tutorial 01.")
}

parcelles <- st_read(parcelles_path, quiet = TRUE)
cat("=== Indicateur R4 : Pression Gibier (parallélisé) ===\n\n")

# ============================================================
# 0. CONFIGURATION PARALLÉLISATION
# ============================================================

use_parallel <- FALSE
if (requireNamespace("furrr", quietly = TRUE) &&
  requireNamespace("future", quietly = TRUE)) {
  future::plan(future::multisession, workers = min(4, parallel::detectCores() - 1))
  use_parallel <- TRUE
  cat("Mode parallèle activé (furrr)\n")
} else {
  cat("Mode séquentiel (installez furrr pour accélérer)\n")
}

# Fonction map selon mode
map_func <- if (use_parallel) furrr::future_map_dbl else purrr::map_dbl

# ============================================================
# 1. TÉLÉCHARGEMENT DES DONNÉES DE CHASSE (avec cache)
# ============================================================

cat("\n--- 1. Données de chasse départementales (cache local) ---\n")

# Cache dans le répertoire du tutoriel
hunting_cache <- file.path(data_dir, "hunting_cache")
if (!dir.exists(hunting_cache)) dir.create(hunting_cache, recursive = TRUE)

pressure_data <- NULL

if (requireNamespace("nemeton", quietly = TRUE)) {
  tryCatch(
    {
      # Vérifier si le cache existe et est valide (contient colonne tableau)
      force_dl <- FALSE
      cache_file <- file.path(hunting_cache, "chevreuil_tableaux_chasse.csv")
      if (file.exists(cache_file)) {
        test_data <- read.csv(cache_file, nrows = 1)
        if (!"prelevements" %in% names(test_data)) {
          cat("Cache obsolète détecté, re-téléchargement...\n")
          force_dl <- TRUE
        }
      }

      # Télécharger avec cache local
      hunting_raw <- nemeton::download_hunting_data(
        species = "all",
        cache_dir = hunting_cache,
        force_download = force_dl
      )

      if (!is.null(hunting_raw) && "tableau" %in% names(hunting_raw)) {
        # Calculer l'indice de pression
        pressure_data <- nemeton::compute_game_pressure_index(hunting_data = hunting_raw)
        cat("Données en cache:", hunting_cache, "\n")
        cat("Indice calculé pour", nrow(pressure_data), "départements\n")

        # Top 5 départements
        cat("\nTop 5 départements (pression gibier) :\n")
        top5 <- head(pressure_data[order(-pressure_data$pressure_index), ], 5)
        for (i in seq_len(nrow(top5))) {
          cat(sprintf("  %s: %.1f\n", top5$code_dept[i], top5$pressure_index[i]))
        }
      }
    },
    error = function(e) {
      cat("Erreur téléchargement données chasse:", e$message, "\n")
    }
  )
}

# ============================================================
# 2. CALCUL DE LA PALATABILITÉ PAR PARCELLE (parallélisé)
# ============================================================

cat("\n--- 2. Palatabilité des essences (parallélisé) ---\n")

palatabilite <- data.frame(
  pattern = c(
    "chene", "quercus", "sapin", "abies", "hetre", "fagus",
    "erable", "frene", "charme", "merisier",
    "bouleau", "peuplier", "pin", "pinus", "epicea", "picea", "douglas"
  ),
  score = c(
    90, 90, 85, 85, 70, 70,
    88, 85, 72, 75,
    55, 50, 30, 30, 15, 15, 32
  ),
  stringsAsFactors = FALSE
)

parcelles$R4_palatabilite <- 50 # Valeur par défaut

if (file.exists(bd_foret_path)) {
  bd_foret <- st_read(bd_foret_path, quiet = TRUE)
  bd_foret <- st_transform(bd_foret, st_crs(parcelles))
  essence_col <- intersect(names(bd_foret), c("essence", "tfv", "libelle", "code_tfv"))

  if (length(essence_col) > 0) {
    calc_palatabilite <- function(i) {
      inter <- suppressWarnings(st_intersection(bd_foret, st_geometry(parcelles)[i]))
      if (nrow(inter) > 0) {
        essence <- tolower(as.character(inter[[essence_col[1]]][1]))
        for (j in seq_len(nrow(palatabilite))) {
          if (grepl(palatabilite$pattern[j], essence)) {
            return(palatabilite$score[j])
          }
        }
      }
      50 # Défaut
    }

    parcelles$R4_palatabilite <- map_func(seq_len(nrow(parcelles)), calc_palatabilite)
  }
}

cat("Palatabilité moyenne:", round(mean(parcelles$R4_palatabilite), 1), "\n")

# ============================================================
# 3. VULNÉRABILITÉ (hauteur/âge du peuplement)
# ============================================================

cat("\n--- 3. Vulnérabilité du peuplement ---\n")

lidar_path <- file.path(data_dir, "metriques_lidar.gpkg")

if (file.exists(lidar_path)) {
  lidar <- st_read(lidar_path, quiet = TRUE)
  if ("zmean" %in% names(lidar)) {
    parcelles$R4_vulnerabilite <- pmax(0, pmin(100, (10 - lidar$zmean) / 8 * 100))
    cat("Vulnérabilité calculée depuis LiDAR (zmean)\n")
  } else {
    parcelles$R4_vulnerabilite <- 50
  }
} else {
  parcelles$R4_vulnerabilite <- 50
  cat("Pas de données LiDAR - vulnérabilité par défaut: 50\n")
}

cat("Vulnérabilité moyenne:", round(mean(parcelles$R4_vulnerabilite, na.rm = TRUE), 1), "\n")

# ============================================================
# 4. EFFET LISIÈRE (parallélisé)
# ============================================================

cat("\n--- 4. Effet lisière (parallélisé) ---\n")

edge_buffer <- 50 # mètres

calc_lisiere <- function(i) {
  geom <- st_geometry(parcelles)[i]
  area_total <- as.numeric(st_area(geom))
  inner <- tryCatch(st_buffer(geom, -edge_buffer), error = function(e) NULL)

  if (!is.null(inner) && !st_is_empty(inner)) {
    area_inner <- as.numeric(st_area(inner))
    (area_total - area_inner) / area_total * 100
  } else {
    100
  }
}

parcelles$R4_lisiere <- map_func(seq_len(nrow(parcelles)), calc_lisiere)

cat("Effet lisière moyen:", round(mean(parcelles$R4_lisiere), 1), "%\n")

# ============================================================
# 5. DENSITÉ GIBIER PAR DÉPARTEMENT (vectorisé)
# ============================================================

cat("\n--- 5. Densité gibier locale ---\n")

parcelles$R4_densite <- 50

if (!is.null(pressure_data) && nrow(pressure_data) > 0) {
  if (requireNamespace("happign", quietly = TRUE)) {
    tryCatch(
      {
        bbox <- st_as_sfc(st_bbox(parcelles))
        st_crs(bbox) <- st_crs(parcelles)

        depts <- happign::get_wfs(
          x = bbox,
          layer = "ADMINEXPRESS-COG-CARTO.LATEST:departement"
        )

        if (!is.null(depts) && nrow(depts) > 0) {
          depts <- st_transform(depts, st_crs(parcelles))

          # Trouver la colonne code département
          dept_col <- NULL
          for (col in c("code_insee", "insee_dep", "code_dept")) {
            if (col %in% names(depts)) {
              dept_col <- col
              break
            }
          }

          if (!is.null(dept_col)) {
            # Extraire le code département (2 premiers caractères si code_insee)
            depts$code_dept_norm <- substr(as.character(depts[[dept_col]]), 1, 2)
            # Cas spéciaux DOM-TOM et Corse
            depts$code_dept_norm <- ifelse(
              nchar(as.character(depts[[dept_col]])) <= 3,
              as.character(depts[[dept_col]]),
              depts$code_dept_norm
            )

            # Jointure spatiale avec centroïdes
            centroids <- suppressWarnings(st_centroid(parcelles))
            join <- st_join(centroids, depts["code_dept_norm"], left = TRUE)

            # Normaliser les codes dans pressure_data (sans zéro devant)
            pressure_data$code_norm <- gsub("^0+", "", pressure_data$code_dept)

            # Match avec codes normalisés
            parcelles_codes <- gsub("^0+", "", join$code_dept_norm)
            idx <- match(parcelles_codes, pressure_data$code_norm)

            # Assigner les valeurs de pression
            parcelles$R4_densite <- ifelse(
              is.na(idx), 50,
              pressure_data$pressure_index[idx]
            )

            n_matched <- sum(!is.na(idx))
            cat("Densité gibier assignée pour", n_matched, "/", nrow(parcelles), "parcelles\n")
          }
        }
      },
      error = function(e) {
        cat("Erreur récupération départements:", e$message, "\n")
        cat("Utilisation valeur par défaut: 50\n")
      }
    )
  }
}

cat("Densité gibier moyenne:", round(mean(parcelles$R4_densite, na.rm = TRUE), 1), "\n")

# ============================================================
# 6. CALCUL DE L'INDICE R4 COMPOSITE
# ============================================================

cat("\n--- 6. Indice R4 composite ---\n")

w_palatabilite <- 0.35
w_vulnerabilite <- 0.30
w_lisiere <- 0.20
w_densite <- 0.15

parcelles$R4 <- w_palatabilite * parcelles$R4_palatabilite +
  w_vulnerabilite * parcelles$R4_vulnerabilite +
  w_lisiere * parcelles$R4_lisiere +
  w_densite * parcelles$R4_densite

parcelles$R4 <- pmax(0, pmin(100, parcelles$R4))

cat("\n=== Résultats R4 ===\n")
cat("R4 min:", round(min(parcelles$R4, na.rm = TRUE), 1), "\n")
cat("R4 max:", round(max(parcelles$R4, na.rm = TRUE), 1), "\n")
cat("R4 moyen:", round(mean(parcelles$R4, na.rm = TRUE), 1), "\n")

parcelles$R4_classe <- cut(parcelles$R4,
  breaks = c(0, 25, 50, 75, 100),
  labels = c("Faible", "Modéré", "Élevé", "Très élevé"),
  include.lowest = TRUE
)

cat("\nDistribution:\n")
print(table(parcelles$R4_classe))

# Nettoyer parallélisation
if (use_parallel) future::plan(future::sequential)

# Sauvegarder
output_path <- file.path(data_dir, "metriques_pression_gibier_r4.gpkg")
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n=== Métriques R4 Pression du gibier exportées ===\n")
cat("Fichier:", output_path, "\n")
cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
```


### Synthèse des indicateurs de risque

| Indicateur | Packages | Méthode |
|------------|----------|---------|
| **R1** (Feu) | fireexposuR | Exposition végétation combustible (rayon 500m) |
| **R2** (Tempête) | nasapower + microclima | Vent NASA POWER + coefficient d'abri windcoef |
| **R3** (Sécheresse) | QBMS + SPEI | Données climatiques + indices SPI, SPEI, RDI |
| **R4** (Gibier) | nemeton + data.gouv.fr | Palatabilité + vulnérabilité + lisière + tableaux chasse |

**Installation des packages :**
```r
install.packages(c("fireexposuR", "nasapower", "microclima", "QBMS", "SPEI"))
```

---

## Section 5 : Accessibilité (S1, S2, S3)

### Exercice 5.1 : Distance aux routes (S1)

```{r ex-5-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-5-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-5-1-setup"}
# === ACCESSIBILITÉ ROUTES (S1) - Rendu raster ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
routes_path <- file.path(data_dir, "routes.gpkg")
mnt_path <- file.path(data_dir, "mnt.tif")

if (file.exists(parcelles_path) && file.exists(mnt_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)
  mnt <- rast(mnt_path) # Pour la grille de référence

  if (file.exists(routes_path)) {
    routes <- st_read(routes_path, quiet = TRUE)
    routes <- st_transform(routes, st_crs(parcelles))
    cat("Routes chargées:", nrow(routes), "tronçons\n\n")

    # === Créer raster de distance aux routes ===
    cat("=== Calcul raster de distance aux routes ===\n")

    # Rasteriser les routes (valeur 1 sur les routes)
    routes_vect <- vect(routes)
    routes_rast <- rasterize(routes_vect, mnt, field = 1, background = NA)

    # Calculer la distance (en mètres)
    S1_raster <- distance(routes_rast)
    names(S1_raster) <- "S1"

    # Sauvegarder le raster
    S1_path <- file.path(data_dir, "distance_routes.tif")
    writeRaster(S1_raster, S1_path, overwrite = TRUE)
    cat("Raster S1 sauvegardé:", S1_path, "\n")

    # Extraire par parcelle
    if (requireNamespace("exactextractr", quietly = TRUE)) {
      parcelles$S1 <- exactextractr::exact_extract(S1_raster, parcelles, fun = "mean")
    } else {
      parcelles$S1 <- extract(S1_raster, vect(parcelles), fun = mean, na.rm = TRUE)[, 2]
    }

    cat("\n=== Indicateur S1 (Accessibilité routes) ===\n")
    cat("Distance min:", round(min(parcelles$S1, na.rm = TRUE)), "m\n")
    cat("Distance max:", round(max(parcelles$S1, na.rm = TRUE)), "m\n")
    cat("Distance moyenne:", round(mean(parcelles$S1, na.rm = TRUE)), "m\n")

    # Classification
    cat("\nClassification accessibilité:\n")
    cat("- < 100m : Très accessible\n")
    cat("- 100-500m : Accessible\n")
    cat("- > 500m : Peu accessible\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_access_route_a1.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("\n=== Métriques S1 Accessibilité route exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Fichier routes.gpkg non trouvé.\n")
    cat("Exécutez l'exercice 4.2 du Tutorial 01.\n")
  }
} else {
  cat("Parcelles ou MNT non trouvés. Exécutez le Tutorial 01.\n")
}
```


---

### Exercice 5.2 : Distance aux bâtiments (S2)

```{r ex-5-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-5-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=70, exercise.setup="ex-5-2-setup", exercise.timelimit=300}
# === DISTANCE AUX BÂTIMENTS (S2) - Rendu raster ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
mnt_path <- file.path(data_dir, "mnt.tif")
batiments_path <- file.path(data_dir, "batiments.gpkg")

if (file.exists(parcelles_path) && file.exists(mnt_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)
  mnt <- rast(mnt_path)

  # === Télécharger les bâtiments si non présents ===
  if (!file.exists(batiments_path)) {
    cat("Téléchargement des bâtiments BD TOPO (Géoplateforme)...\n")
    bbox <- st_bbox(parcelles)

    # Nouvelle URL Géoplateforme IGN (remplace wxs.ign.fr)
    url_batiments <- paste0(
      "https://data.geopf.fr/wfs/ows?",
      "SERVICE=WFS&VERSION=2.0.0&REQUEST=GetFeature",
      "&TYPENAME=BDTOPO_V3:batiment",
      "&SRSNAME=EPSG:2154",
      "&BBOX=", paste(bbox, collapse = ","), ",EPSG:2154",
      "&OUTPUTFORMAT=application/json"
    )

    batiments <- tryCatch(
      {
        st_read(url_batiments, quiet = TRUE)
      },
      error = function(e) {
        cat("Erreur téléchargement:", conditionMessage(e), "\n")
        NULL
      }
    )

    if (!is.null(batiments) && nrow(batiments) > 0) {
      st_write(batiments, batiments_path, quiet = TRUE)
      cat("Bâtiments sauvegardés:", nrow(batiments), "entités\n")
    } else {
      cat("Aucun bâtiment trouvé dans la zone.\n")
    }
  }

  if (file.exists(batiments_path)) {
    batiments <- st_read(batiments_path, quiet = TRUE)
    batiments <- st_transform(batiments, st_crs(parcelles))
    cat("Bâtiments chargés:", nrow(batiments), "entités\n\n")

    # === Créer raster de distance aux bâtiments ===
    cat("=== Calcul raster de distance aux bâtiments ===\n")

    batiments_vect <- vect(batiments)
    batiments_rast <- rasterize(batiments_vect, mnt, field = 1, background = NA)
    S2_raster <- distance(batiments_rast)
    names(S2_raster) <- "S2"

    # Sauvegarder le raster
    S2_path <- file.path(data_dir, "distance_batiments.tif")
    writeRaster(S2_raster, S2_path, overwrite = TRUE)
    cat("Raster S2 sauvegardé:", S2_path, "\n")

    # Extraire par parcelle
    parcelles$S2 <- extract(S2_raster, vect(parcelles), fun = mean, na.rm = TRUE)[, 2]

    cat("\n=== Indicateur S2 (Distance bâtiments) ===\n")
    cat("Distance min:", round(min(parcelles$S2, na.rm = TRUE)), "m\n")
    cat("Distance max:", round(max(parcelles$S2, na.rm = TRUE)), "m\n")
    cat("Distance moyenne:", round(mean(parcelles$S2, na.rm = TRUE)), "m\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_distance_batiment_a2.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("\n=== Métriques S2 Distance au batiment exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Bâtiments non disponibles. Vérifiez l'accès au WFS IGN.\n")
  }
} else {
  cat("Parcelles ou MNT non trouvés.\n")
}
```


---

### Exercice 5.3 : Densité de sentiers (S3)

```{r ex-5-3-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-5-3, exercise=TRUE, exercise.eval=FALSE, exercise.lines=80, exercise.setup="ex-5-3-setup", exercise.timelimit=300}
# === DENSITÉ DE SENTIERS (S3) - osmdata ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
mnt_path <- file.path(data_dir, "mnt.tif")
sentiers_path <- file.path(data_dir, "sentiers.gpkg")

if (file.exists(parcelles_path) && file.exists(mnt_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)
  mnt <- rast(mnt_path)

  # === Télécharger les sentiers depuis OpenStreetMap ===
  if (!file.exists(sentiers_path)) {
    if (requireNamespace("osmdata", quietly = TRUE)) {
      library(osmdata)
      cat("Téléchargement des sentiers depuis OpenStreetMap...\n")

      # Bbox en WGS84 pour osmdata
      bbox_wgs84 <- st_bbox(st_transform(parcelles, 4326))

      # Requête Overpass : chemins, sentiers, pistes
      q <- tryCatch(
        {
          opq(bbox = bbox_wgs84, timeout = 180) |>
            add_osm_feature(
              key = "highway",
              value = c("path", "footway", "track", "bridleway", "cycleway")
            )
        },
        error = function(e) {
          cat("Erreur Overpass:", conditionMessage(e), "\n")
          NULL
        }
      )

      sentiers <- osmdata_sf(q)

      if (!is.null(sentiers) && !is.null(sentiers$osm_lines) && nrow(sentiers$osm_lines) > 0) {
        sentiers_sf <- st_transform(sentiers$osm_lines, st_crs(parcelles))
        st_write(sentiers_sf, sentiers_path, quiet = TRUE)
        cat("Sentiers OSM sauvegardés:", nrow(sentiers_sf), "tronçons\n")
      } else {
        cat("Aucun sentier trouvé dans la zone.\n")
      }
    } else {
      cat("Package osmdata requis. Installez avec: install.packages('osmdata')\n")
    }
  }

  if (file.exists(sentiers_path)) {
    sentiers <- st_read(sentiers_path, quiet = TRUE)
    sentiers <- st_transform(sentiers, st_crs(parcelles))
    cat("Sentiers chargés:", nrow(sentiers), "tronçons\n\n")

    # === Calculer densité par parcelle (m/ha) ===
    cat("=== Calcul densité de sentiers (m/ha) ===\n")

    calc_s3 <- function(i) {
      inter <- tryCatch(
        {
          st_intersection(sentiers, parcelles[i, ])
        },
        error = function(e) NULL
      )
      if (!is.null(inter) && nrow(inter) > 0) {
        longueur <- sum(st_length(inter))
        surface_ha <- as.numeric(st_area(parcelles[i, ])) / 10000
        as.numeric(longueur / surface_ha)
      } else {
        0
      }
    }

    # Parallélisation avec furrr si disponible
    if (requireNamespace("furrr", quietly = TRUE) && requireNamespace("future", quietly = TRUE)) {
      library(furrr)
      library(future)
      plan(multisession, workers = max(1, availableCores() - 1))
      cat("Mode parallèle (furrr,", nbrOfWorkers(), "workers)...\n")
      parcelles$S3 <- future_map_dbl(seq_len(nrow(parcelles)), calc_s3, .progress = TRUE)
      plan(sequential)
    } else if (requireNamespace("purrr", quietly = TRUE)) {
      library(purrr)
      cat("Mode séquentiel (purrr)...\n")
      parcelles$S3 <- map_dbl(seq_len(nrow(parcelles)), calc_s3)
    } else {
      cat("Mode séquentiel (base R)...\n")
      parcelles$S3 <- sapply(seq_len(nrow(parcelles)), calc_s3)
    }

    # === Créer raster de densité (kernel) ===
    reso <- res(mnt)[1]
    sentiers_rast <- rasterize(vect(sentiers), mnt, field = 1, background = 0)
    w <- focalMat(mnt, d = 100, type = "circle")
    S3_raster <- focal(sentiers_rast, w = w, fun = "sum", na.rm = TRUE)
    S3_raster <- S3_raster * reso
    names(S3_raster) <- "S3"

    S3_path <- file.path(data_dir, "densite_sentiers.tif")
    writeRaster(S3_raster, S3_path, overwrite = TRUE)
    cat("Raster S3 sauvegardé:", S3_path, "\n")

    cat("\n=== Indicateur S3 (Densité sentiers) ===\n")
    cat("Densité min:", round(min(parcelles$S3, na.rm = TRUE), 1), "m/ha\n")
    cat("Densité max:", round(max(parcelles$S3, na.rm = TRUE), 1), "m/ha\n")
    cat("Densité moyenne:", round(mean(parcelles$S3, na.rm = TRUE), 1), "m/ha\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_densite_sentiers_a3.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("\n=== Métriques S3 Densité sentiers exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Sentiers non disponibles.\n")
  }
} else {
  cat("Parcelles ou MNT non trouvés.\n")
}
```


---

## Section 6 : Export et synthèse

### Exercice 6.1 : Famille W (Eau)

```{r ex-6-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-6-1-setup"}
# === FAMILLE W (EAU) : W1, W2, W3 ===
parcelles_path <- file.path(data_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

# Fonction d'extraction
extract_mean <- function(r, poly) {
  if (requireNamespace("exactextractr", quietly = TRUE)) {
    exactextractr::exact_extract(r, poly, fun = "mean")
  } else {
    extract(r, vect(poly), fun = mean, na.rm = TRUE)[, 2]
  }
}

cat("=== Famille W (Eau) ===\n\n")

# W1 : Densité réseau hydrographique (m/ha)
cours_eau_path <- file.path(data_dir, "cours_eau.gpkg")
if (file.exists(cours_eau_path)) {
  cours_eau <- st_read(cours_eau_path, quiet = TRUE)
  cours_eau <- st_transform(cours_eau, st_crs(parcelles))

  calc_w1_synth <- function(i) {
    inter <- st_intersection(cours_eau, parcelles[i, ])
    if (nrow(inter) > 0) {
      as.numeric(sum(st_length(inter)) / (st_area(parcelles[i, ]) / 10000))
    } else {
      0
    }
  }

  # Parallélisation avec furrr si disponible
  if (requireNamespace("furrr", quietly = TRUE) && requireNamespace("future", quietly = TRUE)) {
    library(furrr)
    library(future)
    plan(multisession, workers = max(1, availableCores() - 1))
    parcelles$W1 <- future_map_dbl(seq_len(nrow(parcelles)), calc_w1_synth, .progress = TRUE)
    plan(sequential)
  } else if (requireNamespace("purrr", quietly = TRUE)) {
    library(purrr)
    parcelles$W1 <- map_dbl(seq_len(nrow(parcelles)), calc_w1_synth)
  } else {
    parcelles$W1 <- sapply(seq_len(nrow(parcelles)), calc_w1_synth)
  }

  cat("W1 (densité hydro):", round(mean(parcelles$W1, na.rm = TRUE), 2), "m/ha\n")
  cat("   0 = pas de cours d'eau, >50 = réseau dense\n\n")
}

# W2, W3 : TWI et zones humides
twi_path <- file.path(data_dir, "twi.tif")
if (file.exists(twi_path)) {
  twi_rast <- rast(twi_path)
  parcelles$W3 <- extract_mean(twi_rast, parcelles)
  parcelles$W2 <- extract_mean(twi_rast > 12, parcelles) * 100
  cat("W2 (zones humides):", round(mean(parcelles$W2, na.rm = TRUE), 2), "%\n")
  cat("   % de surface avec TWI > 12 (potentiel zone humide)\n\n")
  cat("W3 (TWI moyen):", round(mean(parcelles$W3, na.rm = TRUE), 2), "\n")
  cat("   <6 = très sec, 6-9 = sec, 9-12 = moyen, >12 = humide\n")
}

# Sauvegarder
output_path <- file.path(data_dir, "indicateurs_terrain.gpkg")
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\nFamille W sauvegardée:", output_path, "\n")
```


---

### Exercice 6.2 : Famille R (Risques)

```{r ex-6-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=65, exercise.setup="ex-6-2-setup"}
# === FAMILLE R (RISQUES) : R1, R2, R3, R4 ===
output_path <- file.path(data_dir, "indicateurs_terrain.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

# Fonction d'extraction
extract_mean <- function(r, poly) {
  if (requireNamespace("exactextractr", quietly = TRUE)) {
    exactextractr::exact_extract(r, poly, fun = "mean")
  } else {
    extract(r, vect(poly), fun = mean, na.rm = TRUE)[, 2]
  }
}

cat("=== Famille R (Risques) ===\n\n")

# R1 : Risque feu (score 0-1)
fire_path <- file.path(data_dir, "fire_exposure.tif")
if (file.exists(fire_path)) {
  parcelles$R1 <- extract_mean(rast(fire_path), parcelles)
  cat("R1 (risque feu):", round(mean(parcelles$R1, na.rm = TRUE), 3), "\n")
  cat("   Score 0-1 (0=faible, 1=fort) - pente + expo sud + sécheresse\n\n")
}

# R2 : Risque tempête (score 0-1)
storm_path <- file.path(data_dir, "storm_exposure.tif")
if (file.exists(storm_path)) {
  parcelles$R2 <- extract_mean(rast(storm_path), parcelles)
  cat("R2 (risque tempête):", round(mean(parcelles$R2, na.rm = TRUE), 3), "\n")
  cat("   Score 0-1 (0=abrité, 1=exposé) - altitude + exposition vents\n\n")
}

# R3 : Risque sécheresse (score 0-1)
drought_path <- file.path(data_dir, "drought_risk.tif")
if (file.exists(drought_path)) {
  parcelles$R3 <- extract_mean(rast(drought_path), parcelles)
  cat("R3 (risque sécheresse):", round(mean(parcelles$R3, na.rm = TRUE), 3), "\n")
  cat("   Score 0-1 (0=humide, 1=sec) - TWI inverse + expo sud\n\n")
}

# R4 : Pression gibier (score 0-100 → normalisé 0-1)
# Calculé en exercice 4.4 et sauvegardé dans metriques_pression_gibier_r4.gpkg
r4_path <- file.path(data_dir, "metriques_pression_gibier_r4.gpkg")
if (file.exists(r4_path)) {
  r4_data <- st_read(r4_path, quiet = TRUE)
  if ("R4" %in% names(r4_data)) {
    parcelles$R4 <- r4_data$R4 / 100 # Normaliser 0-100 → 0-1
    cat("R4 (pression gibier):", round(mean(parcelles$R4, na.rm = TRUE), 3), "\n")
    cat("   Score 0-1 : palatabilité 35% + vulnérabilité 25%\n")
    cat("              + effet lisière 25% + densité chasse 15%\n")
  }
} else {
  parcelles$R4 <- 0.5
  cat("R4 (pression gibier): 0.5 (valeur par défaut)\n")
  cat("   Exécutez l'exercice 4.4 pour calculer R4\n")
}

# Sauvegarder
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\nFamille R sauvegardée:", output_path, "\n")
```


---

### Exercice 6.3 : Famille S (Social)

```{r ex-6-3-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-3, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-6-3-setup"}
# === FAMILLE S (SOCIAL) : S1, S2, S3 ===
output_path <- file.path(data_dir, "indicateurs_terrain.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

# Fonction d'extraction
extract_mean <- function(r, poly) {
  if (requireNamespace("exactextractr", quietly = TRUE)) {
    exactextractr::exact_extract(r, poly, fun = "mean")
  } else {
    extract(r, vect(poly), fun = mean, na.rm = TRUE)[, 2]
  }
}

cat("=== Famille S (Social) ===\n\n")

# S1 : Distance aux routes (m)
dist_routes_path <- file.path(data_dir, "distance_routes.tif")
if (file.exists(dist_routes_path)) {
  parcelles$S1 <- extract_mean(rast(dist_routes_path), parcelles)
  cat("S1 (dist routes):", round(mean(parcelles$S1, na.rm = TRUE), 0), "m\n")
  cat("   <100m = très accessible, 100-500m = accessible, >500m = isolé\n\n")
}

# S2 : Distance aux bâtiments (m)
dist_bat_path <- file.path(data_dir, "distance_batiments.tif")
if (file.exists(dist_bat_path)) {
  parcelles$S2 <- extract_mean(rast(dist_bat_path), parcelles)
  cat("S2 (dist bâtiments):", round(mean(parcelles$S2, na.rm = TRUE), 0), "m\n")
  cat("   <200m = proche habitat, 200-1000m = périurbain, >1000m = rural\n\n")
}

# S3 : Densité sentiers (m/ha)
sentiers_path <- file.path(data_dir, "densite_sentiers.tif")
if (file.exists(sentiers_path)) {
  parcelles$S3 <- extract_mean(rast(sentiers_path), parcelles)
  cat("S3 (densité sentiers):", round(mean(parcelles$S3, na.rm = TRUE), 1), "m/ha\n")
  cat("   0 = pas de sentier, >20 = usage récréatif important\n")
} else {
  parcelles$S3 <- 0
  cat("S3 (densité sentiers): 0 (données non disponibles)\n")
  cat("   Exécutez la section 5 pour télécharger les sentiers OSM\n")
}

# Sauvegarder
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\nFamille S sauvegardée:", output_path, "\n")
```


---

### Exercice 6.4 : Famille F (Sol)

```{r ex-6-4-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-4, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-6-4-setup"}
# === FAMILLE F (SOL) ===
output_path <- file.path(data_dir, "indicateurs_terrain.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

# Fonction d'extraction
extract_mean <- function(r, poly) {
  if (requireNamespace("exactextractr", quietly = TRUE)) {
    exactextractr::exact_extract(r, poly, fun = "mean")
  } else {
    extract(r, vect(poly), fun = mean, na.rm = TRUE)[, 2]
  }
}

cat("=== Famille F ===\n\n")

# F1 : Risque érosion RUSLE simplifié (Section 1)
# F1 = LS (facteur pente-longueur) × C (couverture végétale)
erosion_path <- file.path(data_dir, "erosion_f1.tif")
if (file.exists(erosion_path)) {
  parcelles$F1 <- extract_mean(rast(erosion_path), parcelles)
  cat("F1 (érosion RUSLE):", round(mean(parcelles$F1, na.rm = TRUE), 3), "\n")
  cat("   Score 0-1 : 0-0.1=très faible, 0.1-0.3=faible,\n")
  cat("              0.3-0.5=modéré, 0.5-0.7=élevé, 0.7-1=très élevé\n")
} else {
  cat("F1: Fichier erosion_f1.tif non trouvé.\n")
  cat("   Exécutez l'exercice 1.2 (RUSLE simplifié)\n")
}

# Sauvegarder
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\nFamille F sauvegardée:", output_path, "\n")
```

---

### Exercice 6.5 : Synthèse finale

```{r ex-6-5-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-5, exercise=TRUE, exercise.eval=FALSE, exercise.lines=70, exercise.setup="ex-6-5-setup"}
# === SYNTHÈSE FINALE - TOUS LES INDICATEURS TERRAIN ===
output_path <- file.path(data_dir, "indicateurs_terrain.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

# Résumé par famille
cat("\n=== Résumé par famille ===\n")
familles <- list(
  W = c("W1", "W2", "W3"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  F = c("F1")
)

for (fam in names(familles)) {
  inds <- familles[[fam]]
  present <- sum(inds %in% names(parcelles))
  cat(sprintf("Famille %s: %d/%d indicateurs\n", fam, present, length(inds)))
}

cat("\nTotal:", sum(unlist(familles) %in% names(parcelles)), "/11 indicateurs calculés\n")
```

---

## Quiz final

```{r quiz-final, echo=FALSE}
quiz(
  caption = "Testez vos connaissances",
  question("Que signifie TWI ?",
    answer("Topographic Wetness Index - indice d'humidité topographique", correct = TRUE),
    answer("Tree Width Index"),
    answer("Terrain Water Indicator"),
    answer("Total Watershed Input"),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Quels facteurs augmentent le risque feu (R1) ?",
    answer("Pente forte + exposition sud", correct = TRUE),
    answer("Pente faible + exposition nord"),
    answer("Altitude élevée"),
    answer("Proximité des routes"),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("L'indicateur S1 mesure :",
    answer("La surface des parcelles"),
    answer("La distance aux routes (accessibilité)", correct = TRUE),
    answer("Le nombre d'espèces"),
    answer("La pente moyenne"),
    allow_retry = TRUE,
    random_answer_order = TRUE
  )
)
```

---

## Synthèse

### Indicateurs calculés

| Famille | Code | Indicateur | Source | Unité | Interprétation |
|---------|------|------------|--------|-------|----------------|
| **W** | W1 | Densité réseau hydro | BD TOPO cours_eau | m/ha | 0=aucun, >50=dense |
| **W** | W2 | Zones humides | MNT → TWI > 12 | % | % surface humide |
| **W** | W3 | TWI moyen | MNT + fasterRaster | - | <6=sec, >12=humide |
| **R** | R1 | Risque feu | fireexposuR | 0-1 | 0=faible, 1=fort |
| **R** | R2 | Risque tempête | nasapower + microclima | 0-1 | 0=abrité, 1=exposé |
| **R** | R3 | Risque sécheresse | QBMS + SPEI | 0-1 | 0=humide, 1=sec |
| **R** | R4 | Pression gibier | nemeton + data.gouv.fr | 0-1 | palatab.+vulnér.+lisière+chasse |
| **S** | S1 | Distance routes | BD TOPO routes | m | <100=accessible, >500=isolé |
| **S** | S2 | Distance bâtiments | BD TOPO bâtiments | m | <200=proche, >1000=rural |
| **S** | S3 | Densité sentiers | osmdata (OSM) | m/ha | 0=aucun, >20=récréatif |
| **F** | F1 | Érosion RUSLE | MNT + BD Forêt | 0-1 | LS × C (pente × couverture) |

### Fichiers produits

| Fichier | Contenu | Indicateurs |
|---------|---------|-------------|
| `indicateurs_terrain.gpkg` | Synthèse complète | W1-3, R1-4, S1-3, F1 |
| `metriques_erosion_f1.gpkg` | Érosion RUSLE | F1 |
| `metriques_twi_w3.gpkg` | Humidité topographique | W3 |
| `metriques_densite_hydro_w1.gpkg` | Densité réseau hydro | W1 |
| `metriques_couverture_zone_humide_w2.gpkg` | Zones humides | W2 |
| `metriques_exposition_feu_r1.gpkg` | Exposition au feu | R1 |
| `metriques_exposition_tempete_r2.gpkg` | Exposition tempête | R2 |
| `metriques_risque_secheresse_r3.gpkg` | Risque sécheresse | R3 |
| `metriques_pression_gibier_r4.gpkg` | Pression gibier | R4 + composantes |
| `metriques_access_route_a1.gpkg` | Accessibilité route | A1 |
| `metriques_distance_batiment_a2.gpkg` | Distance bâtiments | A2 |
| `metriques_densite_sentiers_a3.gpkg` | Densité sentiers | A3 |
| `twi.tif` | Raster TWI | - |
| `erosion_f1.tif` | Raster érosion RUSLE | - |

### Tutoriel suivant

→ **Tutorial 04 : Indicateurs Écologiques** - Protection (B1), connectivité (B3), paysage (L), naturalité (N).

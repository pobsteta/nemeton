---
title: "Tutorial 01 : Acquisition des Données Géographiques"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Apprenez à acquérir les données géographiques nécessaires à l'analyse
  écosystémique forestière : cadastre, MNT, BD Forêt, BD TOPO et LiDAR HD
  via les APIs IGN (happign, lidarHD). Prérequis pour tous les indicateurs.
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)

# Configuration gradethis
gradethis::gradethis_setup()

# Options
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)

# Timeout pour les exercices avec téléchargement
options(tutorial.exercise.timelimit = 300)

# Configuration des timeouts réseau (5 minutes)
NETWORK_TIMEOUT <- 300
options(
  timeout = NETWORK_TIMEOUT,
  HTTPUserAgent = "nemeton-tutorial/1.0"
)

# Configuration httr (connect + request timeout)
if (requireNamespace("httr", quietly = TRUE)) {
  httr::set_config(httr::config(
    connecttimeout = NETWORK_TIMEOUT,
    timeout = NETWORK_TIMEOUT
  ))
}

# Configuration GDAL/curl pour happign
Sys.setenv(
  GDAL_HTTP_TIMEOUT = as.character(NETWORK_TIMEOUT),
  GDAL_HTTP_CONNECTTIMEOUT = as.character(NETWORK_TIMEOUT),
  CURL_SSL_BACKEND = "openssl"
)
```

## Bienvenue

### Objectifs du tutoriel

Ce tutoriel vous guide dans l'acquisition des données géographiques nécessaires au calcul des indicateurs écosystémiques **nemeton**.

À la fin de ce tutoriel, vous saurez :

1. **Créer une zone d'étude** à partir de placettes forestières

2. **Télécharger le cadastre** via l'API IGN (happign)

3. **Télécharger le MNT** RGE Alti 5m

4. **Télécharger la BD Forêt** V2 (formations végétales)

5. **Télécharger la BD TOPO** (routes, cours d'eau, bâtiments)

6. **Télécharger le LiDAR HD** IGN (lidarHD)

7. **Harmoniser et exporter** les données en GeoPackage

### Zone d'étude

Nous utiliserons la **zone d'étude prédéfinie** fournie avec le package nemeton. Cette zone correspond au cluster **Verc-02** des données Quatre Montagnes, située dans le **Vercors** (Isère, France), couvrant environ **450 hectares**.

### Prérequis

```{r prerequis, echo=FALSE}
question("Quels packages sont nécessaires pour ce tutoriel ?",
  answer("sf, terra, ggplot2", message = "Incomplet - il manque les packages d'acquisition"),
  answer("happign, lidarHD, lidaRtRee", message = "Incomplet - il manque les packages de base"),
  answer("sf, terra, happign, lidarHD, lidaRtRee", correct = TRUE),
  answer("dplyr, tidyr, purrr", message = "Ces packages sont utiles mais pas essentiels ici"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

### Chargement des packages

Exécutez le code suivant pour charger les packages nécessaires :

```{r load-packages, exercise=TRUE, exercise.eval=FALSE}
# Packages de base
library(sf)
library(terra)

# Données exemple
library(lidaRtRee)

# Acquisition IGN
library(happign)

# Visualisation
library(ggplot2)

cat("Packages chargés avec succès !")
```

### Répertoire de données

Pour éviter de retélécharger les données à chaque session, nous allons créer un **répertoire de cache local**. Ce répertoire persistera entre les sessions R.

Le package `rappdirs` permet de trouver le bon emplacement selon votre système d'exploitation :

- **Linux** : `~/.local/share/nemeton/tutorial_data/`
- **Windows** : `C:\Users\<user>\AppData\Local\nemeton\tutorial_data\`
- **macOS** : `~/Library/Application Support/nemeton/tutorial_data/`

```{r show-data-dir, exercise=TRUE, exercise.eval=FALSE, exercise.lines=20}
# === CRÉER LE RÉPERTOIRE DE CACHE ===

# Utiliser rappdirs si disponible, sinon le répertoire home
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}

# Créer le répertoire s'il n'existe pas
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)

cat("=== Répertoire de cache créé ===\n")
cat("Chemin:", data_dir, "\n\n")

# Vérifier que le répertoire existe
if (dir.exists(data_dir)) {
  cat("Le répertoire existe et est prêt à recevoir les données.\n")
} else {
  cat("ERREUR: Impossible de créer le répertoire.\n")
}
```

**Important** : Retenez ce code ! Vous devrez définir `data_dir` au début de chaque exercice de téléchargement.

---

## Section 1 : Zone d'étude

### Introduction

La première étape consiste à charger notre **zone d'étude**. Le package nemeton fournit une zone prête à l'emploi dans `inst/extdata/zone_etude.gpkg`. Cette zone correspond à 7 clusters des données Quatre Montagnes avec un buffer de 100m, couvrant environ **450 hectares**.

### Exercice 1.1 : Charger la zone d'étude

```{r ex-1-1-setup}
library(sf)
library(ggplot2)
```

```{r ex-1-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-1-1-setup"}
# Chemin vers la zone d'étude fournie avec le package
zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")

# Charger la zone d'étude
zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)

cat("=== Zone d'étude chargée ===\n")
cat("Source: nemeton::inst/extdata/zone_etude.gpkg\n")
cat("Cluster:", zone_etude_sf$cluster_id, "\n")
cat("Surface:", round(as.numeric(st_area(zone_etude_sf)) / 10000), "ha\n")
cat("CRS:", st_crs(zone_etude_sf)$epsg, "(Lambert-93)\n\n")

# Sauvegarder dans le répertoire de cache pour les exercices suivants
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)

filepath <- file.path(data_dir, "zone_etude.gpkg")
st_write(zone_etude_sf, filepath, layer = "zone_etude",
         delete_layer = TRUE, quiet = TRUE)
cat("Zone sauvegardée dans:", filepath, "\n")

# Afficher les attributs
print(zone_etude_sf)
```

### Exercice 1.2 : Visualiser la zone d'étude

```{r ex-1-2-setup}
library(sf)
library(ggplot2)
# Charger la zone depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-1-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=22, exercise.setup="ex-1-2-setup"}
# Visualiser la zone d'étude
ggplot() +
  geom_sf(
    data = zone_etude_sf,
    fill = "lightgreen",
    alpha = 0.3,
    color = "darkgreen",
    linewidth = 1
  ) +
  geom_sf(
    data = st_centroid(zone_etude_sf),
    color = "darkgreen",
    size = 3
  ) +
  coord_sf(datum = NA) +
  labs(
    title = "Zone d'étude : Vercors (Verc-02)",
    subtitle = paste(
      "Cluster", zone_etude_sf$cluster_id, "-",
      round(as.numeric(st_area(zone_etude_sf)) / 10000), "ha"
    ),
    x = "X (m)", y = "Y (m)"
  ) +
  theme_minimal()
```

### Quiz Section 1

```{r quiz-section-1, echo=FALSE}
quiz(
  question("Quel est le système de coordonnées utilisé par l'IGN en France ?",
    answer("WGS84 (EPSG:4326)"),
    answer("Lambert-93 (EPSG:2154)", correct = TRUE),
    answer("UTM zone 31N (EPSG:32631)"),
    answer("Web Mercator (EPSG:3857)"),
    allow_retry = TRUE
  ),
  question("Quel format de fichier est utilisé pour stocker la zone d'étude ?",
    answer("Shapefile (.shp)"),
    answer("GeoJSON (.geojson)"),
    answer("GeoPackage (.gpkg)", correct = TRUE),
    answer("CSV (.csv)"),
    allow_retry = TRUE
  )
)
```

---

## Section 2 : Téléchargement du cadastre

### Introduction

Le **cadastre** fournit les limites des parcelles. Nous utiliserons le package `happign` pour interroger l'API **WFS** de l'IGN.

**Couche utilisée** : `CADASTRALPARCELS.PARCELLAIRE_EXPRESS:parcelle`

### Pattern de cache

À chaque téléchargement, nous appliquerons le même pattern :

1. Définir le chemin du fichier dans le répertoire de cache
2. Vérifier si le fichier existe déjà
3. Si oui → charger depuis le cache
4. Si non → télécharger, sauvegarder, puis utiliser

### Exercice 2.1 : Télécharger les parcelles cadastrales

Appliquons le pattern de cache pour télécharger les parcelles :

```{r ex-2-1-setup}
library(sf)
library(happign)
# Charger la zone d'étude depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
# Essayer le cache, sinon le package
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-2-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-2-1-setup"}
# === PATTERN DE CACHE ===
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
parcelles_filepath <- file.path(data_dir, "parcelles.gpkg")

# Vérifier si les données existent déjà
if (file.exists(parcelles_filepath)) {
  # CACHE HIT : Charger depuis le fichier local
  cat("Chargement depuis le cache...\n")
  parcelles <- st_read(parcelles_filepath, quiet = TRUE)
  cat("Parcelles chargées depuis:", parcelles_filepath, "\n\n")
} else {
  # CACHE MISS : Télécharger depuis l'API IGN
  cat("Téléchargement depuis l'API IGN...\n")
  parcelles <- get_wfs(
    x = zone_etude_sf,
    layer = "CADASTRALPARCELS.PARCELLAIRE_EXPRESS:parcelle"
  )
  parcelles <- st_transform(parcelles, 2154)

  # Sauvegarder dans le cache
  st_write(parcelles, parcelles_filepath, quiet = TRUE)
  cat("Parcelles sauvegardées dans:", parcelles_filepath, "\n\n")
}

# === INFORMATIONS SUR LES DONNÉES ===
cat("=== Parcelles cadastrales ===\n")
cat("Nombre de parcelles:", nrow(parcelles), "\n")
cat("CRS:", st_crs(parcelles)$epsg, "(Lambert-93)\n")
cat("\nColonnes disponibles:\n")
cat(paste(names(parcelles)[seq_len(min(8, ncol(parcelles)))], collapse = ", "), "\n")

# Surface totale
surface_totale <- sum(st_area(parcelles))
cat("\nSurface totale:", round(as.numeric(surface_totale) / 10000, 1), "ha\n")
```



### Exercice 2.2 : Explorer les parcelles

Les parcelles sont maintenant en cache. Chargeons-les et explorons leurs attributs :

```{r ex-2-2-setup}
library(sf)
# Charger les parcelles depuis le cache
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
parcelles_filepath <- file.path(data_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_filepath, quiet = TRUE)
```

```{r ex-2-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=22, exercise.setup="ex-2-2-setup"}
# Les parcelles sont déjà chargées depuis le cache (setup)
cat("Parcelles chargées depuis le cache\n\n")
cat("Nombre de ligne:", nrow(parcelles), "\n")
cat("Nombre de colonne:", ncol(parcelles), "\n")

# Calculer la surface de chaque parcelle
parcelles$surface_ha <- as.numeric(st_area(parcelles)) / 10000

# Statistiques de surface
cat("=== Statistiques des parcelles ===\n\n")
cat("Nombre total:", nrow(parcelles), "parcelles\n")
cat("Surface min:", round(min(parcelles$surface_ha), 3), "ha\n")
cat("Surface max:", round(max(parcelles$surface_ha), 2), "ha\n")
cat("Surface médiane:", round(median(parcelles$surface_ha), 3), "ha\n")
cat("Surface moyenne:", round(mean(parcelles$surface_ha), 3), "ha\n")

# Distribution par taille
cat("\n=== Distribution par taille ===\n")
cat("< 0.5 ha:", sum(parcelles$surface_ha < 0.5), "parcelles\n")
cat("0.5 - 2 ha:", sum(parcelles$surface_ha >= 0.5 & parcelles$surface_ha < 2), "parcelles\n")
cat("> 2 ha:", sum(parcelles$surface_ha >= 2), "parcelles\n")
```

### Visualisation des parcelles

```{r viz-parcelles-setup}
library(sf)
library(ggplot2)
# Charger les données depuis le cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)
# Charger la zone d'étude (toujours disponible)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r viz-parcelles, exercise=TRUE, exercise.eval=FALSE, exercise.lines=16, exercise.setup="viz-parcelles-setup"}
# Les données sont chargées depuis le cache (setup)
parcelles$surface_ha <- as.numeric(st_area(parcelles)) / 10000

ggplot() +
  geom_sf(data = parcelles, aes(fill = surface_ha), color = "white", linewidth = 0.2) +
  geom_sf(data = zone_etude_sf, fill = NA, color = "red", linewidth = 1) +
  coord_sf(datum = NA) +
  scale_fill_viridis_c(name = "Surface (ha)", trans = "log10") +
  labs(
    title = "Parcelles cadastrales",
    subtitle = paste(nrow(parcelles), "parcelles"),
    x = "X (m)", y = "Y (m)"
  ) +
  theme_minimal()
```

---

## Section 3 : Téléchargement du MNT

### Introduction

Le **Modèle Numérique de Terrain (MNT)** est essentiel pour :

- Calculer les pentes et expositions
- Normaliser les hauteurs LiDAR
- Analyser la topographie

Nous utiliserons le **RGE Alti** de l'IGN à **5m de résolution**.

### Exercice 3.1 : Télécharger le MNT

Appliquons le même pattern de cache pour le MNT (format GeoTIFF) :

```{r ex-3-1-setup}
library(sf)
library(terra)
library(happign)
# Charger la zone d'étude depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-3-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-3-1-setup"}
# === PATTERN DE CACHE POUR RASTER ===
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
mnt_filepath <- file.path(data_dir, "mnt.tif")

# Vérifier si le MNT existe déjà
if (file.exists(mnt_filepath)) {
  # CACHE HIT : Charger depuis le fichier local
  cat("Chargement du MNT depuis le cache...\n")
  mnt <- rast(mnt_filepath)
  cat("MNT chargé depuis:", mnt_filepath, "\n\n")
} else {
  # CACHE MISS : Télécharger depuis l'API IGN
  cat("Téléchargement du MNT depuis l'API IGN...\n")
  cat("(Cela peut prendre quelques secondes...)\n\n")

  mnt <- get_wms_raster(
    x = zone_etude_sf,
    layer = "ELEVATION.ELEVATIONGRIDCOVERAGE.HIGHRES",
    res = 5,
    crs = 2154,
    rgb = FALSE
  )

  # Sauvegarder dans le cache
  writeRaster(mnt, mnt_filepath, overwrite = TRUE)
  cat("MNT sauvegardé dans:", mnt_filepath, "\n\n")
}

# === INFORMATIONS SUR LE MNT ===
cat("=== MNT RGE Alti ===\n")
cat("Dimensions:", nrow(mnt), "x", ncol(mnt), "pixels\n")
cat("Résolution:", res(mnt)[1], "m\n")
cat("CRS:", crs(mnt, describe = TRUE)$code, "\n")

# Statistiques d'altitude
cat("\n=== Statistiques d'altitude ===\n")
stats <- global(mnt, c("min", "max", "mean", "sd"), na.rm = TRUE)
cat("Altitude min:", round(stats$min), "m\n")
cat("Altitude max:", round(stats$max), "m\n")
cat("Altitude moyenne:", round(stats$mean), "m\n")
cat("Écart-type:", round(stats$sd), "m\n")
```



### Exercice 3.2 : Calculer pente, exposition et ombrage

```{r ex-3-2-setup}
library(sf)
library(terra)
library(ggplot2)
# Charger le MNT depuis le cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
mnt_filepath <- file.path(data_dir, "mnt.tif")
mnt <- rast(mnt_filepath)
```

```{r ex-3-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=40, exercise.setup="ex-3-2-setup"}
# Le MNT est chargé depuis le cache (setup)
cat("MNT chargé depuis le cache\n\n")

# Calculer la pente (en degrés)
pente <- terrain(mnt, v = "slope", unit = "degrees")

# Calculer l'exposition (en degrés, 0 = Nord)
exposition <- terrain(mnt, v = "aspect", unit = "degrees")

# Calculer le hillshade (ombrage)
# Paramètres : angle = élévation du soleil, direction = azimut
pente_rad <- terrain(mnt, v = "slope", unit = "radians")
aspect_rad <- terrain(mnt, v = "aspect", unit = "radians")
hillshade <- shade(pente_rad, aspect_rad, angle = 45, direction = 315)

# Statistiques
cat("=== Statistiques topographiques ===\n")
cat("\nPente:\n")
cat(" Min:", round(global(pente, "min", na.rm = TRUE)$min, 1), "°\n")
cat(" Max:", round(global(pente, "max", na.rm = TRUE)$max, 1), "°\n")
cat(" Moyenne:", round(global(pente, "mean", na.rm = TRUE)$mean, 1), "°\n")

# Visualiser le hillshade
hillshade_df <- as.data.frame(hillshade, xy = TRUE)
names(hillshade_df)[3] <- "shade"

ggplot(hillshade_df, aes(x = x, y = y, fill = shade)) +
  geom_raster() +
  scale_fill_gradient(low = "black", high = "white", guide = "none") +
  coord_sf(datum = NA) +
  labs(
    title = "Hillshade (ombrage)",
    subtitle = "Soleil : élévation 45°, azimut 315° (NO)",
    x = "X (m)", y = "Y (m)"
  ) +
  theme_minimal()
```


### Visualisation du MNT

```{r viz-mnt-setup}
library(sf)
library(terra)
library(ggplot2)
# Charger les données depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
mnt <- tryCatch(rast(file.path(data_dir, "mnt.tif")), error = function(e) NULL)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r viz-mnt, exercise=TRUE, exercise.eval=FALSE, exercise.lines=15, exercise.setup="viz-mnt-setup"}
if (!is.null(mnt)) {
  # Convertir en data.frame pour ggplot
  mnt_df <- as.data.frame(mnt, xy = TRUE)
  names(mnt_df)[3] <- "altitude"

  ggplot(mnt_df, aes(x = x, y = y, fill = altitude)) +
    geom_raster() +
    scale_fill_viridis_c(name = "Altitude (m)", option = "terrain") +
    geom_sf(data = zone_etude_sf, fill = NA, color = "red", linewidth = 1, inherit.aes = FALSE) +
    coord_sf(datum = NA) +
    labs(
      title = "MNT RGE Alti 5m", subtitle = "Zone d'étude Vercors",
      x = "X (m)", y = "Y (m)"
    ) +
    theme_minimal()
} else {
  cat("MNT non disponible")
}
```

---

## Section 4 : BD Forêt et BD TOPO

### Introduction

La **BD Forêt** V2 fournit les formations végétales forestières avec :
- Type de formation (feuillus, conifères, mixte)
- Essence dominante
- Structure du peuplement

La **BD TOPO** fournit les éléments topographiques :
- Routes et chemins
- Cours d'eau
- Bâtiments

### Exercice 4.1 : Télécharger la BD Forêt V2

```{r ex-4-1-setup}
library(sf)
library(happign)
# Charger la zone d'étude depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-4-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-4-1-setup"}
# === PATTERN DE CACHE ===
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
bdforet_filepath <- file.path(data_dir, "bd_foret.gpkg")

if (file.exists(bdforet_filepath)) {
  cat("Chargement de la BD Forêt depuis le cache...\n")
  bd_foret <- st_read(bdforet_filepath, quiet = TRUE)
} else {
  cat("Téléchargement de la BD Forêt depuis l'API IGN...\n")
  bd_foret <- get_wfs(
    x = zone_etude_sf,
    layer = "LANDCOVER.FORESTINVENTORY.V2:formation_vegetale"
  )
  bd_foret <- st_transform(bd_foret, 2154)
  st_write(bd_foret, bdforet_filepath, quiet = TRUE)
  cat("BD Forêt sauvegardée dans:", bdforet_filepath, "\n")
}

cat("\n=== BD Forêt V2 ===\n")
cat("Formations téléchargées:", nrow(bd_foret), "\n")
cat("\nColonnes disponibles:\n")
cat(paste(names(bd_foret)[seq_len(min(8, ncol(bd_foret)))], collapse = ", "), "\n")

# Types de formations
if ("tfv" %in% names(bd_foret)) {
  cat("\n=== Types de formations ===\n")
  print(table(bd_foret$tfv))
}

# Surface forestière totale
surface_foret <- sum(st_area(bd_foret))
cat("\nSurface forestière:", round(as.numeric(surface_foret) / 10000, 1), "ha\n")
```


### Exercice 4.2 : Télécharger les routes

```{r ex-4-2-setup}
library(sf)
library(happign)
# Charger la zone d'étude depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-4-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-4-2-setup"}
# === PATTERN DE CACHE ===
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
routes_filepath <- file.path(data_dir, "routes.gpkg")

if (file.exists(routes_filepath)) {
  cat("Chargement des routes depuis le cache...\n")
  routes <- st_read(routes_filepath, quiet = TRUE)
} else {
  cat("Téléchargement des routes depuis l'API IGN...\n")
  routes <- get_wfs(
    x = zone_etude_sf,
    layer = "BDTOPO_V3:troncon_de_route"
  )
  routes <- st_transform(routes, 2154)
  st_write(routes, routes_filepath, quiet = TRUE)
  cat("Routes sauvegardées dans:", routes_filepath, "\n")
}

cat("\n=== Réseau routier ===\n")
cat("Tronçons téléchargés:", nrow(routes), "\n")

# Longueur totale
longueur_totale <- sum(st_length(routes))
cat("Longueur totale:", round(as.numeric(longueur_totale) / 1000, 1), "km\n")

# Types de routes
if ("nature" %in% names(routes)) {
  cat("\n=== Types de routes ===\n")
  print(table(routes$nature))
}
```


### Exercice 4.3 : Télécharger les cours d'eau

```{r ex-4-3-setup}
library(sf)
library(happign)
# Charger la zone d'étude depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-4-3, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-4-3-setup"}
# === PATTERN DE CACHE ===
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
courseau_filepath <- file.path(data_dir, "cours_eau.gpkg")

if (file.exists(courseau_filepath)) {
  cat("Chargement des cours d'eau depuis le cache...\n")
  cours_eau <- st_read(courseau_filepath, quiet = TRUE)
} else {
  cat("Téléchargement des cours d'eau depuis l'API IGN...\n")
  cours_eau <- get_wfs(
    x = zone_etude_sf,
    layer = "BDTOPO_V3:cours_d_eau"
  )
  if (nrow(cours_eau) > 0) {
    cours_eau <- st_transform(cours_eau, 2154)
    st_write(cours_eau, courseau_filepath, quiet = TRUE)
    cat("Cours d'eau sauvegardés dans:", courseau_filepath, "\n")
  }
}

if (nrow(cours_eau) > 0) {
  cat("\n=== Hydrographie ===\n")
  cat("Cours d'eau téléchargés:", nrow(cours_eau), "\n")
  longueur_totale <- sum(st_length(cours_eau))
  cat("Longueur totale:", round(as.numeric(longueur_totale) / 1000, 1), "km\n")
} else {
  cat("Aucun cours d'eau dans la zone d'étude\n")
}
```


### Visualisation BD Forêt

```{r viz-bdforet-setup}
library(sf)
library(ggplot2)
# Charger les données depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
bd_foret <- tryCatch(st_read(file.path(data_dir, "bd_foret.gpkg"), quiet = TRUE), error = function(e) NULL)
```

```{r viz-bdforet, exercise=TRUE, exercise.eval=FALSE, exercise.lines=15, exercise.setup="viz-bdforet-setup"}
if (!is.null(bd_foret) && nrow(bd_foret) > 0) {
  ggplot() +
    geom_sf(data = bd_foret, aes(fill = tfv), color = NA) +
    geom_sf(data = zone_etude_sf, fill = NA, color = "red", linewidth = 1) +
    coord_sf(datum = NA) +
    scale_fill_viridis_d(name = "Formation", option = "viridis") +
    labs(
      title = "BD Forêt V2",
      subtitle = "Formations végétales",
      x = "X (m)", y = "Y (m)"
    ) +
    theme_minimal() +
    theme(legend.position = "bottom")
} else {
  cat("BD Forêt non disponible - exécutez d'abord l'exercice 4.1")
}
```

---

## Section 5 : Téléchargement LiDAR HD

### Introduction

Le **LiDAR HD** de l'IGN couvre progressivement tout le territoire français avec une densité de **10 points/m²**.

Le package `lidarHD` permet de télécharger les dalles LiDAR qui intersectent notre zone d'étude.

**Note** : Le téléchargement peut être long selon la taille de la zone et la connexion internet.

### Exercice 5.1 : Identifier les dalles LiDAR

```{r ex-5-1-setup}
library(sf)
# Charger la zone d'étude depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-5-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.timelimit=600, exercise.setup="ex-5-1-setup"}
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
# Vérifier si lidarHD est disponible
if (requireNamespace("lidarHD", quietly = TRUE)) {
  library(lidarHD)

  cat("=== Identification des dalles LiDAR HD ===\n\n")
  cat("Chargement du tableau d'assemblage des dalles...\n")
  cat("(Cela peut prendre quelques secondes)\n\n")

  # Charger le tableau d'assemblage des dalles classifiées
  # La fonction interroge le WFS de l'IGN
  ta <- load_classified_ta(
    bbox = st_bbox(st_transform(zone_etude_sf, 4326)),
    save_dir = data_dir
  )

  cat("Dalles disponibles dans la zone:", nrow(ta), "\n\n")

  if (nrow(ta) > 0) {
    cat("=== Informations sur les dalles ===\n")
    cat("Colonnes disponibles:", paste(names(ta)[seq_len(min(5, ncol(ta)))], collapse = ", "), "\n\n")

    # Afficher quelques dalles
    cat("Premières dalles:\n")
    print(head(ta[, c("name", "bloc")], 5))
  }
} else {
  cat("Package lidarHD non installé.\n")
  cat("Installation: remotes::install_github('Jean-Roc/lidarHD')\n")
}
```

### Exercice 5.2 : Télécharger les dalles LiDAR

**Attention** : Ce téléchargement peut prendre plusieurs minutes !

Les données LiDAR seront sauvegardées dans le répertoire de cache pour réutilisation.

```{r ex-5-2-setup}
library(sf)
# Charger la zone d'étude depuis le cache ou le package
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
zone_filepath <- file.path(data_dir, "zone_etude.gpkg")
if (file.exists(zone_filepath)) {
  zone_etude_sf <- st_read(zone_filepath, layer = "zone_etude", quiet = TRUE)
} else {
  zone_pkg <- system.file("extdata", "zone_etude.gpkg", package = "nemeton")
  zone_etude_sf <- st_read(zone_pkg, quiet = TRUE)
}
```

```{r ex-5-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.timelimit=600, exercise.setup="ex-5-2-setup"}
if (requireNamespace("lidarHD", quietly = TRUE)) {
  library(lidarHD)

  # === DÉFINIR LE RÉPERTOIRE DE CACHE ===
  if (requireNamespace("rappdirs", quietly = TRUE)) {
    data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
  } else {
    data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
  }
  dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)
  lidar_dir <- file.path(data_dir, "lidar_hd")
  dir.create(lidar_dir, showWarnings = FALSE, recursive = TRUE)

  cat("=== Téléchargement LiDAR HD ===\n")
  cat("Répertoire de sortie:", lidar_dir, "\n\n")

  # calcule le nombre de fichiers qui sont à télécharger
  # La fonction interroge le WFS de l'IGN
  ta <- load_classified_ta(
    bbox = st_bbox(st_transform(zone_etude_sf, 4326)),
    save_dir = data_dir
  )
  # Vérifier si tous les fichiers existent déjà
  fichiers_existants <- list.files(lidar_dir,
    pattern = "\\.copc\\.laz$",
    full.names = TRUE, recursive = TRUE
  )

  if (length(fichiers_existants) >= nrow(ta)) {
    cat("Fichiers déjà téléchargés:", length(fichiers_existants), "\n")
    cat("Utilisez le cache existant.\n")
  } else {
    cat("Chargement du tableau d'assemblage...\n")
    cat("Dalles à télécharger:", nrow(ta), "\n\n")

    if (nrow(ta) > 0) {
      cat("Téléchargement en cours...\n")
      cat("(Attention: plusieurs centaines de Mo par dalle)\n\n")

      # Télécharger les dalles (prompt=FALSE pour mode non-interactif)
      tryCatch(
        {
          ta_result <- download_files(ta,
            roi = zone_etude_sf,
            folder = lidar_dir, prompt = FALSE
          )
          cat("Téléchargement terminé.\n")
        },
        error = function(e) {
          cat("Erreur:", e$message, "\n")
        }
      )
    }
  }

  # Lister les fichiers disponibles
  fichiers_laz <- list.files(lidar_dir, pattern = "\\.laz$", recursive = TRUE)
  cat("\nFichiers LiDAR disponibles:", length(fichiers_laz), "\n")
} else {
  cat("Package lidarHD non disponible.\n")
}
```

---

## Section 6 : Récapitulatif et Export

### Introduction

Toutes les données téléchargées sont déjà sauvegardées dans votre **répertoire de cache local**. Cette section vous montre comment :

1. Vérifier ce qui a été téléchargé
2. Créer un GeoPackage consolidé pour un projet

### Exercice 6.1 : Inventorier les données téléchargées

```{r ex-6-1-setup}
library(sf)
library(terra)
library(lidaRtRee)
```

```{r ex-6-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-6-1-setup"}
# === INVENTAIRE DU CACHE ===
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)

cat("=== Répertoire de cache ===\n")
cat("Chemin:", data_dir, "\n\n")

# Lister tous les fichiers
fichiers <- list.files(data_dir, full.names = TRUE, recursive = TRUE)

cat("=== Fichiers téléchargés ===\n")
total_size <- 0
for (f in fichiers) {
  taille_mo <- file.size(f) / (1024 * 1024)
  total_size <- total_size + taille_mo
  cat(sprintf("- %s (%.2f Mo)\n", basename(f), taille_mo))
}
cat(sprintf("\nTotal: %.2f Mo\n", total_size))

# Détails des données vectorielles
cat("\n=== Détails des couches ===\n")
gpkg_files <- list.files(data_dir, pattern = "\\.gpkg$", full.names = TRUE)
for (gpkg in gpkg_files) {
  cat("\n", basename(gpkg), ":\n", sep = "")
  couches <- st_layers(gpkg)
  for (i in seq_len(nrow(couches))) {
    cat("  -", couches$name[i], ":", couches$features[i], "entités\n")
  }
}

# === MÉTRIQUES LIDAR DEPUIS QUATRE_MONTAGNES ===
cat("\n=== Métriques LiDAR (quatre_montagnes) ===\n")
data("quatre_montagnes", package = "lidaRtRee")

# Filtrer sur les clusters Centre utilisés dans le tutoriel
clusters_centre <- c(
  "Verc-02", "Verc-05", "Verc-06", "Verc-C1",
  "Verc-C2", "Verc-S4","Verc-S7"
)
qm_centre <- quatre_montagnes[quatre_montagnes$cluster_id %in% clusters_centre, ]

cat("Placettes:", nrow(qm_centre), "\n\n")

# Métriques LiDAR disponibles
metriques <- c(
  "zmax", "zmean", "zsd", "zq25", "zq50", "zq75", "zq95",
  "zentropy", "pzabove2", "Tree_density"
)

cat("Métrique         Min      Moy      Max    Unité\n")
for (m in metriques) {
  if (m %in% names(qm_centre)) {
    vals <- qm_centre[[m]]
    unite <- ifelse(m %in% c("zmax", "zmean", "zsd", "zq25", "zq50", "zq75", "zq95"), "m",
      ifelse(m == "pzabove2", "%",
        ifelse(m == "Tree_density", "arb/ha", "")
      )
    )
    cat(sprintf(
      "%-12s %8.1f %8.1f %8.1f    %s\n",
      m, min(vals, na.rm = TRUE), mean(vals, na.rm = TRUE),
      max(vals, na.rm = TRUE), unite
    ))
  }
}

# === EXPORT EN GEOPACKAGE ===
cat("\n=== Export en GeoPackage ===\n")

# Convertir en objet sf avec coordonnées
qm_sf <- st_as_sf(qm_centre, coords = c("X", "Y"), crs = 2154)

# Fichier de sortie
output_gpkg <- file.path(data_dir, "placettes_lidar.gpkg")

# Sauvegarder
st_write(qm_sf, output_gpkg, layer = "placettes_metrics",
         delete_dsn = TRUE, quiet = TRUE)

cat("Fichier créé:", output_gpkg, "\n")
cat("Couche: placettes_metrics\n")
cat("Entités:", nrow(qm_sf), "\n")
cat("CRS: EPSG:2154 (Lambert-93)\n")
```

### Exercice 6.2 : Créer un GeoPackage consolidé

Regroupez toutes les données dans un seul GeoPackage pour un projet :

```{r ex-6-2-setup}
library(sf)
library(terra)
```

```{r ex-6-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-6-2-setup"}
# === EXPORT CONSOLIDÉ ===
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
dir.create(data_dir, showWarnings = FALSE, recursive = TRUE)

# Chemin du GeoPackage consolidé
gpkg_export <- file.path(data_dir, "quatre_montagnes_COMPLET.gpkg")

cat("=== Export consolidé ===\n")
cat("Destination:", gpkg_export, "\n\n")

# 1. Zone d'étude et placettes
tryCatch(
  {
    zone <- st_read(file.path(data_dir, "zone_etude.gpkg"), layer = "zone_etude", quiet = TRUE)
    placettes <- st_read(file.path(data_dir, "zone_etude.gpkg"), layer = "placettes", quiet = TRUE)
    st_write(zone, gpkg_export, layer = "zone_etude", delete_layer = TRUE, quiet = TRUE)
    st_write(placettes, gpkg_export, layer = "placettes", append = TRUE, quiet = TRUE)
    cat("Zone et placettes exportées\n")
  },
  error = function(e) cat("Zone: non disponible\n")
)

# 2. Parcelles cadastrales
tryCatch(
  {
    parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)
    st_write(parcelles, gpkg_export, layer = "parcelles", append = TRUE, quiet = TRUE)
    cat("Cadastre exporté:", nrow(parcelles), "parcelles\n")
  },
  error = function(e) cat("Cadastre: non disponible (exécuter ex 2.1)\n")
)

# 3. BD Forêt
tryCatch(
  {
    bd_foret <- st_read(file.path(data_dir, "bd_foret.gpkg"), quiet = TRUE)
    st_write(bd_foret, gpkg_export, layer = "bd_foret", append = TRUE, quiet = TRUE)
    cat("BD Forêt exportée:", nrow(bd_foret), "formations\n")
  },
  error = function(e) cat("BD Forêt: non disponible (exécuter ex 4.1)\n")
)

# 4. Routes
tryCatch(
  {
    routes <- st_read(file.path(data_dir, "routes.gpkg"), quiet = TRUE)
    st_write(routes, gpkg_export, layer = "routes", append = TRUE, quiet = TRUE)
    cat("Routes exportées:", nrow(routes), "tronçons\n")
  },
  error = function(e) cat("Routes: non disponible (exécuter ex 4.2)\n")
)

# 5. Cours d'eau
tryCatch(
  {
    cours_eau <- st_read(file.path(data_dir, "cours_eau.gpkg"), quiet = TRUE)
    st_write(cours_eau, gpkg_export, layer = "cours_eau", append = TRUE, quiet = TRUE)
    cat("Cours d'eau exportés:", nrow(cours_eau), "\n")
  },
  error = function(e) cat("Cours d'eau: non disponible (exécuter ex 4.3)\n")
)

# Résumé
cat("\n=== GeoPackage créé ===\n")
cat("Fichier:", gpkg_export, "\n")
cat("Taille:", round(file.size(gpkg_export) / (1024 * 1024), 2), "Mo\n")
cat("Couches:", paste(st_layers(gpkg_export)$name, collapse = ", "), "\n")
```

---

## Quiz final

```{r quiz-final, echo=FALSE}
quiz(
  caption = "Vérifiez vos connaissances",
  question("Quelle fonction happign permet de télécharger des données vectorielles ?",
    answer("get_wms_raster()"),
    answer("get_wfs()", correct = TRUE),
    answer("get_wmts()"),
    answer("download_ign()"),
    allow_retry = TRUE
  ),
  question("Quelle est la résolution du MNT RGE Alti haute résolution ?",
    answer("1 mètre"),
    answer("5 mètres", correct = TRUE),
    answer("10 mètres"),
    answer("25 mètres"),
    allow_retry = TRUE
  ),
  question("Quel format de fichier permet de stocker plusieurs couches géographiques ?",
    answer("Shapefile (.shp)"),
    answer("GeoTIFF (.tif)"),
    answer("GeoPackage (.gpkg)", correct = TRUE),
    answer("CSV (.csv)"),
    allow_retry = TRUE
  ),
  question("Quelle couche WFS contient les parcelles cadastrales ?",
    answer("BDTOPO_V3:parcelle"),
    answer("CADASTRALPARCELS.PARCELLAIRE_EXPRESS:parcelle", correct = TRUE),
    answer("LANDCOVER.FORESTINVENTORY.V2:parcelle"),
    answer("IGN.CADASTRE:parcelle"),
    allow_retry = TRUE
  ),
  question("Pourquoi ajoute-t-on un buffer de 500m autour des placettes ?",
    answer("Pour réduire le temps de calcul"),
    answer("Pour avoir un contexte spatial et éviter les effets de bord", correct = TRUE),
    answer("Pour corriger les erreurs GPS"),
    answer("Pour convertir les coordonnées"),
    allow_retry = TRUE
  )
)
```

---

## Synthèse

### Ce que vous avez appris

Dans ce tutoriel, vous avez appris à :

1. **Créer une zone d'étude** à partir de placettes forestières (lidaRtRee)
2. **Télécharger des données IGN** via les APIs WFS et WMS (happign)
3. **Manipuler des données spatiales** avec sf et terra
4. **Exporter vos données** en GeoPackage

### Données acquises

| Couche | Source | Format |
|--------|--------|--------|
| Zone d'étude | lidaRtRee | Polygone |
| Placettes | lidaRtRee | Points |
| Cadastre | IGN WFS | Polygones |
| MNT | IGN WMS | Raster 5m |
| BD Forêt V2 | IGN WFS | Polygones |
| Routes | IGN WFS | Lignes |
| Cours d'eau | IGN WFS | Lignes |
| LiDAR HD | IGN lidarHD | LAZ |

### Tutoriel suivant

→ **Tutorial 02 : LiDAR** — Familles C, P, E, A (9 indicateurs) : Traiter les données LiDAR HD pour calculer les indicateurs Carbone (C1, C2), Production (P1, P2, P3), Énergie (E1, E2) et Air (A1, A2).

---

**Bravo !** Vous avez terminé le Tutorial 1.

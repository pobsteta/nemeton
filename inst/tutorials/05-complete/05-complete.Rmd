---
title: "Tutorial 05 : Normalisation et Indice Composite I_nemeton"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Normalisation des 32 indicateurs, inversion des indicateurs négatifs,
  et calcul de l'indice composite pondéré I_nemeton.
---

```{r setup, include=FALSE}
library(learnr)
library(sf)
library(dplyr)
library(ggplot2)

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

# Répertoire cache
data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

## Introduction

### Objectifs du Tutorial

Bienvenue dans le **cinquième tutoriel** de la série nemeton !

Dans les tutoriels précédents, vous avez calculé progressivement tous les indicateurs :
- **T01** : Zone d'étude, parcelles et données de base
- **T02** : Métriques LiDAR → C1, C2, P1, P2, P3, A1, A2, E1, E2 (9 indicateurs)
- **T03** : Indicateurs terrain → W1, W2, W3, R1, R2, R3, R4, S1, S2, S3, F1, F2 (12 indicateurs)
- **T04** : Indicateurs écologiques → B1, B2, B3, L1, L2, L3, T1, T2, N1, N2, N3 (11 indicateurs)

**Total : 32 indicateurs calculés.**

Tous ces indicateurs sont maintenant dans votre fichier **`parcelles.gpkg`**.

Dans ce tutoriel, vous allez :
1. **Vérifier** la complétude des indicateurs
2. **Normaliser** les valeurs sur une échelle [0, 1]
3. **Inverser** les indicateurs négatifs (risques, érosion)
4. **Calculer** les moyennes par famille
5. **Créer** l'indice composite I_nemeton

### Les 12 Familles d'Indicateurs

```{r familles-diagram, echo=FALSE}
familles <- data.frame(
  Code = c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N"),
  Famille = c(
    "Carbone", "Biodiversité", "Eau", "Air", "Sol", "Paysage",
    "Temporel", "Risques", "Social", "Production", "Énergie", "Naturalité"
  ),
  Indicateurs = c(
    "C1, C2", "B1, B2, B3", "W1, W2, W3", "A1, A2",
    "F1, F2", "L1, L2, L3", "T1, T2", "R1, R2, R3, R4",
    "S1, S2, S3", "P1, P2, P3", "E1, E2", "N1, N2, N3"
  ),
  Nb = c(2, 3, 3, 2, 2, 3, 2, 4, 3, 3, 2, 3)
)
knitr::kable(familles, caption = "Les 12 familles d'indicateurs nemeton (32 indicateurs)")
```

### Indicateurs Simples et Composites

Les 32 indicateurs se répartissent en **24 indicateurs simples** (mesure directe) et **8 indicateurs composites** (combinaison de plusieurs métriques).

```{r indicateurs-types, echo=FALSE}
types_ind <- data.frame(
  Type = c(rep("Simple", 24), rep("Composite", 8)),
  Code = c(
    # Simples (24)
    "C1", "C2", "P1", "P2", "E1", "A1",
    "W1", "W2", "W3", "F1", "F2",
    "B1", "B2", "L2", "T1", "T2",
    "R1", "R2", "R3", "S1", "S2", "S3", "N1", "N2",
    # Composites (8)
    "P3", "E2", "A2", "B3", "L1", "L3", "R4", "N3"
  ),
  Nom = c(
    # Simples
    "Stock carbone aérien", "Vitalité NDVI", "Volume bois sur pied",
    "Productivité forestière", "Potentiel bois-énergie", "Couverture forestière",
    "Densité réseau hydro", "Zones humides", "TWI humidité",
    "Fertilité sol", "Risque érosion",
    "Habitats protégés", "Structure verticale", "Ratio lisière",
    "Ancienneté forêt", "Changement occupation",
    "Risque incendie", "Risque tempête", "Risque sécheresse",
    "Densité sentiers", "Accessibilité", "Proximité population",
    "Distance infrastructures", "Continuité forestière",
    # Composites
    "Qualité structurale", "Évitement carbone", "Qualité air",
    "Connectivité écologique", "Fragmentation paysage", "Intégration TVB",
    "Pression gibier", "Naturalité composite"
  ),
  Source = c(
    # Simples
    "LiDAR", "Sentinel-2", "LiDAR", "LiDAR", "LiDAR", "BD Forêt",
    "BD TOPO", "BD TOPO", "MNT", "BD Sol", "MNT + Couvert",
    "INPN", "LiDAR", "BD Forêt", "BD Forêt Anciennes", "CLC",
    "MNT + Végétation", "LiDAR + MNT", "Climat + Sol",
    "OSM", "BD TOPO", "INSEE",
    "BD TOPO + OSM", "BD Forêt",
    # Composites
    "P1 + P2 + LiDAR", "E1 × facteurs", "ATMO + couvert",
    "B1 + B2 + paysage", "Métriques paysage", "TVB verte + bleue",
    "Tableaux chasse", "N1 + N2 + L1 + B3"
  )
)

# Afficher en deux tableaux côte à côte
simples <- types_ind[types_ind$Type == "Simple", c("Code", "Nom", "Source")]
composites <- types_ind[types_ind$Type == "Composite", c("Code", "Nom", "Source")]

cat("**Indicateurs simples (24)** : mesure directe depuis une source de données\n\n")
knitr::kable(simples, row.names = FALSE)
```

```{r indicateurs-composites, echo=FALSE}
cat("\n**Indicateurs composites (8)** : combinaison de plusieurs métriques ou indicateurs\n\n")
knitr::kable(composites, row.names = FALSE)
```

## Chargement et Vérification

### Chargement des Parcelles

Toutes vos données sont maintenant dans un seul fichier `parcelles.gpkg` :

```{r load-parcelles-setup}
library(sf)
library(dplyr)

# Répertoire de cache
data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

# Liste des indicateurs attendus par famille (33 indicateurs au total)
indicateurs_par_famille <- list(
  C = c("C1", "C2"),
  B = c("B1", "B2", "B3"),
  W = c("W1", "W2", "W3"),
  A = c("A1", "A2"),
  F = c("F1", "F2"),
  L = c("L1", "L2", "L3"),
  T = c("T1", "T2"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  P = c("P1", "P2", "P3"),
  E = c("E1", "E2"),
  N = c("N1", "N2", "N3")
)
tous_indicateurs <- unlist(indicateurs_par_famille, use.names = FALSE)

# Indicateurs attendus par tutoriel (pour vérification)
indics_tuto02 <- c("C1", "C2", "P1", "P2", "P3", "A1", "A2", "E1", "E2")  # 9 indicateurs LiDAR
indics_tuto03 <- c("W1", "W2", "W3", "R1", "R2", "R3", "R4", "S1", "S2", "S3", "F1", "F2")  # 12 indicateurs terrain
indics_tuto04 <- c("B1", "B2", "B3", "L1", "L2", "L3", "T1", "T2", "N1", "N2", "N3")  # 11 indicateurs écologie
```

```{r load-parcelles, exercise=TRUE, exercise.setup="load-parcelles-setup"}
# Chemin vers les parcelles
parcelles_path <- file.path(data_dir, "parcelles.gpkg")

# Vérifier que le fichier existe
if (!file.exists(parcelles_path)) {
  stop("Fichier parcelles.gpkg non trouvé. Avez-vous complété les tutoriels 01-04 ?")
}

# Charger les parcelles
parcelles <- st_read(parcelles_path, quiet = TRUE)

cat("=== DONNÉES CHARGÉES ===\n")
cat("Parcelles:", nrow(parcelles), "\n")
cat("Colonnes:", ncol(parcelles), "\n")
cat("CRS:", st_crs(parcelles)$epsg, "\n")

# === VÉRIFICATION DES INDICATEURS PAR TUTORIEL ===
cat("\n=== VÉRIFICATION INDICATEURS PAR TUTORIEL ===\n")

# Indicateurs attendus par tutoriel
indics_tuto02 <- c("C1", "C2", "P1", "P2", "P3", "A1", "A2", "E1", "E2")  # LiDAR (9)
indics_tuto03 <- c("W1", "W2", "W3", "R1", "R2", "R3", "R4", "S1", "S2", "S3", "F1", "F2")  # Terrain (12)
indics_tuto04 <- c("B1", "B2", "B3", "L1", "L2", "L3", "T1", "T2", "N1", "N2", "N3")  # Écologie (11)

# Fonction de vérification
check_tuto <- function(nom, indics, data) {
  presents <- indics[indics %in% names(data)]
  manquants <- indics[!indics %in% names(data)]
  status <- if (length(manquants) == 0) "✓ COMPLET" else "⚠ INCOMPLET"
  cat(sprintf("\n%s (%d/%d): %s\n", nom, length(presents), length(indics), status))
  if (length(manquants) > 0) {
    cat(sprintf("  Manquants: %s\n", paste(manquants, collapse = ", ")))
    cat("  → Relancez ce tutoriel pour calculer ces indicateurs\n")
  }
  length(manquants) == 0
}

t02_ok <- check_tuto("Tutorial 02 (LiDAR)", indics_tuto02, parcelles)
t03_ok <- check_tuto("Tutorial 03 (Terrain)", indics_tuto03, parcelles)
t04_ok <- check_tuto("Tutorial 04 (Écologie)", indics_tuto04, parcelles)

# Bilan global
total_attendus <- length(c(indics_tuto02, indics_tuto03, indics_tuto04))
total_presents <- sum(c(indics_tuto02, indics_tuto03, indics_tuto04) %in% names(parcelles))

cat(sprintf("\n=== BILAN GLOBAL: %d/%d indicateurs ===\n", total_presents, total_attendus))

if (total_presents < total_attendus) {
  cat("\n⚠ ATTENTION: Certains indicateurs sont manquants.\n")
  cat("Le calcul de I_nemeton sera partiel.\n")
  cat("Pour un résultat complet, complétez d'abord les tutoriels précédents.\n")
} else {
  cat("\n✓ Tous les indicateurs sont présents. Prêt pour la normalisation !\n")
}
```

### Vérification des Indicateurs

```{r verif-indicateurs, exercise=TRUE, exercise.setup="load-parcelles-setup"}
# Charger les parcelles
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)

# Vérifier chaque famille
cat("=== VÉRIFICATION DES INDICATEURS ===\n\n")

for (famille in names(indicateurs_par_famille)) {
  indics <- indicateurs_par_famille[[famille]]
  presents <- indics[indics %in% names(parcelles)]
  manquants <- indics[!indics %in% names(parcelles)]

  status <- if (length(manquants) == 0) "✓" else "⚠"
  cat(sprintf("%s Famille %s: %d/%d indicateurs\n",
              status, famille, length(presents), length(indics)))

  if (length(manquants) > 0) {
    cat(sprintf("  Manquants: %s\n", paste(manquants, collapse = ", ")))
  }
}

# Bilan global
presents <- sum(tous_indicateurs %in% names(parcelles))
cat(sprintf("\n=== BILAN: %d/%d indicateurs présents ===\n",
            presents, length(tous_indicateurs)))
```

### Statistiques Descriptives

```{r stats-indicateurs-setup}
library(sf)
library(dplyr)

data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

indicateurs_par_famille <- list(
  C = c("C1", "C2"),
  B = c("B1", "B2", "B3"),
  W = c("W1", "W2", "W3"),
  A = c("A1", "A2"),
  F = c("F1", "F2"),
  L = c("L1", "L2", "L3"),
  T = c("T1", "T2"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  P = c("P1", "P2", "P3"),
  E = c("E1", "E2"),
  N = c("N1", "N2", "N3")
)
tous_indicateurs <- unlist(indicateurs_par_famille, use.names = FALSE)
```

```{r stats-indicateurs, exercise=TRUE, exercise.setup="stats-indicateurs-setup"}
# Charger les données
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)

# Indicateurs présents
indics_presents <- tous_indicateurs[tous_indicateurs %in% names(parcelles)]

if (length(indics_presents) > 0) {
  # Extraire les données numériques
  data_indics <- parcelles %>%
    st_drop_geometry() %>%
    select(all_of(indics_presents))

  # Statistiques par indicateur
  stats <- data.frame(
    Indicateur = indics_presents,
    Min = sapply(data_indics, min, na.rm = TRUE),
    Max = sapply(data_indics, max, na.rm = TRUE),
    Moyenne = sapply(data_indics, mean, na.rm = TRUE),
    NA_count = sapply(data_indics, function(x) sum(is.na(x)))
  )

  print(stats)
} else {
  cat("Aucun indicateur trouvé dans les données.\n")
}
```

## Normalisation Min-Max

### Pourquoi Normaliser ?

Les indicateurs ont des **unités et échelles très différentes** :

| Indicateur | Unité | Plage typique |
|------------|-------|---------------|
| C1 (stock carbone) | tC/ha | 0 - 300 |
| W1 (TWI) | sans unité | 2 - 20 |
| S1 (distance routes) | mètres | 0 - 5000 |
| B1 (protection) | score 0-100 | 0 - 100 |
| R1 (risque feu) | score 0-100 | 0 - 100 |

Pour les **comparer** et les **agréger**, il faut les ramener sur une échelle commune **[0, 1]**.

### Méthode Min-Max

La normalisation **Min-Max** transforme chaque valeur selon :

$$x_{norm} = \frac{x - x_{min}}{x_{max} - x_{min}}$$

- Résultat : valeurs entre 0 et 1
- 0 = valeur minimale observée
- 1 = valeur maximale observée

```{r normalize-function-setup}
library(sf)
library(dplyr)
data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r normalize-function, exercise=TRUE, exercise.setup="normalize-function-setup"}
# Fonction de normalisation Min-Max
normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)

  # Cas particulier : valeur constante

  if (max_val == min_val) {
    return(rep(0.5, length(x)))
  }

  (x - min_val) / (max_val - min_val)
}

# Test sur des valeurs exemple
valeurs_test <- c(10, 25, 50, 75, 100)
valeurs_norm <- normalize_minmax(valeurs_test)

cat("Valeurs originales:", valeurs_test, "\n")
cat("Valeurs normalisées:", round(valeurs_norm, 3), "\n")
cat("\nVérification: min =", min(valeurs_norm), ", max =", max(valeurs_norm))
```

### Exercice : Normaliser Tous les Indicateurs

Appliquez la normalisation Min-Max à tous les indicateurs présents :

```{r normalize-all-setup}
library(sf)
library(dplyr)

data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

indicateurs_par_famille <- list(
  C = c("C1", "C2"),
  B = c("B1", "B2", "B3"),
  W = c("W1", "W2", "W3"),
  A = c("A1", "A2"),
  F = c("F1", "F2"),
  L = c("L1", "L2", "L3"),
  T = c("T1", "T2"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  P = c("P1", "P2", "P3"),
  E = c("E1", "E2"),
  N = c("N1", "N2", "N3")
)
tous_indicateurs <- unlist(indicateurs_par_famille, use.names = FALSE)

normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)
  if (max_val == min_val) return(rep(0.5, length(x)))
  (x - min_val) / (max_val - min_val)
}
```

```{r normalize-all, exercise=TRUE, exercise.lines=35, exercise.setup="normalize-all-setup"}
# Charger les données
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)

# Indicateurs présents
indics_presents <- tous_indicateurs[tous_indicateurs %in% names(parcelles)]

cat("Normalisation de", length(indics_presents), "indicateurs...\n\n")

# Normaliser chaque indicateur
for (indic in indics_presents) {
  # Nom de la colonne normalisée
  col_norm <- paste0(indic, "_norm")

  # Appliquer la normalisation
  parcelles[[col_norm]] <- normalize_minmax(parcelles[[indic]])

  # Afficher le résultat
  cat(sprintf("%s: [%.1f - %.1f] → %s: [0 - 1]\n",
              indic,
              min(parcelles[[indic]], na.rm = TRUE),
              max(parcelles[[indic]], na.rm = TRUE),
              col_norm))
}

# Vérifier les nouvelles colonnes
cols_norm <- grep("_norm$", names(parcelles), value = TRUE)
cat("\n=== BILAN ===\n")
cat(length(cols_norm), "indicateurs normalisés créés\n")
```

## Inversion des Indicateurs Négatifs

### Indicateurs à Logique Inverse

Certains indicateurs ont une logique **inverse** : une valeur élevée est **défavorable**.

| Indicateur | Signification | Logique | Action |
|------------|---------------|---------|--------|
| R1 | Risque feu | Élevé = mauvais | **Inverser** |
| R2 | Risque tempête | Élevé = mauvais | **Inverser** |
| R3 | Risque sécheresse | Élevé = mauvais | **Inverser** |
| R4 | Pression gibier | Élevé = mauvais | **Inverser** |
| F1 | Risque érosion | Élevé = mauvais | **Inverser** |
| L1 | Densité lisières | Élevé = fragmenté | **Inverser** |

Pour ces indicateurs, on applique : `score_final = 1 - score_normalisé`

### Exercice : Inverser les Indicateurs Négatifs

```{r invert-setup, include=FALSE}
library(sf)
library(dplyr)

data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

indicateurs_par_famille <- list(
  C = c("C1", "C2"),
  B = c("B1", "B2", "B3"),
  W = c("W1", "W2", "W3"),
  A = c("A1", "A2"),
  F = c("F1", "F2"),
  L = c("L1", "L2", "L3"),
  T = c("T1", "T2"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  P = c("P1", "P2", "P3"),
  E = c("E1", "E2"),
  N = c("N1", "N2", "N3")
)
tous_indicateurs <- unlist(indicateurs_par_famille, use.names = FALSE)

normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)
  if (max_val == min_val) return(rep(0.5, length(x)))
  (x - min_val) / (max_val - min_val)
}

# Indicateurs à inverser
indicateurs_negatifs <- c("R1", "R2", "R3", "R4", "F1", "L1")
```

```{r invert-indicators, exercise=TRUE, exercise.lines=40, exercise.setup="invert-setup"}
# Charger et normaliser
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)

# D'abord normaliser tous les indicateurs présents
indics_presents <- tous_indicateurs[tous_indicateurs %in% names(parcelles)]
for (indic in indics_presents) {
  parcelles[[paste0(indic, "_norm")]] <- normalize_minmax(parcelles[[indic]])
}

# Indicateurs à inverser (valeur élevée = défavorable)
indicateurs_negatifs <- c("R1", "R2", "R3", "R4", "F1", "L1")

cat("=== INVERSION DES INDICATEURS NÉGATIFS ===\n\n")

for (indic in indicateurs_negatifs) {
  col_norm <- paste0(indic, "_norm")

  if (col_norm %in% names(parcelles)) {
    # Valeurs avant inversion
    avant <- mean(parcelles[[col_norm]], na.rm = TRUE)

    # Inverser : 1 - x
    parcelles[[col_norm]] <- 1 - parcelles[[col_norm]]

    # Valeurs après inversion
    apres <- mean(parcelles[[col_norm]], na.rm = TRUE)

    cat(sprintf("%s: moyenne %.3f → %.3f (inversé)\n", indic, avant, apres))
  }
}

cat("\nInterprétation après inversion:\n")
cat("- Risque élevé (ex: R1=0.9) → score faible (0.1)\n")
cat("- Risque faible (ex: R1=0.1) → score élevé (0.9)\n")
```

## Calcul des Moyennes par Famille

### Agrégation par Famille

Chaque famille est représentée par la **moyenne** de ses indicateurs normalisés.

```{r family-means-setup}
library(sf)
library(dplyr)

data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

indicateurs_par_famille <- list(
  C = c("C1", "C2"),
  B = c("B1", "B2", "B3"),
  W = c("W1", "W2", "W3"),
  A = c("A1", "A2"),
  F = c("F1", "F2"),
  L = c("L1", "L2", "L3"),
  T = c("T1", "T2"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  P = c("P1", "P2", "P3"),
  E = c("E1", "E2"),
  N = c("N1", "N2", "N3")
)

normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)
  if (max_val == min_val) return(rep(0.5, length(x)))
  (x - min_val) / (max_val - min_val)
}

indicateurs_negatifs <- c("R1", "R2", "R3", "R4", "F1", "L1")
```

```{r family-means, exercise=TRUE, exercise.lines=50, exercise.setup="family-means-setup"}
# Charger les données
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)

# Normaliser tous les indicateurs présents
tous_indicateurs <- unlist(indicateurs_par_famille, use.names = FALSE)
indics_presents <- tous_indicateurs[tous_indicateurs %in% names(parcelles)]

for (indic in indics_presents) {
  parcelles[[paste0(indic, "_norm")]] <- normalize_minmax(parcelles[[indic]])
}

# Inverser les indicateurs négatifs
for (indic in indicateurs_negatifs) {
  col_norm <- paste0(indic, "_norm")
  if (col_norm %in% names(parcelles)) {
    parcelles[[col_norm]] <- 1 - parcelles[[col_norm]]
  }
}

# Calculer la moyenne par famille
cat("=== MOYENNES PAR FAMILLE ===\n\n")

for (famille in names(indicateurs_par_famille)) {
  # Colonnes normalisées pour cette famille
  cols_norm <- paste0(indicateurs_par_famille[[famille]], "_norm")
  cols_presentes <- cols_norm[cols_norm %in% names(parcelles)]

  if (length(cols_presentes) > 0) {
    # Calculer la moyenne (en gérant les NA)
    famille_col <- paste0("family_", famille)
    parcelles[[famille_col]] <- rowMeans(
      st_drop_geometry(parcelles)[, cols_presentes, drop = FALSE],
      na.rm = TRUE
    )

    # Statistiques
    moy <- mean(parcelles[[famille_col]], na.rm = TRUE)
    cat(sprintf("Famille %s: %d indicateurs → %s (moyenne: %.3f)\n",
                famille, length(cols_presentes), famille_col, moy))
  } else {
    cat(sprintf("Famille %s: aucun indicateur disponible\n", famille))
  }
}

# Vérifier les colonnes famille créées
cols_famille <- grep("^family_", names(parcelles), value = TRUE)
cat("\n", length(cols_famille), "familles calculées\n")
```

## Indice Composite I_nemeton

### Pondération des Familles

L'indice composite agrège les 12 familles avec des **pondérations** reflétant les priorités :

```{r ponderations, echo=FALSE}
poids <- data.frame(
  Famille = c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N"),
  Nom = c(
    "Carbone", "Biodiversité", "Eau", "Air", "Sol", "Paysage",
    "Temporel", "Risques", "Social", "Production", "Énergie", "Naturalité"
  ),
  Poids = c(10, 12, 8, 6, 6, 5, 4, 10, 8, 8, 5, 8)
)
poids$Pct <- round(poids$Poids / sum(poids$Poids) * 100, 1)
knitr::kable(poids, caption = "Pondérations par défaut des familles")
```

### Formule de l'Indice Composite

$$I_{nemeton} = \sum_{f=1}^{12} w_f \cdot \bar{I}_f$$

Où :
- $w_f$ : poids normalisé de la famille f (somme = 1)
- $\bar{I}_f$ : moyenne des indicateurs normalisés de la famille f

### Exercice : Calculer I_nemeton

```{r composite-setup, include=FALSE}
library(sf)
library(dplyr)

data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

indicateurs_par_famille <- list(
  C = c("C1", "C2"),
  B = c("B1", "B2", "B3"),
  W = c("W1", "W2", "W3"),
  A = c("A1", "A2"),
  F = c("F1", "F2"),
  L = c("L1", "L2", "L3"),
  T = c("T1", "T2"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  P = c("P1", "P2", "P3"),
  E = c("E1", "E2"),
  N = c("N1", "N2", "N3")
)

normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)
  if (max_val == min_val) return(rep(0.5, length(x)))
  (x - min_val) / (max_val - min_val)
}

indicateurs_negatifs <- c("R1", "R2", "R3", "R4", "F1", "L1")

# Poids des familles
poids_familles <- c(
  C = 10, B = 12, W = 8, A = 6, F = 6, L = 5,
  T = 4, R = 10, S = 8, P = 8, E = 5, N = 8
)
```

```{r composite-index, exercise=TRUE, exercise.lines=60, exercise.setup="composite-setup"}
# Charger les données
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)

# === ÉTAPE 1: Normaliser tous les indicateurs ===
tous_indicateurs <- unlist(indicateurs_par_famille, use.names = FALSE)
indics_presents <- tous_indicateurs[tous_indicateurs %in% names(parcelles)]

for (indic in indics_presents) {
  parcelles[[paste0(indic, "_norm")]] <- normalize_minmax(parcelles[[indic]])
}

# === ÉTAPE 2: Inverser les indicateurs négatifs ===
for (indic in indicateurs_negatifs) {
  col_norm <- paste0(indic, "_norm")
  if (col_norm %in% names(parcelles)) {
    parcelles[[col_norm]] <- 1 - parcelles[[col_norm]]
  }
}

# === ÉTAPE 3: Calculer les moyennes par famille ===
for (famille in names(indicateurs_par_famille)) {
  cols_norm <- paste0(indicateurs_par_famille[[famille]], "_norm")
  cols_presentes <- cols_norm[cols_norm %in% names(parcelles)]

  if (length(cols_presentes) > 0) {
    parcelles[[paste0("family_", famille)]] <- rowMeans(
      st_drop_geometry(parcelles)[, cols_presentes, drop = FALSE],
      na.rm = TRUE
    )
  }
}

# === ÉTAPE 4: Calculer I_nemeton ===
# Normaliser les poids
poids_norm <- poids_familles / sum(poids_familles)

# Initialiser l'indice à 0
parcelles$I_nemeton <- 0

# Ajouter la contribution de chaque famille
for (famille in names(poids_familles)) {
  col_famille <- paste0("family_", famille)
  if (col_famille %in% names(parcelles)) {
    contribution <- poids_norm[famille] * parcelles[[col_famille]]
    contribution[is.na(contribution)] <- 0
    parcelles$I_nemeton <- parcelles$I_nemeton + contribution
  }
}

# === RÉSULTATS ===
cat("=== INDICE COMPOSITE I_NEMETON ===\n\n")
cat("Statistiques:\n")
cat(sprintf("  Min: %.3f\n", min(parcelles$I_nemeton, na.rm = TRUE)))
cat(sprintf("  Max: %.3f\n", max(parcelles$I_nemeton, na.rm = TRUE)))
cat(sprintf("  Moyenne: %.3f\n", mean(parcelles$I_nemeton, na.rm = TRUE)))
cat(sprintf("  Écart-type: %.3f\n", sd(parcelles$I_nemeton, na.rm = TRUE)))
```

### Classification des Parcelles

```{r classification-setup}
library(sf)
library(dplyr)
library(ggplot2)

data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

```{r classification, exercise=TRUE, exercise.setup="classification-setup"}
# Simuler des résultats I_nemeton pour l'exercice
set.seed(42)
n <- 50
resultats <- data.frame(
  id = seq_len(n),
  I_nemeton = rbeta(n, 2, 2)  # Distribution entre 0 et 1
)

# Classifier en 4 classes
resultats$classe <- cut(
  resultats$I_nemeton,
  breaks = c(0, 0.25, 0.5, 0.75, 1),
  labels = c("Faible", "Moyen", "Bon", "Excellent"),
  include.lowest = TRUE
)

# Distribution
cat("=== DISTRIBUTION DES CLASSES ===\n\n")
print(table(resultats$classe))

cat("\nStatistiques par classe:\n")
resultats %>%
  group_by(classe) %>%
  summarise(
    n = n(),
    I_moy = round(mean(I_nemeton), 3),
    I_min = round(min(I_nemeton), 3),
    I_max = round(max(I_nemeton), 3)
  ) %>%
  print()
```

### Visualisation de l'Indice

```{r visu-index, exercise=TRUE, exercise.setup="classification-setup"}
# Données simulées
set.seed(42)
n <- 50
resultats <- data.frame(
  id = seq_len(n),
  I_nemeton = rbeta(n, 2, 2)
)
resultats$classe <- cut(
  resultats$I_nemeton,
  breaks = c(0, 0.25, 0.5, 0.75, 1),
  labels = c("Faible", "Moyen", "Bon", "Excellent"),
  include.lowest = TRUE
)

# Histogramme
ggplot(resultats, aes(x = I_nemeton, fill = classe)) +
  geom_histogram(bins = 20, color = "white", alpha = 0.8) +
  scale_fill_manual(values = c(
    "Faible" = "#d73027",
    "Moyen" = "#fc8d59",
    "Bon" = "#91cf60",
    "Excellent" = "#1a9850"
  )) +
  labs(
    title = "Distribution de l'Indice Composite I_nemeton",
    x = "I_nemeton",
    y = "Nombre de parcelles",
    fill = "Classe"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

## Export des Résultats

### Sauvegarde Finale

```{r export-final-setup}
library(sf)
library(dplyr)

data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

indicateurs_par_famille <- list(
  C = c("C1", "C2"),
  B = c("B1", "B2", "B3"),
  W = c("W1", "W2", "W3"),
  A = c("A1", "A2"),
  F = c("F1", "F2"),
  L = c("L1", "L2", "L3"),
  T = c("T1", "T2"),
  R = c("R1", "R2", "R3", "R4"),
  S = c("S1", "S2", "S3"),
  P = c("P1", "P2", "P3"),
  E = c("E1", "E2"),
  N = c("N1", "N2", "N3")
)

normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)
  if (max_val == min_val) return(rep(0.5, length(x)))
  (x - min_val) / (max_val - min_val)
}

indicateurs_negatifs <- c("R1", "R2", "R3", "R4", "F1", "L1")

poids_familles <- c(
  C = 10, B = 12, W = 8, A = 6, F = 6, L = 5,
  T = 4, R = 10, S = 8, P = 8, E = 5, N = 8
)
```

```{r export-final, exercise=TRUE, exercise.lines=80, exercise.setup="export-final-setup"}
# ============================================================
# WORKFLOW COMPLET : Normalisation → Familles → I_nemeton → Export
# ============================================================

# Charger les données
parcelles <- st_read(file.path(data_dir, "parcelles.gpkg"), quiet = TRUE)

# 1. Normaliser tous les indicateurs
tous_indicateurs <- unlist(indicateurs_par_famille, use.names = FALSE)
indics_presents <- tous_indicateurs[tous_indicateurs %in% names(parcelles)]

for (indic in indics_presents) {
  parcelles[[paste0(indic, "_norm")]] <- normalize_minmax(parcelles[[indic]])
}

# 2. Inverser les indicateurs négatifs
for (indic in indicateurs_negatifs) {
  col_norm <- paste0(indic, "_norm")
  if (col_norm %in% names(parcelles)) {
    parcelles[[col_norm]] <- 1 - parcelles[[col_norm]]
  }
}

# 3. Calculer les moyennes par famille
for (famille in names(indicateurs_par_famille)) {
  cols_norm <- paste0(indicateurs_par_famille[[famille]], "_norm")
  cols_presentes <- cols_norm[cols_norm %in% names(parcelles)]
  if (length(cols_presentes) > 0) {
    parcelles[[paste0("family_", famille)]] <- rowMeans(
      st_drop_geometry(parcelles)[, cols_presentes, drop = FALSE],
      na.rm = TRUE
    )
  }
}

# 4. Calculer I_nemeton
poids_norm <- poids_familles / sum(poids_familles)
parcelles$I_nemeton <- 0
for (famille in names(poids_familles)) {
  col_famille <- paste0("family_", famille)
  if (col_famille %in% names(parcelles)) {
    contribution <- poids_norm[famille] * parcelles[[col_famille]]
    contribution[is.na(contribution)] <- 0
    parcelles$I_nemeton <- parcelles$I_nemeton + contribution
  }
}

# 5. Classifier
parcelles$classe_nemeton <- cut(
  parcelles$I_nemeton,
  breaks = c(0, 0.25, 0.5, 0.75, 1),
  labels = c("Faible", "Moyen", "Bon", "Excellent"),
  include.lowest = TRUE
)

# 6. Exporter
output_path <- file.path(data_dir, "parcelles.gpkg")
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)

cat("=== EXPORT TERMINÉ ===\n\n")
cat("Fichier:", output_path, "\n")
cat("Parcelles:", nrow(parcelles), "\n")
cat("Colonnes:", ncol(parcelles), "\n")

# Résumé final
cat("\n=== RÉSUMÉ I_NEMETON ===\n")
cat(sprintf("Min: %.3f | Max: %.3f | Moyenne: %.3f\n",
            min(parcelles$I_nemeton, na.rm = TRUE),
            max(parcelles$I_nemeton, na.rm = TRUE),
            mean(parcelles$I_nemeton, na.rm = TRUE)))

cat("\nDistribution par classe:\n")
print(table(parcelles$classe_nemeton))
```

## Quiz Final

```{r quiz-final, echo=FALSE}
quiz(
  caption = "Testez vos connaissances",

  question("Pourquoi normalise-t-on les indicateurs ?",
    answer("Pour réduire le temps de calcul"),
    answer("Pour rendre les indicateurs comparables entre eux", correct = TRUE),
    answer("Pour supprimer les valeurs manquantes"),
    answer("Pour augmenter la précision des données"),
    correct = "La normalisation ramène tous les indicateurs sur une échelle commune [0,1].",
    allow_retry = TRUE
  ),

  question("Quels indicateurs doivent être inversés après normalisation ?",
    answer("C1, C2 (carbone)"),
    answer("B1, B2, B3 (biodiversité)"),
    answer("R1, R2, R3, R4 (risques)", correct = TRUE),
    answer("P1, P2, P3 (production)"),
    correct = "Les risques sont inversés car une valeur élevée est défavorable.",
    allow_retry = TRUE
  ),

  question("Comment est calculé l'indice composite I_nemeton ?",
    answer("Somme simple de tous les indicateurs"),
    answer("Moyenne pondérée des moyennes par famille", correct = TRUE),
    answer("Maximum des indicateurs"),
    answer("Médiane de tous les indicateurs"),
    correct = "I_nemeton = somme(poids × moyenne_famille) pour les 12 familles.",
    allow_retry = TRUE
  ),

  question("Quelle famille a le poids le plus élevé par défaut ?",
    answer("Carbone (C) - 10%"),
    answer("Biodiversité (B) - 12%", correct = TRUE),
    answer("Risques (R) - 10%"),
    answer("Production (P) - 8%"),
    correct = "La biodiversité (12%) est la priorité dans les pondérations par défaut.",
    allow_retry = TRUE
  ),

  question("Quelle est la plage de valeurs de I_nemeton ?",
    answer("0 à 100"),
    answer("0 à 1", correct = TRUE),
    answer("-1 à 1"),
    answer("Pas de limite"),
    correct = "I_nemeton varie de 0 (faible) à 1 (excellent).",
    allow_retry = TRUE
  )
)
```

## Conclusion

### Récapitulatif

Dans ce tutoriel, vous avez appris à :

1. **Vérifier** la complétude des indicateurs dans `parcelles.gpkg`
2. **Normaliser** avec la méthode Min-Max (échelle 0-1)
3. **Inverser** les indicateurs négatifs (R1-R4, F1, L1)
4. **Calculer** les moyennes par famille (12 familles)
5. **Créer** l'indice composite pondéré I_nemeton
6. **Classifier** les parcelles en 4 niveaux

### Structure Finale des Données

```
parcelles.gpkg
├── Indicateurs bruts (C1, B1, W1, ...)
├── Indicateurs normalisés (*_norm)
├── Moyennes par famille (family_C, family_B, ...)
├── Indice composite (I_nemeton)
└── Classification (classe_nemeton)
```

### Prochaine Étape

**Tutorial 06 : Analyse Multi-Critères**
- Visualisation radar 12 axes
- Matrices de corrélation entre familles
- Identification des hotspots
- Front de Pareto et trade-offs
- Export cartographique interactif

```{r next-step, echo=FALSE}
cat("
Lancez le prochain tutoriel avec :
learnr::run_tutorial('06-analysis', package = 'nemeton')
")
```

### Ressources

- [Documentation nemeton](https://pobsteta.github.io/nemeton/)
- [Vignette : Référentiel complet](https://pobsteta.github.io/nemeton/articles/complete-referential_fr.html)
- [Vignette : Optimisation multicritères](https://pobsteta.github.io/nemeton/articles/multi-criteria-optimization_fr.html)

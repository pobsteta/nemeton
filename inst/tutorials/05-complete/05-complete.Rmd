---
title: "Tutorial 05 : Assemblage — Indice Composite I_nemeton"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Assemblage des 32 indicateurs, normalisation Min-Max, et calcul de
  l'indice composite pondéré I_nemeton.
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(sf)
library(terra)

knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
gradethis::gradethis_setup()

# Répertoire cache
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
```

## Introduction

### Objectifs du Tutorial

Bienvenue dans le **cinquième tutorial** de la série nemeton !

Dans les tutoriels précédents, vous avez calculé des indicateurs appartenant aux 12 familles :
- **T01** : Zone d'étude et données de base
- **T02** : Métriques LiDAR → C1, P1, P3, E1, E2, A1 (6 indicateurs)
- **T03** : Indicateurs terrain → W1-W3, R1-R4, S1-S3, P2, F1 (12 indicateurs)
- **T04** : Indicateurs écologiques → B1-B3, L1-L3, C2, T1-T2, A2, F2, N1-N3 (14 indicateurs)

Maintenant, vous allez :
1. **Assembler** tous les indicateurs dans un tableau unique
2. **Normaliser** les valeurs pour les rendre comparables
3. **Calculer l'indice composite** nemeton
4. **Analyser** la distribution des résultats

### Les 12 Familles d'Indicateurs

```{r familles-diagram, echo=FALSE}
familles <- data.frame(
  Code = c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N"),
  Famille = c(
    "Carbone", "Biodiversité", "Eau", "Air", "Sol", "Paysage",
    "Temporel", "Risques", "Social", "Production", "Énergie", "Naturalité"
  ),
  Nb_Indicateurs = c(3, 3, 3, 2, 2, 3, 2, 4, 3, 3, 2, 3),
  Source_Principale = c(
    "LiDAR", "INPN/LiDAR", "MNT", "LiDAR/BD Forêt",
    "MNT/Pédologie", "BD Forêt", "BD Forêt", "MNT",
    "BD TOPO", "LiDAR/BD Forêt", "LiDAR/BD Forêt", "Multi"
  )
)
knitr::kable(familles, caption = "Les 12 familles d'indicateurs nemeton")
```

## Chargement des Données

### Vérification des Prérequis

Avant de commencer, vérifions que toutes les données des tutoriaux précédents sont disponibles :

```{r verif-prerequis, exercise=TRUE, exercise.eval=FALSE, exercise.eval=FALSE}
# Répertoire de cache
cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")

# Fichiers attendus des tutoriaux précédents
fichiers_requis <- c(
  "parcelles.gpkg", # T01
  "metriques_lidar.gpkg", # T02
  "indicateurs_terrain.gpkg", # T03
  "indicateurs_ecologiques.gpkg" # T04
)

# Vérification
for (f in fichiers_requis) {
  chemin <- file.path(cache_dir, f)
  existe <- file.exists(chemin)
  cat(sprintf("%s : %s\n", f, ifelse(existe, "✓ OK", "✗ MANQUANT")))
}
```

### Chargement des Couches

```{r load-layers, exercise=TRUE, exercise.eval=FALSE, exercise.setup="verif-prerequis"}
# Charger toutes les couches d'indicateurs
parcelles <- st_read(file.path(cache_dir, "parcelles.gpkg"), quiet = TRUE)

# Métriques LiDAR (T02)
if (file.exists(file.path(cache_dir, "metriques_lidar.gpkg"))) {
  metriques_lidar <- st_read(file.path(cache_dir, "metriques_lidar.gpkg"), quiet = TRUE)
  cat("Métriques LiDAR:", ncol(metriques_lidar) - 1, "colonnes\n")
}

# Indicateurs Terrain (T03)
if (file.exists(file.path(cache_dir, "indicateurs_terrain.gpkg"))) {
  indic_terrain <- st_read(file.path(cache_dir, "indicateurs_terrain.gpkg"), quiet = TRUE)
  cat("Indicateurs Terrain:", ncol(indic_terrain) - 1, "colonnes\n")
}

# Indicateurs Écologiques (T04)
if (file.exists(file.path(cache_dir, "indicateurs_ecologiques.gpkg"))) {
  indic_eco <- st_read(file.path(cache_dir, "indicateurs_ecologiques.gpkg"), quiet = TRUE)
  cat("Indicateurs Écologiques:", ncol(indic_eco) - 1, "colonnes\n")
}

cat("\nTotal parcelles:", nrow(parcelles))
```

## Assemblage des Indicateurs

### Principe de la Jointure

Toutes les couches partagent l'identifiant unique **`idu`** (identifiant cadastral unique).
La jointure est donc simple : on fusionne les tables attributaires sur cette clé commune.

```{r jointure-concept, echo=FALSE}
cat("
Parcelles (base) — clé: idu
     │
     ├── + Métriques LiDAR (T02) → C1, P1, P3, E1, E2, A1
     │
     ├── + Indicateurs Terrain (T03) → W1-3, R1-4, S1-3, P2, F1
     │
     └── + Indicateurs Écologiques (T04) → B1-3, L1-3, C2, T1-2, A2, F2, N1-3

     TOTAL: 6 + 12 + 14 = 32 indicateurs
")
```

### Exercice : Assembler les Indicateurs

Fusionnez toutes les couches d'indicateurs en utilisant **`idu`** comme clé de jointure :

```{r assemble-indicators-setup}
library(sf)

# Répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  cache_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  cache_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}

# Fonction pour trouver ou créer la colonne ID
ensure_id_column <- function(df, id_name = "idu") {
  # Chercher une colonne ID existante
  id_candidates <- c("idu", "IDU", "id", "ID", "fid", "FID", "OBJECTID", "id_parcelle")
  found_id <- intersect(id_candidates, names(df))


  if (length(found_id) > 0) {
    # Renommer la première colonne trouvée en 'idu'
    if (found_id[1] != id_name) {
      df[[id_name]] <- df[[found_id[1]]]
    }
  } else {
    # Créer un ID basé sur le numéro de ligne
    df[[id_name]] <- seq_len(nrow(df))
  }
  return(df)
}

# Charger et préparer les données
parcelles <- st_read(file.path(cache_dir, "parcelles.gpkg"), quiet = TRUE)
parcelles <- ensure_id_column(parcelles)

metriques_lidar <- st_read(file.path(cache_dir, "metriques_lidar.gpkg"), quiet = TRUE)
metriques_lidar <- ensure_id_column(metriques_lidar)

indic_terrain <- st_read(file.path(cache_dir, "indicateurs_terrain.gpkg"), quiet = TRUE)
indic_terrain <- ensure_id_column(indic_terrain)

indic_eco <- st_read(file.path(cache_dir, "indicateurs_ecologiques.gpkg"), quiet = TRUE)
indic_eco <- ensure_id_column(indic_eco)
```

```{r assemble-indicators, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.timelimit=300, exercise.setup="assemble-indicators-setup"}
# ============================================================
# ASSEMBLAGE DES 32 INDICATEURS NEMETON
# Clé de jointure : idu
# ============================================================

# 1. Partir des parcelles (géométrie de base)
indicateurs <- parcelles
cat("Parcelles:", nrow(indicateurs), "\n")

# 2. Joindre les métriques LiDAR (T02) → C1, P1, P3, E1, A1
cols_lidar <- c("idu", "C1", "P1", "P3", "E1", "A1")
cols_present <- intersect(cols_lidar, names(metriques_lidar))
if ("idu" %in% cols_present && length(cols_present) > 1) {
  lidar_data <- st_drop_geometry(metriques_lidar)[, cols_present, drop = FALSE]
  indicateurs <- merge(indicateurs, lidar_data, by = "idu", all.x = TRUE)
  cat("✓ LiDAR:", length(cols_present) - 1, "indicateurs\n")
}

# 3. Joindre les indicateurs terrain (T03)
cols_terrain <- c("idu", "W1", "W2", "W3", "R1", "R2", "R3", "R4", "S1", "S2", "S3", "P2", "F1")
cols_present <- intersect(cols_terrain, names(indic_terrain))
if ("idu" %in% cols_present && length(cols_present) > 1) {
  terrain_data <- st_drop_geometry(indic_terrain)[, cols_present, drop = FALSE]
  indicateurs <- merge(indicateurs, terrain_data, by = "idu", all.x = TRUE)
  cat("✓ Terrain:", length(cols_present) - 1, "indicateurs\n")
}

# 4. Joindre les indicateurs écologiques (T04)
cols_eco <- c("idu", "B1", "B2", "B3", "L1", "L2", "L3", "C2", "T1", "T2", "A2", "F2", "N1", "N2", "N3")
cols_present <- intersect(cols_eco, names(indic_eco))
if ("idu" %in% cols_present && length(cols_present) > 1) {
  eco_data <- st_drop_geometry(indic_eco)[, cols_present, drop = FALSE]
  indicateurs <- merge(indicateurs, eco_data, by = "idu", all.x = TRUE)
  cat("✓ Écologique:", length(cols_present) - 1, "indicateurs\n")
}

# ============================================================
# BILAN
# ============================================================
indicateurs_attendus <- c(
  "C1", "P1", "P3", "E1", "E2", "A1",
  "W1", "W2", "W3", "R1", "R2", "R3", "R4",
  "S1", "S2", "S3", "P2", "F1",
  "B1", "B2", "B3", "L1", "L2", "L3", "C2",
  "T1", "T2", "A2", "F2", "N1", "N2", "N3"
)
presents <- sum(indicateurs_attendus %in% names(indicateurs))

cat("\n=== BILAN ===\n")
cat("Colonnes:", ncol(indicateurs), "\n")
cat("Indicateurs:", presents, "/ 32\n")
```



## Normalisation des Indicateurs

### Pourquoi Normaliser ?

Les indicateurs ont des unités et échelles très différentes :
- Hauteur maximale (zmax) : 0-50 mètres
- TWI (W1) : 2-20 sans unité
- Distance routes (S1) : 0-5000 mètres
- Zones protégées (B1) : 0-1 (booléen ou proportion)

Pour les **comparer** et les **agréger**, il faut les ramener sur une échelle commune.

### Méthodes de Normalisation

```{r normalisation-methods, echo=FALSE}
methods <- data.frame(
  Méthode = c("Min-Max", "Z-score", "Rang percentile", "Bornes fixes"),
  Formule = c("(x - min) / (max - min)", "(x - μ) / σ", "rang(x) / n", "(x - borne_inf) / (borne_sup - borne_inf)"),
  Résultat = c("[0, 1]", "[-∞, +∞]", "[0, 1]", "[0, 1] (clippé)"),
  Usage = c("Défaut nemeton", "Comparaison statistique", "Robuste aux outliers", "Seuils experts")
)
knitr::kable(methods, caption = "Méthodes de normalisation")
```

### Normalisation Min-Max

La méthode **Min-Max** est la plus courante. Elle transforme chaque valeur selon :

$$x_{norm} = \frac{x - x_{min}}{x_{max} - x_{min}}$$

```{r minmax-function, exercise=TRUE, exercise.eval=FALSE, exercise.eval=FALSE}
# Fonction de normalisation Min-Max
normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)

  if (max_val == min_val) {
    return(rep(0.5, length(x))) # Valeur constante
  }

  (x - min_val) / (max_val - min_val)
}

# Test
valeurs <- c(10, 20, 30, 40, 50)
normalize_minmax(valeurs)
```

### Exercice : Normaliser les Indicateurs

Appliquez la normalisation Min-Max à tous les indicateurs numériques :

```{r normalize-all, exercise=TRUE, exercise.eval=FALSE, exercise.lines=20}
# Fonction de normalisation
normalize_minmax <- function(x, na.rm = TRUE) {
  min_val <- min(x, na.rm = na.rm)
  max_val <- max(x, na.rm = na.rm)
  if (max_val == min_val) {
    return(rep(0.5, length(x)))
  }
  (x - min_val) / (max_val - min_val)
}

# Simuler des données pour l'exercice
set.seed(42)
n <- 50
indicateurs <- data.frame(
  id_parcelle = 1:n,
  zmax = runif(n, 5, 45),
  W1 = runif(n, 3, 18),
  S1 = runif(n, 50, 3000),
  B1 = rbinom(n, 1, 0.3)
)

# À compléter : normaliser toutes les colonnes numériques sauf id_parcelle
# Créer un nouveau data.frame 'indicateurs_norm'
```



### Inversion des Indicateurs Négatifs

Certains indicateurs ont une logique **inverse** : une valeur élevée est défavorable.

| Indicateur | Logique | Action |
|------------|---------|--------|
| R1 (risque feu) | Élevé = mauvais | Inverser : 1 - x_norm |
| S1 (distance routes) | Élevé = bon (tranquillité) | Conserver |
| N2 (distance infrastructures) | Élevé = bon | Conserver |
| F1 (risque érosion) | Élevé = mauvais | Inverser |

```{r inversion, exercise=TRUE, exercise.eval=FALSE, exercise.eval=FALSE}
# Indicateurs à inverser (valeur élevée = défavorable)
indicateurs_negatifs <- c("R1", "R2", "R3", "R4", "F1", "L1") # L1 = fragmentation, R4 = pression gibier

# Fonction d'inversion
inverser_indicateur <- function(x_norm) {
  1 - x_norm
}

# Exemple
risque_feu_norm <- c(0.2, 0.5, 0.8) # Normalisé
risque_feu_inv <- inverser_indicateur(risque_feu_norm)

cat("Original (normalisé):", risque_feu_norm, "\n")
cat("Inversé:", risque_feu_inv, "\n")
cat("Interprétation: fort risque (0.8) devient score faible (0.2)")
```

## Calcul de l'Indice Composite

### Pondération des Familles

L'indice composite nemeton agrège les 12 familles avec des pondérations reflétant les priorités de gestion :

```{r ponderations, echo=FALSE}
poids <- data.frame(
  Famille = c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N"),
  Nom = c(
    "Carbone", "Biodiversité", "Eau", "Air", "Sol", "Paysage",
    "Temporel", "Risques", "Social", "Production", "Énergie", "Naturalité"
  ),
  Poids_Default = c(10, 12, 8, 6, 6, 5, 4, 10, 8, 8, 5, 8),
  stringsAsFactors = FALSE
)
poids$Poids_Relatif <- round(poids$Poids_Default / sum(poids$Poids_Default) * 100, 1)
knitr::kable(poids, caption = "Pondérations par défaut des familles nemeton")
```

### Formule de l'Indice Composite

$$I_{nemeton} = \sum_{f=1}^{12} w_f \cdot \bar{I}_f$$

Où :
- $w_f$ : poids normalisé de la famille f
- $\bar{I}_f$ : moyenne des indicateurs normalisés de la famille f

### Exercice : Calculer l'Indice Composite

```{r composite-index, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35}
# Simuler des indicateurs normalisés pour l'exercice
set.seed(42)
n <- 30

indic_norm <- data.frame(
  id = 1:n,
  # Carbone (C)
  C1 = runif(n), C2 = runif(n), C3 = runif(n),
  # Biodiversité (B)
  B1 = runif(n), B2 = runif(n), B3 = runif(n),
  # Eau (W)
  W1 = runif(n), W2 = runif(n), W3 = runif(n),
  # Risques (R) - déjà inversés
  R1 = runif(n), R2 = runif(n), R3 = runif(n), R4 = runif(n)
)

# Poids des familles (sous-ensemble)
poids <- c(C = 0.15, B = 0.18, W = 0.12, R = 0.15)

# À compléter : calculer l'indice composite
# 1. Calculer la moyenne par famille pour chaque parcelle
# 2. Appliquer les poids
# 3. Sommer pour obtenir l'indice final
```



## Utilisation de nemeton

### Fonction create_composite_index()

Le package nemeton fournit une fonction dédiée :

```{r nemeton-composite, eval=FALSE}
library(nemeton)

# Créer l'indice composite avec pondérations par défaut
resultat <- create_composite_index(
  data = indicateurs_sf,
  weights = NULL, # Utilise les poids par défaut
  normalize = TRUE,
  invert_negative = TRUE
)

# Avec pondérations personnalisées
poids_perso <- list(
  C = 15, B = 20, W = 10, A = 5, F = 5, L = 5,
  T = 5, R = 10, S = 5, P = 10, E = 5, N = 5
)

resultat_perso <- create_composite_index(
  data = indicateurs_sf,
  weights = poids_perso
)
```

### Exercice : Intégration nemeton

```{r nemeton-integration, exercise=TRUE, exercise.eval=FALSE, exercise.lines=20}
# Simulation de la fonction nemeton
# (Dans la vraie vie, utiliser library(nemeton))

create_composite_index_demo <- function(data, weights = NULL) {
  # Poids par défaut
  if (is.null(weights)) {
    weights <- list(C = 10, B = 12, W = 8, R = 10)
  }

  # Normaliser les poids
  total <- sum(unlist(weights))
  weights_norm <- lapply(weights, function(x) x / total)

  # Calculer (simplifié)
  data$I_nemeton <- runif(nrow(data)) # Simulation
  return(data)
}

# Test avec vos données
test_data <- data.frame(
  id = 1:10,
  C1 = runif(10), B1 = runif(10), W1 = runif(10), R1 = runif(10)
)

resultat <- create_composite_index_demo(test_data)
head(resultat)
```

## Export des Résultats

### Sauvegarde du Tableau Complet

```{r export-gpkg, exercise=TRUE, exercise.eval=FALSE, exercise.eval=FALSE}
# Préparer les données finales
# (En situation réelle avec les vraies données)

# Simuler le résultat final
set.seed(42)
n <- 30
resultat_final <- data.frame(
  id_parcelle = 1:n,
  surface_ha = runif(n, 0.5, 10),
  I_nemeton = runif(n, 0.3, 0.8),
  classe = cut(runif(n, 0.3, 0.8),
    breaks = c(0, 0.4, 0.6, 0.8, 1),
    labels = c("Faible", "Moyen", "Bon", "Excellent")
  )
)

# Afficher le résumé
cat("Résumé de l'indice nemeton:\n")
summary(resultat_final$I_nemeton)

cat("\nDistribution par classe:\n")
table(resultat_final$classe)
```

### Export vers GeoPackage

```{r export-final, exercise=TRUE, exercise.eval=FALSE, exercise.setup="export-gpkg"}
# Code d'export (non exécuté dans le tutorial)
#
# # Convertir en sf si nécessaire
# resultat_sf <- st_as_sf(resultat_final,
#                         geometry = geometries,
#                         crs = 2154)
#
# # Exporter
# output_path <- file.path(cache_dir, "indicateurs_complets.gpkg")
# st_write(resultat_sf, output_path, delete_dsn = TRUE)
#
# cat("Export réussi:", output_path)

cat("Le fichier serait exporté vers:\n")
cat(file.path(cache_dir, "indicateurs_complets.gpkg"))
```

## Quiz Final

```{r quiz-final, echo=FALSE}
quiz(
  caption = "Testez vos connaissances",
  question("Pourquoi normalise-t-on les indicateurs ?",
    answer("Pour réduire le temps de calcul"),
    answer("Pour rendre les indicateurs comparables entre eux", correct = TRUE),
    answer("Pour supprimer les valeurs manquantes"),
    answer("Pour augmenter la précision des données"),
    correct = "Exact ! La normalisation ramène tous les indicateurs sur une échelle commune [0,1].",
    incorrect = "La normalisation sert à comparer des indicateurs ayant des unités différentes.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Quel indicateur doit être inversé après normalisation ?",
    answer("zmax (hauteur maximale)"),
    answer("B1 (zones protégées)"),
    answer("R1 (risque feu)", correct = TRUE),
    answer("W1 (indice humidité)"),
    correct = "Oui ! Un risque élevé est défavorable, donc on inverse pour que 0 = risque fort.",
    incorrect = "On inverse les indicateurs où une valeur élevée est défavorable.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Comment est calculé l'indice composite nemeton ?",
    answer("Somme simple de tous les indicateurs"),
    answer("Moyenne pondérée des moyennes par famille", correct = TRUE),
    answer("Maximum des indicateurs"),
    answer("Produit de tous les indicateurs"),
    correct = "L'indice agrège les 12 familles avec des pondérations reflétant les priorités.",
    incorrect = "L'indice utilise une moyenne pondérée par famille.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  question("Quelle famille a le poids le plus élevé par défaut ?",
    answer("Carbone (C)"),
    answer("Biodiversité (B)", correct = TRUE),
    answer("Production (P)"),
    answer("Énergie (E)"),
    correct = "La biodiversité (12%) est prioritaire dans les pondérations par défaut.",
    incorrect = "Consultez le tableau des pondérations - la biodiversité a le poids le plus fort.",
    allow_retry = TRUE,
    random_answer_order = TRUE
  )
)
```

## Conclusion

### Récapitulatif

Dans ce tutoriel, vous avez appris à :

1. ✅ **Assembler** les indicateurs de plusieurs sources
2. ✅ **Normaliser** avec la méthode Min-Max
3. ✅ **Inverser** les indicateurs négatifs
4. ✅ **Calculer** l'indice composite pondéré
5. ✅ **Exporter** les résultats en GeoPackage

### Données Produites

```
~/nemeton_tutorial_data/
└── indicateurs_complets.gpkg
    ├── Tous les indicateurs normalisés (*_norm)
    ├── Moyennes par famille (moy_C, moy_B, ...)
    ├── Indice composite (I_nemeton)
    └── Classification (classe)
```

### Prochaine Étape

**Tutorial 06 : Analyse Multi-Critères et Export**
- Identification des parcelles prioritaires
- Analyse de sensibilité des pondérations
- Export cartographique et rapports

```{r next-step, echo=FALSE}
cat("
Lancez le prochain tutoriel avec :
learnr::run_tutorial('06-analysis', package = 'nemeton')
")
```

### Ressources

- [Documentation nemeton](https://forestsoils.github.io/nemeton/)
- [Vignette : Indice composite](https://forestsoils.github.io/nemeton/articles/composite-index.html)
- [Référentiel des 12 familles](https://forestsoils.github.io/nemeton/articles/complete-referential_fr.html)

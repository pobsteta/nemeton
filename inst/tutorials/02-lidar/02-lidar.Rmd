---
title: "Tutorial 02 : LiDAR — Familles C, P, E, A (9 indicateurs)"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Traitement LiDAR HD et calcul de 9 indicateurs : C1 (stock carbone),
  C2 (vitalité NDVI), P1 (volume bois), P2 (productivité), P3 (qualité structurale),
  A1 (couverture forestière), A2 (qualité air), E1/E2 (énergie).
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)

# Configuration gradethis
gradethis::gradethis_setup()

# Options
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)

# Timeout pour les exercices LiDAR (10 min)
options(tutorial.exercise.timelimit = 600)

# Configuration des timeouts réseau (5 minutes)
NETWORK_TIMEOUT <- 300
options(
  timeout = NETWORK_TIMEOUT,
  HTTPUserAgent = "nemeton-tutorial/1.0"
)

# Configuration httr (connect + request timeout)
if (requireNamespace("httr", quietly = TRUE)) {
  httr::set_config(httr::config(
    connecttimeout = NETWORK_TIMEOUT,
    timeout = NETWORK_TIMEOUT
  ))
}

# Configuration GDAL/curl pour happign
Sys.setenv(
  GDAL_HTTP_TIMEOUT = as.character(NETWORK_TIMEOUT),
  GDAL_HTTP_CONNECTTIMEOUT = as.character(NETWORK_TIMEOUT),
  CURL_SSL_BACKEND = "openssl"
)
```

## Bienvenue

### Objectifs du tutoriel

Ce tutoriel vous guide dans le **traitement des données LiDAR** pour extraire des métriques forestières utilisables dans le calcul des indicateurs nemeton.

À la fin de ce tutoriel, vous saurez :

1. **Charger un nuage de points LiDAR** avec lidR
2. **Comprendre la classification** des points (sol, végétation)
3. **Normaliser les hauteurs** par rapport au MNT
4. **Générer un MNH** (Modèle Numérique de Hauteur)
5. **Calculer des métriques** dendrométriques par parcelle
6. **Exporter les résultats** en GeoPackage

### Prérequis

Ce tutoriel nécessite les données acquises dans le **Tutorial 01** :

- `mnt.tif` : Modèle Numérique de Terrain
- `parcelles.gpkg` : Parcelles cadastrales
- `lidar_hd/` : Dalles LiDAR HD téléchargées

### Packages utilisés

```{r packages-info, echo=FALSE}
cat("Packages requis pour ce tutoriel:\n")
cat("- lidR >= 4.0.0 : Traitement nuages de points LiDAR\n")
cat("- terra : Manipulation rasters\n")
cat("- sf : Données vectorielles\n")
cat("- exactextractr : Extraction par polygone\n")
```

### Quiz d'introduction

```{r quiz-intro, echo=FALSE}
question("Qu'est-ce que le LiDAR ?",
  answer("Un capteur radar pour la pluie"),
  answer("Light Detection And Ranging - mesure de distance par laser", correct = TRUE),
  answer("Un format de fichier image"),
  answer("Un logiciel de cartographie"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

```{r quiz-intro-2, echo=FALSE}
question("Que mesure principalement le LiDAR aéroporté en foresterie ?",
  answer("La température des arbres"),
  answer("La hauteur et la structure verticale de la végétation", correct = TRUE),
  answer("L'humidité du sol"),
  answer("La couleur des feuilles"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

```{r quiz-intro-3, echo=FALSE}
question("Qu'est-ce que la normalisation des hauteurs LiDAR ?",
  answer("Convertir les coordonnées en mètres"),
  answer("Soustraire l'altitude du terrain pour obtenir la hauteur au-dessus du sol", correct = TRUE),
  answer("Diviser toutes les hauteurs par 100"),
  answer("Supprimer les points aberrants"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

---

## Section 1 : Introduction au LiDAR

### Principes du LiDAR

Le **LiDAR** (Light Detection And Ranging) est une technologie de télédétection active qui mesure la distance entre un capteur et une surface en émettant des impulsions laser.

**Caractéristiques du LiDAR HD IGN** :
- Densité : **10+ points/m²**
- Précision altimétrique : **< 20 cm**
- Classification automatique : sol, végétation basse, moyenne, haute
- Format : **LAZ** (compressé) ou **COPC** (Cloud Optimized Point Cloud)

### Classification des points

Chaque point LiDAR est classifié selon la norme ASPRS :

| Code | Classe | Description |
|------|--------|-------------|
| 2 | Ground | Sol nu |
| 3 | Low vegetation | Végétation < 0.5m |
| 4 | Medium vegetation | Végétation 0.5-2m |
| 5 | High vegetation | Végétation > 2m |
| 6 | Building | Bâtiments |

### Métriques forestières dérivées

À partir du nuage de points, nous pouvons extraire :

| Métrique | Description | Usage |
|----------|-------------|-------|
| **zmax** | Hauteur maximale | Volume, biomasse |
| **zmean** | Hauteur moyenne | Structure |
| **zsd** | Écart-type des hauteurs | Diversité structurale |
| **zq95** | Percentile 95 | Hauteur dominante |
| **pzabove2** | % points > 2m | Couverture canopée |
| **zentropy** | Entropie verticale | Complexité structurale |

---

## Section 2 : Chargement du nuage de points

### Exercice 2.1 : Charger une dalle LiDAR

Chargeons une dalle LiDAR depuis le cache du Tutorial 01.

```{r ex-2-1-setup}
library(sf)
library(terra)
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-2-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=25, exercise.setup="ex-2-1-setup"}
# === CHARGEMENT D'UNE DALLE LIDAR ===

# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}

# Vérifier si lidR est disponible
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  # Lister les fichiers LiDAR disponibles
  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )

  cat("Fichiers LiDAR disponibles:", length(fichiers_laz), "\n")

  if (length(fichiers_laz) > 0) {
    # Charger le premier fichier
    las <- readLAS(fichiers_laz[1])
    cat("\n=== Informations sur le nuage de points ===\n")
    print(las)
  }
} else {
  cat("Package lidR non installé.\n")
  cat("Installation: install.packages('lidR')\n")
}
```


### Exercice 2.2 : Explorer la structure du nuage

```{r ex-2-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-2-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-2-2-setup"}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )

  if (length(fichiers_laz) > 0) {
    # Charger avec filtre pour réduire la mémoire
    las <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    cat("=== Structure du nuage de points ===\n\n")
    cat("Nombre de points:", nrow(las@data), "\n")
    cat("Attributs disponibles:", paste(names(las@data), collapse = ", "), "\n\n")

    # Statistiques par classification
    cat("=== Distribution par classe ===\n")
    table_class <- table(las@data$Classification)
    print(table_class)

    cat("\n=== Statistiques d'altitude (Z) ===\n")
    cat("Min:", min(las@data$Z), "m\n")
    cat("Max:", max(las@data$Z), "m\n")
    cat("Moyenne:", round(mean(las@data$Z), 1), "m\n")
  }
} else {
  cat("Démonstration avec données simulées:\n")
  cat("Points typiques: 500,000 - 5,000,000 par dalle\n")
  cat("Classes: 2 (sol), 3-5 (végétation), 6 (bâtiments)\n")
}
```

---

## Section 3 : Normalisation des hauteurs

### Pourquoi normaliser ?

Les coordonnées Z brutes du LiDAR sont des **altitudes absolues** (m au-dessus du niveau de la mer). Pour obtenir la **hauteur des arbres**, il faut soustraire l'altitude du terrain.

```
Hauteur arbre = Z_lidar - Z_mnt
```

### Exercice 3.1 : Normaliser avec le MNT

```{r ex-3-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-3-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-3-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")
    cat("Nuage complet:", nrow(las_full@data), "points\n")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    # Pour accélérer le traitement dans ce tutoriel
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    # Clipper sur 20x20m centré
    las <- clip_rectangle(las_full,
      xleft = center_x - 10,
      ybottom = center_y - 10,
      xright = center_x + 10,
      ytop = center_y + 10
    )

    cat("Après clip 20x20m:", nrow(las@data), "points\n\n")

    # Charger le MNT
    mnt <- rast(mnt_path)

    cat("=== Avant normalisation ===\n")
    cat("Z min:", round(min(las@data$Z), 1), "m\n")
    cat("Z max:", round(max(las@data$Z), 1), "m\n")

    # Normalisation (rapide sur 20x20m)
    las_norm <- normalize_height(las, mnt)

    cat("\n=== Après normalisation ===\n")
    cat("Z min:", round(min(las_norm@data$Z), 1), "m\n")
    cat("Z max:", round(max(las_norm@data$Z), 1), "m\n")

    # Filtrer les points négatifs (sous le sol)
    las_clean <- filter_poi(las_norm, Z >= 0)
    cat("\nPoints après filtrage Z >= 0:", nrow(las_clean@data), "\n")
  } else {
    cat("Fichiers non trouvés. Exécutez d'abord le Tutorial 01.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 4 : Génération du MNH

### Modèle Numérique de Hauteur (MNH)

Le **MNH** (ou CHM - Canopy Height Model) est un raster représentant la hauteur de la canopée en chaque pixel.

### Exercice 4.1 : Créer le MNH

```{r ex-4-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-4-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-4-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    las <- clip_rectangle(las_full,
      xleft = center_x - 10,
      ybottom = center_y - 10,
      xright = center_x + 10,
      ytop = center_y + 10
    )

    cat("Zone 20x20m:", nrow(las@data), "points\n")

    # Normaliser
    mnt <- rast(mnt_path)
    las_norm <- normalize_height(las, mnt)
    las_clean <- filter_poi(las_norm, Z >= 0 & Z < 60)

    # Générer le MNH (résolution 1m)
    cat("\n=== Génération du MNH ===\n")
    mnh <- rasterize_canopy(las_clean, res = 1, algorithm = p2r())

    cat("Dimensions:", nrow(mnh), "x", ncol(mnh), "pixels\n")
    cat("Résolution:", res(mnh)[1], "m\n")

    # Statistiques
    stats <- global(mnh, c("min", "max", "mean", "sd"), na.rm = TRUE)
    cat("\n=== Statistiques MNH ===\n")
    cat("Hauteur min:", round(stats$min, 1), "m\n")
    cat("Hauteur max:", round(stats$max, 1), "m\n")
    cat("Hauteur moyenne:", round(stats$mean, 1), "m\n")

    # Sauvegarder (exemple sur zone réduite)
    mnh_path <- file.path(data_dir, "mnh_sample.tif")
    writeRaster(mnh, mnh_path, overwrite = TRUE)
    cat("\nMNH échantillon sauvegardé:", mnh_path, "\n")
  } else {
    cat("Fichiers non trouvés.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 5 : Métriques par parcelle

### Exercice 5.1 : Calculer les métriques LiDAR

```{r ex-5-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-5-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-5-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    las <- clip_rectangle(las_full,
      xleft = center_x - 10,
      ybottom = center_y - 10,
      xright = center_x + 10,
      ytop = center_y + 10
    )

    cat("Zone 20x20m:", nrow(las@data), "points\n")

    # Normaliser
    mnt <- rast(mnt_path)
    las_norm <- normalize_height(las, mnt)
    las_clean <- filter_poi(las_norm, Z >= 0 & Z < 60)

    # Calculer par pixel (raster 2m pour zone 20x20m)
    # Utiliser une fonction anonyme inline pour éviter les problèmes de scope
    cat("\n=== Calcul des métriques raster ===\n")
    metrics_raster <- pixel_metrics(las_clean, ~ list(
      zmax = max(Z, na.rm = TRUE),
      zmean = mean(Z, na.rm = TRUE),
      zsd = sd(Z, na.rm = TRUE),
      zq95 = quantile(Z, 0.95, na.rm = TRUE),
      pzabove2 = sum(Z > 2, na.rm = TRUE) / length(Z) * 100
    ), res = 2)

    cat("Couches générées:", names(metrics_raster), "\n")
    cat("Dimensions:", nrow(metrics_raster), "x", ncol(metrics_raster), "pixels\n")

    # Statistiques globales sur la zone
    cat("\n=== Statistiques sur la zone 20x20m ===\n")
    cat("Hauteur max (zmax):", round(max(values(metrics_raster$zmax), na.rm = TRUE), 1), "m\n")
    cat("Hauteur moyenne (zmean):", round(mean(values(metrics_raster$zmean), na.rm = TRUE), 1), "m\n")
    cat("Percentile 95 (zq95):", round(mean(values(metrics_raster$zq95), na.rm = TRUE), 1), "m\n")
    cat("Couverture > 2m:", round(mean(values(metrics_raster$pzabove2), na.rm = TRUE), 1), "%\n")
  } else {
    cat("Fichiers non trouvés.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 6 : Export des métriques LiDAR

### Exercice 6.1 : Sauvegarder les métriques

Dans ce tutoriel, nous utilisons les **métriques LiDAR pré-calculées** du jeu de données `quatre_montagnes` (package `lidaRtRee`). Ces 28 placettes contiennent des valeurs réelles de zmean, zmax, zsd, etc.

Pour estimer les métriques sur les parcelles cadastrales, nous appliquons un **krigeage** (interpolation spatiale) à partir des placettes. Cette méthode permet d'obtenir des estimations cohérentes spatialement.

> **Note** : Le calcul direct des métriques LiDAR à partir des nuages de points sera traité dans un tutoriel avancé dédié au traitement LiDAR complet.

```{r ex-6-1-setup}
library(sf)
library(terra)
library(lidaRtRee)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=85, exercise.setup="ex-6-1-setup"}
# === INTERPOLATION DES MÉTRIQUES LIDAR PAR KRIGEAGE ===
# Utilisation des données réelles de quatre_montagnes (lidaRtRee)

# Charger les placettes avec métriques LiDAR
data("quatre_montagnes", package = "lidaRtRee")

# Filtrer sur les clusters Centre (même zone que Tutorial 01)
clusters_centre <- c(
  "Verc-C1", "Verc-S4", "Verc-02", "Verc-S7",
  "Verc-C4", "Verc-C2", "Verc-05"
)
qm_centre <- quatre_montagnes[quatre_montagnes$cluster_id %in% clusters_centre, ]

# Convertir en sf
placettes_sf <- st_as_sf(qm_centre, coords = c("X", "Y"), crs = 2154)

cat("=== Données source : quatre_montagnes ===\n")
cat("Placettes avec métriques LiDAR:", nrow(placettes_sf), "\n\n")

# Métriques LiDAR à interpoler
metriques <- c(
  "zmax", "zmean", "zsd", "zq25", "zq50", "zq75", "zq95",
  "zentropy", "pzabove2"
)

cat("Métriques disponibles:\n")
for (m in metriques) {
  if (m %in% names(placettes_sf)) {
    vals <- qm_centre[[m]]
    cat(sprintf(
      "  %s: %.1f - %.1f (moy: %.1f)\n",
      m, min(vals, na.rm = TRUE), mean(vals, na.rm = TRUE), max(vals, na.rm = TRUE)
    ))
  }
}

# Charger les parcelles cadastrales
parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  # Calculer les centroïdes des parcelles
  centroids <- st_centroid(parcelles)

  cat("\n=== Interpolation par IDW (Inverse Distance Weighting) ===\n")
  cat("Parcelles cibles:", nrow(parcelles), "\n\n")

  # Fonction d'interpolation IDW simple
  idw_interpolate <- function(points_sf, target_sf, variable, power = 2) {
    # Extraire coordonnées
    coords_src <- st_coordinates(points_sf)
    coords_tgt <- st_coordinates(target_sf)
    values <- points_sf[[variable]]

    # Pour chaque point cible
    result <- sapply(seq_len(nrow(coords_tgt)), function(i) {
      # Distances aux points source
      distances <- sqrt((coords_src[, 1] - coords_tgt[i, 1])^2 +
        (coords_src[, 2] - coords_tgt[i, 2])^2)
      # Éviter division par zéro
      distances[distances < 1] <- 1
      # Poids IDW
      weights <- 1 / (distances^power)
      # Moyenne pondérée
      sum(values * weights, na.rm = TRUE) / sum(weights, na.rm = TRUE)
    })
    return(result)
  }

  # Interpoler chaque métrique
  cat("Interpolation en cours...\n")
  for (m in metriques) {
    if (m %in% names(placettes_sf)) {
      parcelles[[m]] <- idw_interpolate(placettes_sf, centroids, m)
      cat(sprintf("  %s interpolé\n", m))
    }
  }

  # Sauvegarder
  output_path <- file.path(data_dir, "metriques_lidar.gpkg")
  st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
  st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
  cat("\n=== Métriques LiDAR exportées ===\n")
  cat("Fichier:", output_path, "\n")
  cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")

  # Résumé des métriques interpolées
  cat("=== Résumé des métriques interpolées ===\n")
  cat("Métrique       Min      Moy      Max\n")
  cat("--------------------------------------\n")
  for (m in metriques) {
    if (m %in% names(parcelles)) {
      cat(sprintf(
        "%-12s %7.1f %8.1f %8.1f\n",
        m, min(parcelles[[m]], na.rm = TRUE),
        mean(parcelles[[m]], na.rm = TRUE),
        max(parcelles[[m]], na.rm = TRUE)
      ))
    }
  }
} else {
  cat("Parcelles non trouvées. Exécutez le Tutorial 01.\n")
}
```


---

## Section 7 : Indicateurs Carbone, Production et Air (C1, P1, P2, P3, A1)

### Introduction aux familles C, P, A

Les métriques LiDAR permettent de calculer directement plusieurs indicateurs du référentiel nemeton :

- **C1** (Carbone) : Stock de biomasse aérienne (tC/ha)
- **P1** (Production) : Volume de bois sur pied (m³/ha)
- **P2** (Production) : Productivité forestière (m³/ha/an)
- **P3** (Production) : Qualité structurale du peuplement (score 0-100)
- **A1** (Air) : Couverture forestière et interception (%)

```{r indicateurs-cpa-concept, echo=FALSE}
indics_cpa <- data.frame(
  Indicateur = c("C1", "P1", "P2", "P3", "A1"),
  Nom = c("Stock carbone biomasse", "Volume bois sur pied", "Productivité forestière", "Qualité structurale", "Couverture forestière"),
  Unite = c("tC/ha", "m³/ha", "m³/ha/an", "score 0-100", "%"),
  Source = c("zmean, zmax, pzabove2", "zmean, zmax, pzabove2", "zmean, pzabove2, zq95, zq25", "zentropy, zsd", "pzabove2")
)
knitr::kable(indics_cpa, caption = "Indicateurs dérivés des métriques LiDAR")
```

### Exercice 7.1 : Calculer C1 (Stock carbone)

L'indicateur **C1** estime le stock de carbone aérien à partir de la biomasse forestière :

$$C1 = AGB \times 0.47$$

Où AGB (Above Ground Biomass) est estimée par une équation allométrique simplifiée :

$$AGB = k \times (pzabove2/100) \times zmean^{1.5}$$

```{r ex-7-1-c1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-1-c1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-7-1-c1-setup"}
# === CALCUL DE C1 : STOCK CARBONE BIOMASSE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de C1 (Stock carbone) ===\n\n")

  if (all(c("pzabove2", "zmean") %in% names(parcelles))) {
    # Paramètres du modèle allométrique simplifié
    k_biomasse <- 2.5  # Facteur de calibration (t/ha)
    fraction_carbone <- 0.47  # Fraction carbone dans la biomasse

    # Estimation de la biomasse aérienne (AGB)
    # Modèle simplifié basé sur couverture et hauteur
    parcelles$AGB <- k_biomasse * (parcelles$pzabove2 / 100) * (parcelles$zmean^1.5)

    # Stock carbone = AGB × fraction carbone
    parcelles$C1 <- parcelles$AGB * fraction_carbone

    cat("Formule: C1 = k × (pzabove2/100) × zmean^1.5 × 0.47\n")
    cat("k_biomasse =", k_biomasse, "t/ha\n\n")

    cat("=== Résultats C1 ===\n")
    cat("C1 min:", round(min(parcelles$C1, na.rm = TRUE), 1), "tC/ha\n")
    cat("C1 moy:", round(mean(parcelles$C1, na.rm = TRUE), 1), "tC/ha\n")
    cat("C1 max:", round(max(parcelles$C1, na.rm = TRUE), 1), "tC/ha\n\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_stock_carbone_c1.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("=== Métriques C1 exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Métriques pzabove2 et zmean non trouvées.\n")
    cat("Exécutez l'exercice 6.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.2 : Calculer P1 (Volume de bois)

L'indicateur **P1** estime le volume de bois sur pied :

$$P1 = k_{vol} \times (pzabove2/100) \times zmean \times zmax^{0.5}$$

```{r ex-7-2-p1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-2-p1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=40, exercise.setup="ex-7-2-p1-setup"}
# === CALCUL DE P1 : VOLUME DE BOIS SUR PIED ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de P1 (Volume bois) ===\n\n")

  if (all(c("pzabove2", "zmean", "zmax") %in% names(parcelles))) {
    # Facteur de conversion volume (m³/ha)
    k_volume <- 15

    # Estimation du volume sur pied
    parcelles$P1 <- k_volume * (parcelles$pzabove2 / 100) *
                    parcelles$zmean * sqrt(parcelles$zmax)

    cat("Formule: P1 = k × (pzabove2/100) × zmean × √zmax\n")
    cat("k_volume =", k_volume, "\n\n")

    cat("=== Résultats P1 ===\n")
    cat("P1 min:", round(min(parcelles$P1, na.rm = TRUE), 1), "m³/ha\n")
    cat("P1 moy:", round(mean(parcelles$P1, na.rm = TRUE), 1), "m³/ha\n")
    cat("P1 max:", round(max(parcelles$P1, na.rm = TRUE), 1), "m³/ha\n\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_volume_bois_p1.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("=== Métriques P1 exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Métriques pzabove2, zmean et zmax non trouvées.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.3 : Calculer P2 (Productivité forestière)

L'indicateur **P2** estime la productivité forestière basée sur les métriques LiDAR :
- **zmean** : Hauteur moyenne (indicateur de qualité de station)
- **pzabove2** : Couverture forestière (densité du peuplement)
- **zq95, zq25** : Distribution des hauteurs (vigueur de croissance)

$$P2 = k_{prod} \times zmean \times (pzabove2/100) \times (1 + \frac{zq95 - zq25}{zmean})$$

```{r ex-7-3-p2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-3-p2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-7-3-p2-setup"}
# === CALCUL DE P2 : PRODUCTIVITÉ FORESTIÈRE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de P2 (Productivité forestière) ===\n\n")

  if (all(c("zmean", "pzabove2", "zq95", "zq25") %in% names(parcelles))) {
    # Facteur de productivité (m³/ha/an équivalent)
    k_prod <- 0.3

    # Indice de vigueur : ratio hauteur dominante / hauteur moyenne
    vigueur <- (parcelles$zq95 - parcelles$zq25) / parcelles$zmean
    vigueur <- pmax(0.1, pmin(2, vigueur))  # Borner entre 0.1 et 2

    # P2 : Productivité = hauteur × couverture × vigueur
    parcelles$P2 <- k_prod * parcelles$zmean *
                    (parcelles$pzabove2 / 100) *
                    (1 + vigueur)

    cat("Formule: P2 = k × zmean × (pzabove2/100) × (1 + vigueur)\n")
    cat("k_prod =", k_prod, "\n")
    cat("vigueur = (zq95 - zq25) / zmean\n\n")

    cat("=== Résultats P2 ===\n")
    cat("P2 min:", round(min(parcelles$P2, na.rm = TRUE), 2), "m³/ha/an\n")
    cat("P2 moy:", round(mean(parcelles$P2, na.rm = TRUE), 2), "m³/ha/an\n")
    cat("P2 max:", round(max(parcelles$P2, na.rm = TRUE), 2), "m³/ha/an\n\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_productivite_p2.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("=== Métriques P2 exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Métriques zmean, pzabove2, zq95 et zq25 non trouvées.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.4 : Calculer P3 (Qualité structurale)

L'indicateur **P3** évalue la qualité structurale du peuplement basée sur :
- **zentropy** : Entropie verticale (diversité des strates)
- **zsd** : Écart-type des hauteurs (hétérogénéité)

Un peuplement de haute qualité a une structure régulière (faible entropie, faible variabilité).

```{r ex-7-4-p3-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-4-p3, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-7-4-p3-setup"}
# === CALCUL DE P3 : QUALITÉ STRUCTURALE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de P3 (Qualité structurale) ===\n\n")

  if (all(c("zentropy", "zsd", "zmean") %in% names(parcelles))) {
    # Normaliser zentropy (0-1) - valeurs typiques entre 0.5 et 1
    entropy_norm <- (parcelles$zentropy - 0.5) / 0.5
    entropy_norm <- pmax(0, pmin(1, entropy_norm))

    # Coefficient de variation (CV = sd/mean)
    cv <- parcelles$zsd / parcelles$zmean
    cv_norm <- pmin(1, cv / 0.5)  # Normaliser sur CV max de 0.5

    # P3 : qualité = régularité (inverse de l'hétérogénéité)
    # Score élevé = peuplement régulier, homogène
    parcelles$P3 <- 100 * (1 - 0.5 * entropy_norm - 0.5 * cv_norm)
    parcelles$P3 <- pmax(0, pmin(100, parcelles$P3))

    cat("Formule: P3 = 100 × (1 - 0.5×entropy_norm - 0.5×cv_norm)\n\n")

    cat("=== Résultats P3 ===\n")
    cat("P3 min:", round(min(parcelles$P3, na.rm = TRUE), 1), "\n")
    cat("P3 moy:", round(mean(parcelles$P3, na.rm = TRUE), 1), "\n")
    cat("P3 max:", round(max(parcelles$P3, na.rm = TRUE), 1), "\n\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_qualite_structurale_p3.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("=== Métriques P3 exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Métriques zentropy, zsd et zmean non trouvées.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.5 : Calculer A1 (Occupation du sol)

L'indicateur **A1** caractérise l'**occupation du sol** de chaque parcelle en utilisant :
- **OSO** (Occupation du Sol) de Theia/CESBIO : classification à 10m
- **pzabove2** (LiDAR) : ajustement de la densité de canopée forestière

**Classes OSO principales :**

| Code | Classe | Code | Classe |
|------|--------|------|--------|
| 1 | Cultures annuelles | 16 | Feuillus |
| 2 | Cultures pérennes | 17 | Conifères |
| 3 | Prairies | 18 | Forêt mixte |
| 4 | Vignes | 19 | Landes |
| 5 | Vergers | 20 | Pelouses naturelles |
| 11 | Urbain dense | 21 | Plages et dunes |
| 12 | Urbain diffus | 22 | Roches nues |
| 13 | Zones industrielles | 23 | Eau |
| 14 | Surfaces minérales | 31 | Neige/Glace |

> **Note** : OSO doit être téléchargé depuis [Recherche Data Gouv](https://entrepot.recherche.data.gouv.fr/api/access/datafile/:persistentId?persistentId=doi:10.57745/8M1AN1) et placé dans `~/.local/share/nemeton/tutorial_data/oso_cache/oso.tif`

```{r ex-7-5-a1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-5-a1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=110, exercise.timelimit=1200, exercise.setup="ex-7-5-a1-setup"}
# === CALCUL DE A1 : OCCUPATION DU SOL (OSO + LiDAR) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

# Répertoire dédié pour OSO
oso_cache <- file.path(data_dir, "oso_cache")
dir.create(oso_cache, showWarnings = FALSE, recursive = TRUE)
oso_path <- file.path(oso_cache, "oso.tif")

if (!file.exists(parcelles_path)) {
  stop("Fichier parcelles.gpkg non trouvé.")
}

parcelles <- st_read(parcelles_path, quiet = TRUE)

cat("=== Calcul de A1 (Occupation du sol) ===\n\n")

# Télécharger et extraire OSO si non présent
if (!file.exists(oso_path)) {
  cat("1. Téléchargement OSO depuis Recherche Data Gouv...\n")
  oso_url <- "https://entrepot.recherche.data.gouv.fr/api/access/datafile/:persistentId?persistentId=doi:10.57745/8M1AN1"

  # Chercher une archive OSO existante (OSO_*.tar.gz)
  oso_tar_files <- list.files(oso_cache, pattern = "^OSO_.*\\.tar\\.gz$", full.names = TRUE)
  if (length(oso_tar_files) > 0) {
    oso_tar <- oso_tar_files[1]  # Utiliser la première archive trouvée
  } else {
    oso_tar <- file.path(oso_cache, "OSO_RASTER.tar.gz")  # Nom par défaut pour le téléchargement
  }

  # Vérifier si curl est disponible
  if (!requireNamespace("curl", quietly = TRUE)) {
    stop("Package 'curl' requis. Installez-le avec: install.packages('curl')")
  }

  # Taille attendue de l'archive (~6 Go)
  oso_expected_size <- 5e9

  tryCatch({
    # Vérifier si l'archive existe déjà et est complète
    need_download <- TRUE
    if (file.exists(oso_tar)) {
      existing_size <- file.info(oso_tar)$size
      cat("   Archive existante détectée (", round(existing_size / 1e9, 2), " Go)\n")
      if (existing_size >= oso_expected_size) {
        cat("   Archive complète, téléchargement ignoré.\n")
        need_download <- FALSE
      } else {
        cat("   Archive incomplète, reprise du téléchargement...\n")
      }
    } else {
      cat("   Fichier volumineux (~6 Go), téléchargement en cours...\n")
    }

    # Télécharger avec curl (supporte la reprise)
    if (need_download) {
      curl::curl_download(
        url = oso_url,
        destfile = oso_tar,
        quiet = FALSE,
        mode = "wb"
      )
      cat("   Archive téléchargée!\n")
    }

    # Extraire l'archive dans le répertoire cache
    # L'archive contient: OSO_*/DATA/OCS_*.tif
    cat("   Extraction de l'archive (peut prendre plusieurs minutes, patientez)...\n")
    untar(path.expand(oso_tar), exdir = path.expand(oso_cache), extras = "--touch")
    cat("   Extraction terminée!\n")

    # Trouver le fichier OCS_*.tif dans les sous-répertoires extraits
    tif_files <- list.files(oso_cache, pattern = "^OCS_.*\\.tif$",
                            full.names = TRUE, recursive = TRUE)
    if (length(tif_files) > 0) {
      # Copier le fichier principal (OCS_*.tif) vers oso.tif
      copy_ok <- file.copy(tif_files[1], oso_path)
      if (copy_ok && file.exists(oso_path)) {
        cat("   Fichier copié vers oso.tif\n")

        # Nettoyer: supprimer les répertoires extraits (OSO_*) et l'archive
        oso_dirs <- list.dirs(oso_cache, full.names = TRUE, recursive = FALSE)
        oso_dirs <- oso_dirs[grepl("^OSO_", basename(oso_dirs))]
        if (length(oso_dirs) > 0) {
          unlink(oso_dirs, recursive = TRUE)
          cat("   Répertoires temporaires supprimés\n")
        }
        if (file.exists(oso_tar)) {
          file.remove(oso_tar)
          cat("   Archive supprimée\n\n")
        }
      } else {
        cat("   Erreur lors de la copie - fichiers conservés\n\n")
      }
    } else {
      cat("   Aucun fichier OCS_*.tif trouvé dans l'archive - fichiers conservés\n\n")
    }

  }, error = function(e) {
    cat("   Erreur:", e$message, "\n")
    if (file.exists(oso_tar)) {
      cat("   Archive partielle conservée dans oso_cache - relancez pour reprendre\n")
    }
    cat("   Ou téléchargez manuellement depuis:\n")
    cat("   https://entrepot.recherche.data.gouv.fr/api/access/datafile/:persistentId?persistentId=doi:10.57745/8M1AN1\n\n")
  })
}

# Classes OSO et leurs noms
oso_classes <- data.frame(
  code = c(1, 2, 3, 4, 5, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22, 23, 31),
  nom = c("Cultures_annuelles", "Cultures_perennes", "Prairies", "Vignes", "Vergers",
          "Urbain_dense", "Urbain_diffus", "Industriel", "Mineral",
          "Feuillus", "Coniferes", "Foret_mixte", "Landes", "Pelouses",
          "Plages_dunes", "Roches", "Eau", "Neige"),
  stringsAsFactors = FALSE
)

# Classes forestières pour le calcul de A1
foret_codes <- c(16, 17, 18)

if (file.exists(oso_path)) {
  cat("1. Chargement et découpage OSO...\n")
  oso_full <- rast(oso_path)

  # Reprojeter parcelles si nécessaire
  if (!identical(crs(oso_full, proj=TRUE), st_crs(parcelles)$proj4string)) {
    parcelles_oso <- st_transform(parcelles, crs(oso_full))
  } else {
    parcelles_oso <- parcelles
  }

  # Découper OSO sur l'emprise des parcelles (beaucoup plus rapide)
  parcelles_ext <- ext(vect(parcelles_oso))
  oso <- crop(oso_full, parcelles_ext)
  rm(oso_full)  # Libérer la mémoire
  cat("   OSO découpé sur l'emprise des parcelles\n")

  cat("2. Extraction des classes OSO par parcelle...\n")
  cat("   Calcul en cours (", nrow(parcelles), " parcelles)...\n")

  # Extraction vectorisée (beaucoup plus rapide que boucle)
  parcelles_vect <- vect(parcelles_oso)
  extracted <- terra::extract(oso, parcelles_vect, touches = TRUE)
  names(extracted)[2] <- "classe"

  # Calculer les pourcentages par parcelle
  cat("   Calcul des pourcentages par classe...\n")

  # Initialiser les colonnes
  for (j in seq_len(nrow(oso_classes))) {
    col_name <- paste0("OSO_", oso_classes$nom[j])
    parcelles[[col_name]] <- 0
  }
  parcelles$OSO_Foret_total <- 0

  # Calculer les stats par parcelle (groupé)
  for (i in seq_len(nrow(parcelles))) {
    vals <- extracted$classe[extracted$ID == i]
    vals <- vals[!is.na(vals)]

    if (length(vals) > 0) {
      total <- length(vals)
      for (j in seq_len(nrow(oso_classes))) {
        col_name <- paste0("OSO_", oso_classes$nom[j])
        parcelles[[col_name]][i] <- round(sum(vals == oso_classes$code[j]) / total * 100, 1)
      }
      # % forêt total
      parcelles$OSO_Foret_total[i] <- round(sum(vals %in% foret_codes) / total * 100, 1)
    }
  }

  cat("\n3. Statistiques OSO:\n")
  cat("   Forêt moyenne:", round(mean(parcelles$OSO_Foret_total, na.rm = TRUE), 1), "%\n")
  cat("   - Feuillus:", round(mean(parcelles$OSO_Feuillus, na.rm = TRUE), 1), "%\n")
  cat("   - Conifères:", round(mean(parcelles$OSO_Coniferes, na.rm = TRUE), 1), "%\n")
  cat("   - Mixte:", round(mean(parcelles$OSO_Foret_mixte, na.rm = TRUE), 1), "%\n")

  # A1 basé sur OSO_Foret_total
  parcelles$A1 <- parcelles$OSO_Foret_total

} else {
  cat("OSO non trouvé - utilisation de pzabove2 seul\n")
  parcelles$A1 <- 0
}

# Ajustement avec pzabove2 (densité de canopée LiDAR)
if ("pzabove2" %in% names(parcelles)) {
  pzabove2 <- as.numeric(unlist(parcelles$pzabove2))
  cat("\n4. Ajustement avec pzabove2 (densité canopée LiDAR)...\n")
  # Moyenne pondérée : 70% OSO + 30% pzabove2
  parcelles$A1 <- round(0.7 * parcelles$A1 + 0.3 * pzabove2, 1)
  cat("   A1 = 0.7 × OSO_Foret + 0.3 × pzabove2\n")
}

cat("\n=== Résultats A1 ===\n")
cat("A1 min:", round(min(parcelles$A1, na.rm = TRUE), 1), "%\n")
cat("A1 moy:", round(mean(parcelles$A1, na.rm = TRUE), 1), "%\n")
cat("A1 max:", round(max(parcelles$A1, na.rm = TRUE), 1), "%\n")

# Sauvegarder
output_path <- file.path(data_dir, "metriques_couverture_forestiere_a1.gpkg")
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n=== Métriques A1 exportées ===\n")
cat("Fichier:", output_path, "\n")
cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n")
```

---

## Section 8 : Indicateurs Énergie (E1, E2)

### Introduction à la famille Énergie

La **famille Énergie (E)** du référentiel nemeton quantifie le potentiel énergétique de la forêt :

- **E1** : Potentiel de production de bois-énergie (tep/ha/an)
- **E2** : Évitement carbone par substitution aux énergies fossiles (tCO₂/ha/an)

La biomasse forestière peut se substituer aux énergies fossiles :

- Chauffage (bois bûche, plaquettes, granulés)
- Cogénération (électricité + chaleur)
- Biocarburants de 2ème génération


```{r energie-concept, echo=FALSE}
substitution <- data.frame(
  Indicateur = c("E1", "E2"),
  Nom = c("Potentiel bois-énergie", "Évitement carbone"),
  Unite = c("tep/ha/an", "tCO₂/ha/an"),
  Source = c("pzabove2, zmean", "E1 × facteur substitution")
)
knitr::kable(substitution, caption = "Indicateurs de la famille Énergie")
```

### Exercice 7.1 : Calculer E1 (Bois-énergie)

L'indicateur **E1** estime le potentiel de production de bois-énergie à partir des métriques LiDAR :

- **pzabove2** : Couverture forestière > 2m (%)
- **zmean** : Hauteur moyenne de la canopée (m)

$$E1 = \frac{pzabove2}{100} \times zmean \times k_{conversion}$$

Où $k_{conversion}$ ≈ 0.015 tep/m/ha/an (tonne équivalent pétrole)

```{r ex-7-1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-7-1-setup"}
# === CALCUL DE E1 : POTENTIEL BOIS-ÉNERGIE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de E1 (Bois-énergie) ===\n\n")

  # Vérifier les métriques nécessaires
  if (all(c("pzabove2", "zmean") %in% names(parcelles))) {
    # Facteur de conversion (tep/m/ha/an)
    # Basé sur productivité moyenne et pouvoir calorifique du bois
    k_conversion <- 0.015

    # Calcul E1
    parcelles$E1 <- (parcelles$pzabove2 / 100) * parcelles$zmean * k_conversion

    cat("Formule: E1 = (pzabove2/100) × zmean × k_conversion\n")
    cat("k_conversion =", k_conversion, "tep/m/ha/an\n\n")

    cat("=== Résultats E1 ===\n")
    cat("E1 min:", round(min(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n")
    cat("E1 moy:", round(mean(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n")
    cat("E1 max:", round(max(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_bois_energie_e1.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("=== Métriques E1 exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
  } else {
    cat("Métriques pzabove2 et zmean non trouvées.\n")
    cat("Exécutez l'exercice 6.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
  cat("Exécutez le Tutorial 01 d'abord.\n")
}
```

### Exercice 7.2 : Calculer E2 (Évitement carbone)

L'indicateur **E2** quantifie les **émissions de CO₂ évitées** grâce à la substitution du bois aux énergies fossiles :

$$E2 = E1 \times f_{substitution} \times \eta_{conversion}$$

Où :
- $E1$ : Production énergétique potentielle (tep/ha/an)
- $f_{substitution}$ ≈ 2.5 tCO₂/tep (facteur moyen de substitution)
- $\eta_{conversion}$ ≈ 0.85 (rendement des chaufferies bois)

```{r e2-table, echo=FALSE}
substitution <- data.frame(
  Combustible_Remplace = c("Fioul domestique", "Gaz naturel", "Charbon", "Électricité (mix FR)"),
  tCO2_evite_par_tep = c(2.9, 2.3, 3.4, 0.5),
  Usage_Typique = c("Chauffage individuel", "Chauffage collectif", "Industrie", "Pointe")
)
knitr::kable(substitution, caption = "Facteurs de substitution carbone par combustible")
```

```{r ex-7-2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-7-2-setup"}
# === CALCUL DE E2 : ÉVITEMENT CARBONE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de E2 (Évitement carbone) ===\n\n")

  # Vérifier que E1 existe
  if ("E1" %in% names(parcelles)) {
    # Paramètres de calcul
    facteur_substitution <- 2.5 # tCO2 évitées par tep de bois-énergie
    rendement_conversion <- 0.85 # Efficacité moyenne des chaufferies

    cat("Paramètres:\n")
    cat("  Facteur substitution:", facteur_substitution, "tCO2/tep\n")
    cat("  Rendement conversion:", rendement_conversion, "\n\n")

    # Convertir E1 en vecteur numérique (évite les problèmes de list-column)
    E1_vec <- as.numeric(unlist(parcelles$E1))

    # Calcul E2
    parcelles$E2 <- E1_vec * facteur_substitution * rendement_conversion

    cat("Formule: E2 = E1 × f_substitution × η_conversion\n\n")

    cat("=== Résultats E2 ===\n")
    cat("E2 min:", round(min(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n")
    cat("E2 moy:", round(mean(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n")
    cat("E2 max:", round(max(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n\n")

    # Évitement total sur la zone
    # Calculer surface_ha si absente
    if (!"surface_ha" %in% names(parcelles)) {
      parcelles$surface_ha <- as.numeric(st_area(parcelles)) / 10000
    }
    surface_ha_vec <- as.numeric(unlist(parcelles$surface_ha))
    parcelles$evitement_total <- parcelles$E2 * surface_ha_vec
    total_evitement <- sum(parcelles$evitement_total, na.rm = TRUE)
    cat("Évitement total zone:", round(total_evitement, 1), "tCO2/an\n\n")

    # Sauvegarder
    output_path <- file.path(data_dir, "metriques_evitement_carbone_e2.gpkg")
    st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("=== Métriques E2 exportées ===\n")
    cat("Fichier:", output_path, "\n")
    cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")

    # Visualisation
    cat("\n=== Distribution E2 ===\n")
    hist(parcelles$E2,
      breaks = 15, col = "darkorange",
      main = "E2 : Évitement carbone",
      xlab = "tCO2/ha/an", ylab = "Fréquence"
    )
  } else {
    cat("E1 non trouvé. Exécutez l'exercice 7.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Interprétation de l'histogramme E2

L'histogramme **E2 : Évitement carbone** montre la distribution des émissions de CO₂ évitées par parcelle, exprimées en **tCO₂/ha/an**.

**Ce que représente E2** : le bénéfice climatique potentiel si le bois de la parcelle était utilisé comme source d'énergie à la place des combustibles fossiles (fioul, gaz, charbon).

=== Grille d'interprétation E2 ===

```{r e2-interpretation, echo=FALSE}
interpretation <- data.frame(
  Valeur_E2 = c("0 - 0.5", "0.5 - 1.5", "> 1.5"),
  Interpretation = c(
    "Faible potentiel (parcelle peu productive ou jeune)",
    "Potentiel modéré (forêt moyenne)",
    "Fort potentiel (forêt productive, mature)"
  )
)
knitr::kable(interpretation, col.names = c("E2 (tCO2/ha/an)", "Interprétation"))
```

=== Exemple concret ===

Une parcelle avec E2 = 1.0 tCO2/ha/an signifie :

- 1 tonne de CO2 évitée par hectare chaque année
- Sur 10 ha : 10 tCO2/an évitées
- Équivalent à ~5 allers-retours Paris-New York en avion

=== Forme de la distribution ===

- Étalée à droite : quelques parcelles très productives
- Pic à gauche : beaucoup de jeunes peuplements
- Normale : forêt homogène en productivité

### Quiz : Indicateurs Énergie

```{r quiz-energie-1, echo=FALSE}
question("Que représente l'indicateur E1 ?",
  answer("Le stock de carbone"),
  answer("Le potentiel de production bois-énergie", correct = TRUE),
  answer("L'évitement d'émissions CO2"),
  answer("La consommation énergétique"),
  allow_retry = TRUE
)
```

```{r quiz-energie-2, echo=FALSE}
question("Quelle unité est utilisée pour E2 ?",
  answer("kWh/ha/an"),
  answer("tep/ha/an"),
  answer("tCO2/ha/an", correct = TRUE),
  answer("m³/ha/an"),
  allow_retry = TRUE
)
```

```{r quiz-energie-3, echo=FALSE}
question("Quel facteur n'influence PAS le calcul de E2 ?",
  answer("Le potentiel E1"),
  answer("Le facteur de substitution"),
  answer("Le rendement de conversion"),
  answer("La pente du terrain", correct = TRUE),
  allow_retry = TRUE
)
```

---

## Section 9 : Indicateurs Vitalité et Air (C2, A2)

### Introduction aux indicateurs C2 et A2

Ces indicateurs complètent l'analyse LiDAR avec des données complémentaires :

- **C2** (Vitalité) : Indice NDVI mesurant la vitalité de la végétation
- **A2** (Air) : Qualité de l'air basée sur l'éloignement des sources de pollution

```{r indicateurs-c2a2-concept, echo=FALSE}
indics_c2a2 <- data.frame(
  Indicateur = c("C2", "A2"),
  Nom = c("Vitalité végétation (NDVI)", "Qualité de l'air forestier"),
  Unite = c("score 0-100", "score 0-100"),
  Source = c("Sentinel-2 / BD Forêt", "Distance routes (BD TOPO)")
)
knitr::kable(indics_c2a2, caption = "Indicateurs de vitalité et qualité de l'air")
```

### Exercice 9.1 : Indice de Vitalité NDVI (C2)

L'indicateur **C2** mesure la **vitalité de la végétation** via l'indice NDVI (Normalized Difference Vegetation Index).

**Sources de données (par ordre de priorité) :**

| Priorité | Source | Package | Résolution | Description |
|----------|--------|---------|------------|-------------|
| 1 | IGN Ortho IRC | happign | 50cm | Orthophoto infrarouge couleur (France) |
| 2 | Sentinel-2 L2A | rstac | 10m | Bandes B4/B8 via STAC API (global) |
| 3 | MODIS NDVI | geodata | 250m | Données globales MOD13Q1 |
| 4 | BD Forêt | sf | vecteur | Estimation par type de peuplement |

**Formule NDVI :**

$$NDVI = \frac{NIR - Rouge}{NIR + Rouge}$$

| NDVI | Interprétation |
|------|----------------|
| < 0.2 | Sol nu, urbain |
| 0.2 - 0.4 | Végétation clairsemée |
| 0.4 - 0.6 | Végétation modérée |
| 0.6 - 0.8 | Végétation dense |
| > 0.8 | Végétation très dense |

```{r ex-9-1-c2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-9-1-c2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=150, exercise.setup="ex-9-1-c2-setup", exercise.timelimit=900}
# === INDICATEUR C2 (NDVI - VITALITÉ VÉGÉTATION) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

cat("=== Indicateur C2 : NDVI (Vitalité) ===\n\n")

ndvi_available <- FALSE
ndvi_raster <- NULL

# ============================================================
# 1. TÉLÉCHARGEMENT DONNÉES NDVI (ordre: happign > rstac > geodata)
# ============================================================

# Méthode 1: happign (Ortho IRC IGN) - Priorité France
if (requireNamespace("happign", quietly = TRUE)) {
  library(happign)

  tryCatch(
    {
      cat("Méthode 1: happign (Ortho IRC IGN)...\n")

      # Bbox pour la requête
      zone_bbox <- st_as_sfc(st_bbox(parcelles))
      st_crs(zone_bbox) <- st_crs(parcelles)

      # Chercher les couches d'orthophotos IRC disponibles
      wms_layers <- get_layers_metadata("wmts", "ortho")
      irc_layers <- wms_layers$Identifier[grepl("irc|infrarouge|ortho.*ir",
        wms_layers$Identifier,
        ignore.case = TRUE
      )]

      if (length(irc_layers) > 0) {
        cat("Couches IRC trouvées:", length(irc_layers), "\n")

        # Télécharger l'ortho IRC
        for (layer in head(irc_layers, 3)) {
          tryCatch(
            {
              irc_raster <- get_wms_raster(
                x = zone_bbox,
                layer = layer,
                res = 5,
                crs = st_crs(parcelles)$epsg
              )

              if (!is.null(irc_raster) && nlyr(irc_raster) >= 3) {
                nir <- irc_raster[[1]]
                red <- irc_raster[[2]]
                ndvi_raster <- (nir - red) / (nir + red + 0.001)
                ndvi_available <- TRUE
                cat("NDVI calculé depuis Ortho IRC!\n")
                break
              }
            },
            error = function(e) cat("Erreur couche", layer, ":", e$message, "\n")
          )
        }
      }
    },
    error = function(e) cat("Erreur happign IRC:", e$message, "\n")
  )
}

# Méthode 2: rstac (Sentinel-2 via STAC API)
if (!ndvi_available && requireNamespace("rstac", quietly = TRUE)) {
  library(rstac)

  tryCatch(
    {
      cat("\nMéthode 2: rstac (Sentinel-2 STAC)...\n")
      bbox <- st_bbox(st_transform(parcelles, 4326))

      s2_stac <- stac("https://planetarycomputer.microsoft.com/api/stac/v1")
      items <- s2_stac |>
        stac_search(
          collections = "sentinel-2-l2a",
          bbox = c(bbox["xmin"], bbox["ymin"], bbox["xmax"], bbox["ymax"]),
          datetime = paste0(format(Sys.Date() - 90, "%Y-%m-%d"), "/", format(Sys.Date(), "%Y-%m-%d"))
        ) |>
        get_request() |>
        items_filter(filter_fn = function(x) x$properties$`eo:cloud_cover` < 20)

      if (length(items$features) > 0) {
        best_item <- items$features[[1]]
        cat("Image Sentinel-2:", best_item$id, "\n")

        b4_url <- best_item$assets$B04$href
        b8_url <- best_item$assets$B08$href

        if (!is.null(b4_url) && !is.null(b8_url)) {
          b4_raster <- rast(paste0("/vsicurl/", b4_url))
          b8_raster <- rast(paste0("/vsicurl/", b8_url))
          zone_vect <- vect(st_transform(st_as_sfc(st_bbox(parcelles)), 4326))
          b4_crop <- crop(b4_raster, zone_vect)
          b8_crop <- crop(b8_raster, zone_vect)
          ndvi_raster <- (b8_crop - b4_crop) / (b8_crop + b4_crop + 0.001)
          ndvi_available <- TRUE
          cat("NDVI calculé depuis Sentinel-2!\n")
        }
      }
    },
    error = function(e) cat("Erreur rstac:", e$message, "\n")
  )
}

# ============================================================
# 2. CALCUL DU NDVI PAR PARCELLE
# ============================================================

cat("\n=== Calcul NDVI ===\n")

bd_foret_path <- file.path(data_dir, "bd_foret.gpkg")
parcelles$C2 <- 0.5  # Valeur par défaut

# Si raster NDVI disponible, extraire par parcelle
if (ndvi_available && exists("ndvi_raster") && !is.null(ndvi_raster)) {
  cat("Extraction NDVI depuis raster...\n")

  if (requireNamespace("exactextractr", quietly = TRUE)) {
    parcelles$C2 <- exactextractr::exact_extract(
      ndvi_raster,
      st_transform(parcelles, crs(ndvi_raster)),
      fun = "mean"
    )
  } else {
    # Extraction manuelle (parallélisée si furrr disponible)
    ndvi_crs <- crs(ndvi_raster)
    extract_ndvi_i <- function(i) {
      geom <- st_transform(st_geometry(parcelles)[i], ndvi_crs)
      vals <- terra::extract(ndvi_raster, vect(geom), fun = mean, na.rm = TRUE)
      if (nrow(vals) > 0 && !is.na(vals[1, 2])) return(vals[1, 2])
      return(0.5)
    }

    # Utiliser smart_map avec complexité "low" (extraction raster ~5-20ms/parcelle)
    parcelles$C2 <- nemeton::smart_map(
      seq_len(nrow(parcelles)),
      extract_ndvi_i,
      complexity = "low",
      .type = "dbl"
    )
  }
} else {
  # Estimation basée sur BD Forêt + LiDAR
  cat("Pas de données satellite, estimation via BD Forêt...\n")

  if (file.exists(bd_foret_path)) {
    bd_foret <- st_read(bd_foret_path, quiet = TRUE)
    bd_foret <- st_transform(bd_foret, st_crs(parcelles))

    ndvi_by_type <- data.frame(
      pattern = c("feuill", "resin", "conif", "mixte", "taillis", "lande", "peupl"),
      ndvi_base = c(0.72, 0.65, 0.65, 0.68, 0.60, 0.45, 0.70),
      stringsAsFactors = FALSE
    )

    calc_ndvi_bdforet_i <- function(i, parcelles_geom, bd_foret, ndvi_by_type) {
      geom <- parcelles_geom[i]
      foret_inter <- suppressWarnings(
        tryCatch(st_intersection(bd_foret, geom), error = function(e) NULL)
      )
      if (is.null(foret_inter) || nrow(foret_inter) == 0) return(0.5)

      type_col <- intersect(names(foret_inter), c("tfv", "essence", "libelle", "code_tfv"))
      if (length(type_col) > 0) {
        type_val <- tolower(as.character(foret_inter[[type_col[1]]][1]))
        for (j in seq_len(nrow(ndvi_by_type))) {
          if (grepl(ndvi_by_type$pattern[j], type_val)) {
            return(ndvi_by_type$ndvi_base[j] + rnorm(1, 0, 0.05))
          }
        }
      }
      return(0.5)
    }

    parcelles_geom <- st_geometry(parcelles)

    # Utiliser smart_map avec complexité "medium" (intersection spatiale ~20-100ms/parcelle)
    options(future.globals.maxSize = +Inf)  # Pour objets volumineux si parallélisé
    parcelles$C2 <- nemeton::smart_map(
      seq_len(nrow(parcelles)),
      function(i) calc_ndvi_bdforet_i(i, parcelles_geom, bd_foret, ndvi_by_type),
      complexity = "medium",
      .type = "dbl"
    )
  }

  # Ajustement avec métriques LiDAR si disponibles
  if ("pzabove2" %in% names(parcelles)) {
    parcelles$C2 <- parcelles$C2 * (0.7 + 0.3 * as.numeric(unlist(parcelles$pzabove2)) / 100)
    cat("Ajusté avec couverture LiDAR (pzabove2)\n")
  }
}

# Borner entre 0 et 1
parcelles$C2 <- pmax(0, pmin(1, parcelles$C2))
parcelles$C2_score <- parcelles$C2 * 100

# Classification
parcelles$C2_classe <- cut(parcelles$C2,
  breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1),
  labels = c("Sol nu", "Clairsemé", "Modéré", "Dense", "Très dense"),
  include.lowest = TRUE
)

cat("\n=== Résultats C2 ===\n")
cat("NDVI min:", round(min(parcelles$C2, na.rm = TRUE), 3), "\n")
cat("NDVI max:", round(max(parcelles$C2, na.rm = TRUE), 3), "\n")
cat("NDVI moyen:", round(mean(parcelles$C2, na.rm = TRUE), 3), "\n")
cat("C2 score moyen:", round(mean(parcelles$C2_score, na.rm = TRUE), 1), "/ 100\n")
cat("\nDistribution:\n")
print(table(parcelles$C2_classe))

# Sauvegarder
output_path <- file.path(data_dir, "metriques_vitalite_c2.gpkg")
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n=== Métriques C2 Vitalité exportées ===\n")
cat("Fichier:", output_path, "\n")
cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
```

### Exercice 9.2 : Qualité de l'air (A2)

L'indicateur **A2** évalue la **qualité de l'air forestier** basée sur l'éloignement et le type des sources de pollution (routes).

**Modèle de dispersion de pollution :**

| Facteur | Description | Impact |
|---------|-------------|--------|
| **Distance routes** | Éloignement des axes routiers | Décroissance quadratique de la pollution |
| **Type de route** | BD TOPO v3 (nature) | Coefficient de pollution par type |
| **Rayon d'influence** | 2000 m | Zone d'impact maximal |

**Coefficients de pollution par type de route :**

| Type | Coefficient | Exemples |
|------|-------------|----------|
| 1.0 | Très élevé | Autoroute |
| 0.8-0.9 | Élevé | Route à 2 chaussées, Quasi-autoroute |
| 0.5-0.7 | Modéré | Route à 1 chaussée, Bretelle, Rond-point |
| 0.1-0.3 | Faible | Route empierrée, Chemin |
| < 0.1 | Très faible | Piste cyclable, Sentier |

```{r ex-9-2-a2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-9-2-a2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=120, exercise.setup="ex-9-2-a2-setup", exercise.timelimit=300}
# === INDICATEUR A2 (QUALITÉ AIR FORESTIER) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
routes_path <- file.path(data_dir, "routes.gpkg")

if (!file.exists(parcelles_path)) {
  stop("Données manquantes. Exécutez d'abord les tutoriels précédents.")
}

parcelles <- st_read(parcelles_path, quiet = TRUE)

cat("=== INDICATEUR A2 : Qualité air forestier ===\n\n")

# ============================================================
# 1. DISTANCE AUX ROUTES (source principale de pollution)
# ============================================================
cat("1. Chargement des routes (BD TOPO v3)...\n")

routes <- NULL

if (file.exists(routes_path)) {
  routes <- st_read(routes_path, quiet = TRUE)
  routes <- st_transform(routes, st_crs(parcelles))
  cat("   Routes BD TOPO chargées:", nrow(routes), "segments\n")
} else {
  cat("   Fichier routes.gpkg non trouvé.\n")
  cat("   Exécutez d'abord le tutoriel 01-acquisition pour télécharger les routes.\n")
}

# ============================================================
# 2. PONDÉRATION PAR TYPE DE ROUTE (pollution)
# ============================================================
cat("\n2. Pondération par type de route...\n")

# Coefficients de pollution par type de route BD TOPO v3
pollution_weights <- data.frame(
  nature = c(
    "Autoroute", "Quasi-autoroute", "Route à 2 chaussées",
    "Route à 1 chaussée", "Route empierrée", "Chemin",
    "Bretelle", "Rond-point", "Piste cyclable", "Sentier"
  ),
  poids = c(1.0, 0.9, 0.8, 0.6, 0.3, 0.1, 0.7, 0.5, 0.05, 0.02),
  stringsAsFactors = FALSE
)

cat("\n   Coefficients de pollution par type:\n")
print(pollution_weights)

if (!is.null(routes) && nrow(routes) > 0) {
  # Identifier le champ "nature" dans BD TOPO
  nature_field <- NULL
  for (field in c("nature", "NATURE", "classe", "importance", "type")) {
    if (field %in% names(routes)) {
      nature_field <- field
      break
    }
  }

  if (!is.null(nature_field)) {
    cat("\n   Champ type de route:", nature_field, "\n")
    cat("   Types présents:\n")
    print(table(routes[[nature_field]]))

    # Assigner les poids aux routes
    routes$pollution_weight <- 0.5
    for (i in seq_len(nrow(pollution_weights))) {
      mask <- grepl(pollution_weights$nature[i], routes[[nature_field]], ignore.case = TRUE)
      routes$pollution_weight[mask] <- pollution_weights$poids[i]
    }
  } else {
    cat("   Champ nature non trouvé - poids uniforme appliqué\n")
    routes$pollution_weight <- 0.5
  }

  # ============================================================
  # 3. CALCUL DISTANCE PONDÉRÉE PAR PARCELLE
  # ============================================================
  cat("\n3. Calcul des distances pondérées par parcelle...\n")

  parcelles_centroids <- st_centroid(parcelles)

  # Fonction de calcul du score pollution pour une parcelle
  calc_pollution_score <- function(centroid, routes, max_dist = 2000) {
    dists <- as.numeric(st_distance(centroid, routes))
    in_range <- dists < max_dist

    if (sum(in_range) == 0) return(0)  # Pas de route proche = pas de pollution

    # Score pollution = somme(poids / distance²)
    weights <- routes$pollution_weight[in_range]
    distances <- pmax(dists[in_range], 10)  # Min 10m pour éviter division par 0
    pollution_contribution <- sum(weights / (distances / 100)^2)

    return(pollution_contribution)
  }

  # Calcul pour chaque parcelle
  cat("   Calcul en cours...\n")

  calc_fn <- function(i) {
    calc_pollution_score(parcelles_centroids[i, ], routes)
  }

  # Utiliser smart_map avec complexité "medium" (calcul de distance ~20-100ms/parcelle)
  options(future.globals.maxSize = +Inf)  # Pour objets volumineux si parallélisé
  pollution_scores <- nemeton::smart_map(
    seq_len(nrow(parcelles)),
    calc_fn,
    complexity = "medium",
    .type = "dbl"
  )

  parcelles$pollution_score <- pollution_scores

  # Distance simple (pour référence)
  routes_union <- st_union(routes)
  parcelles$dist_routes <- as.numeric(st_distance(parcelles_centroids, routes_union))

  cat("   Distance moyenne aux routes:", round(mean(parcelles$dist_routes, na.rm = TRUE)), "m\n")
  cat("   Score pollution moyen:", round(mean(parcelles$pollution_score, na.rm = TRUE), 2), "\n")
} else {
  parcelles$dist_routes <- 500
  parcelles$pollution_score <- 0.1
  cat("   Routes non disponibles - valeurs par défaut\n")
}

# ============================================================
# 4. CALCUL DE L'INDICE A2
# ============================================================
cat("\n4. Calcul de l'indice A2...\n")

# Normaliser le score pollution (échelle log pour gérer les valeurs extrêmes)
max_pollution <- max(parcelles$pollution_score, na.rm = TRUE)
if (max_pollution > 0) {
  pollution_norm <- log1p(parcelles$pollution_score) / log1p(max_pollution)
  parcelles$A2 <- round((1 - pollution_norm) * 100, 1)
} else {
  parcelles$A2 <- 100
}

# Assurer les bornes [0, 100]
parcelles$A2 <- pmax(0, pmin(100, parcelles$A2))

# Classification
parcelles$A2_classe <- cut(parcelles$A2,
  breaks = c(0, 30, 60, 80, 100),
  labels = c("Dégradé", "Modéré", "Bon", "Excellent"),
  include.lowest = TRUE
)

cat("\n=== Résultats A2 ===\n")
cat("A2 moyen:", round(mean(parcelles$A2, na.rm = TRUE), 1), "/ 100\n")
cat("A2 min:", round(min(parcelles$A2, na.rm = TRUE), 1), "\n")
cat("A2 max:", round(max(parcelles$A2, na.rm = TRUE), 1), "\n")
cat("Interprétation: 0 = proche routes/pollution, 100 = air pur\n")
cat("\nDistribution:\n")
print(table(parcelles$A2_classe))

# Sauvegarder
output_path <- file.path(data_dir, "metriques_qualite_air_a2.gpkg")
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n=== Métriques A2 Qualité air exportées ===\n")
cat("Fichier:", output_path, "\n")
cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")
```

---

## Section 10 : Export et synthèse

Cette section consolide tous les indicateurs calculés dans les sections précédentes.
Chaque exercice importe les indicateurs d'une famille depuis les fichiers `metriques_*.gpkg`.

### Exercice 10.1 : Famille C (Carbone)

```{r ex-10-1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-10-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-10-1-setup"}
# === FAMILLE C (CARBONE) : C1, C2 ===
# Consolidation des indicateurs déjà calculés

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
output_path <- file.path(data_dir, "indicateurs_lidar.gpkg")

parcelles <- st_read(parcelles_path, quiet = TRUE)
cat("=== Famille C (Carbone) ===\n\n")

# C1 : Stock carbone (calculé en section 7)
c1_path <- file.path(data_dir, "metriques_stock_carbone_c1.gpkg")
if (file.exists(c1_path)) {
  c1_data <- st_read(c1_path, quiet = TRUE) |> st_drop_geometry()
  if ("C1" %in% names(c1_data)) {
    parcelles$C1 <- as.numeric(unlist(c1_data$C1))
    cat("C1 (stock carbone):", round(mean(parcelles$C1, na.rm = TRUE), 1), "tC/ha\n")
    cat("   0 = pas de stock, valeurs élevées = fort stockage carbone\n\n")
  }
}

# C2 : Vitalité NDVI (calculé en section 9)
c2_path <- file.path(data_dir, "metriques_vitalite_c2.gpkg")
if (file.exists(c2_path)) {
  c2_data <- st_read(c2_path, quiet = TRUE) |> st_drop_geometry()
  if ("C2" %in% names(c2_data)) {
    parcelles$C2 <- as.numeric(unlist(c2_data$C2))
    cat("C2 (vitalité NDVI):", round(mean(parcelles$C2, na.rm = TRUE), 2), "\n")
    cat("   0 = sol nu, 1 = végétation très dense\n")
  }
}

# Sauvegarder
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n✓ Famille C consolidée:", basename(output_path), "\n")
```


---

### Exercice 10.2 : Famille P (Production)

```{r ex-10-2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-10-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-10-2-setup"}
# === FAMILLE P (PRODUCTION) : P1, P2, P3 ===
# Consolidation des indicateurs déjà calculés

output_path <- file.path(data_dir, "indicateurs_lidar.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

cat("=== Famille P (Production) ===\n\n")

# P1 : Volume bois sur pied (calculé en section 7)
p1_path <- file.path(data_dir, "metriques_volume_bois_p1.gpkg")
if (file.exists(p1_path)) {
  p1_data <- st_read(p1_path, quiet = TRUE) |> st_drop_geometry()
  if ("P1" %in% names(p1_data)) {
    parcelles$P1 <- as.numeric(unlist(p1_data$P1))
    cat("P1 (volume bois):", round(mean(parcelles$P1, na.rm = TRUE), 1), "m³/ha\n")
    cat("   0 = pas de bois, valeurs élevées = fort volume sur pied\n\n")
  }
}

# P2 : Productivité forestière (calculé en section 7)
p2_path <- file.path(data_dir, "metriques_productivite_p2.gpkg")
if (file.exists(p2_path)) {
  p2_data <- st_read(p2_path, quiet = TRUE) |> st_drop_geometry()
  if ("P2" %in% names(p2_data)) {
    parcelles$P2 <- as.numeric(unlist(p2_data$P2))
    cat("P2 (productivité):", round(mean(parcelles$P2, na.rm = TRUE), 2), "m³/ha/an\n")
    cat("   0 = faible croissance, valeurs élevées = forte productivité\n\n")
  }
}

# P3 : Qualité structurale (calculé en section 7)
p3_path <- file.path(data_dir, "metriques_qualite_structurale_p3.gpkg")
if (file.exists(p3_path)) {
  p3_data <- st_read(p3_path, quiet = TRUE) |> st_drop_geometry()
  if ("P3" %in% names(p3_data)) {
    parcelles$P3 <- as.numeric(unlist(p3_data$P3))
    cat("P3 (qualité structurale):", round(mean(parcelles$P3, na.rm = TRUE), 1), "\n")
    cat("   0 = structure irrégulière, 100 = structure régulière\n")
  }
}

# Sauvegarder
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n✓ Famille P consolidée:", basename(output_path), "\n")
```


---

### Exercice 10.3 : Famille E (Énergie)

```{r ex-10-3-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-10-3, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-10-3-setup"}
# === FAMILLE E (ÉNERGIE) : E1, E2 ===
# Consolidation des indicateurs déjà calculés

output_path <- file.path(data_dir, "indicateurs_lidar.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

cat("=== Famille E (Énergie) ===\n\n")

# E1 : Potentiel bois-énergie (calculé en section 8)
e1_path <- file.path(data_dir, "metriques_bois_energie_e1.gpkg")
if (file.exists(e1_path)) {
  e1_data <- st_read(e1_path, quiet = TRUE) |> st_drop_geometry()
  if ("E1" %in% names(e1_data)) {
    parcelles$E1 <- as.numeric(unlist(e1_data$E1))
    cat("E1 (bois-énergie):", round(mean(parcelles$E1, na.rm = TRUE), 2), "tep/ha\n")
    cat("   0 = faible potentiel, valeurs élevées = fort potentiel énergétique\n\n")
  }
}

# E2 : Évitement carbone (calculé en section 8)
e2_path <- file.path(data_dir, "metriques_evitement_carbone_e2.gpkg")
if (file.exists(e2_path)) {
  e2_data <- st_read(e2_path, quiet = TRUE) |> st_drop_geometry()
  if ("E2" %in% names(e2_data)) {
    parcelles$E2 <- as.numeric(unlist(e2_data$E2))
    cat("E2 (évitement carbone):", round(mean(parcelles$E2, na.rm = TRUE), 2), "tCO₂/ha/an\n")
    cat("   0 = pas d'évitement, valeurs élevées = fort évitement par substitution\n")
  }
}

# Sauvegarder
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n✓ Famille E consolidée:", basename(output_path), "\n")
```


---

### Exercice 10.4 : Famille A (Air)

```{r ex-10-4-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-10-4, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-10-4-setup"}
# === FAMILLE A (AIR) : A1, A2 ===
# Consolidation des indicateurs déjà calculés

output_path <- file.path(data_dir, "indicateurs_lidar.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

cat("=== Famille A (Air) ===\n\n")

# A1 : Couverture forestière (calculé en section 7)
a1_path <- file.path(data_dir, "metriques_couverture_forestiere_a1.gpkg")
if (file.exists(a1_path)) {
  a1_data <- st_read(a1_path, quiet = TRUE) |> st_drop_geometry()
  if ("A1" %in% names(a1_data)) {
    parcelles$A1 <- as.numeric(unlist(a1_data$A1))
    cat("A1 (couverture forestière):", round(mean(parcelles$A1, na.rm = TRUE), 1), "%\n")
    cat("   0% = pas de forêt, 100% = entièrement boisé\n\n")
  }
}

# A2 : Qualité air (calculé en section 9)
a2_path <- file.path(data_dir, "metriques_qualite_air_a2.gpkg")
if (file.exists(a2_path)) {
  a2_data <- st_read(a2_path, quiet = TRUE) |> st_drop_geometry()
  if ("A2" %in% names(a2_data)) {
    parcelles$A2 <- as.numeric(unlist(a2_data$A2))
    cat("A2 (qualité air):", round(mean(parcelles$A2, na.rm = TRUE), 1), "\n")
    cat("   0 = forte pollution, 100 = air pur\n")
  }
}

# Sauvegarder
st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n✓ Famille A consolidée:", basename(output_path), "\n")
```


---

### Exercice 10.5 : Synthèse finale

```{r ex-10-5-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-10-5, exercise=TRUE, exercise.eval=FALSE, exercise.lines=55, exercise.setup="ex-10-5-setup"}
# === SYNTHÈSE FINALE ===
# Consolidation de tous les indicateurs LiDAR

output_path <- file.path(data_dir, "indicateurs_lidar.gpkg")
parcelles <- st_read(output_path, quiet = TRUE)

cat("=== SYNTHÈSE INDICATEURS LIDAR ===\n\n")

# Liste des indicateurs par famille (9 indicateurs)
familles <- list(
  "C (Carbone)" = c("C1", "C2"),
  "P (Production)" = c("P1", "P2", "P3"),
  "E (Énergie)" = c("E1", "E2"),
  "A (Air)" = c("A1", "A2")
)

# Afficher les résultats par famille
for (fam in names(familles)) {
  cat("FAMILLE", fam, ":\n")
  for (ind in familles[[fam]]) {
    if (ind %in% names(parcelles)) {
      val <- mean(parcelles[[ind]], na.rm = TRUE)
      cat(sprintf("  - %s: %.1f\n", ind, val))
    } else {
      cat(sprintf("  - %s: non calculé\n", ind))
    }
  }
  cat("\n")
}

# Statistiques globales
indicateurs_calcules <- unlist(familles)
n_calcules <- sum(indicateurs_calcules %in% names(parcelles))
cat(strrep("=", 40), "\n")
cat("Parcelles:", nrow(parcelles), "\n")
cat("Indicateurs:", n_calcules, "/", length(indicateurs_calcules), "\n")
cat("Fichier:", basename(output_path), "\n")
cat(strrep("=", 40), "\n")

# Sauvegarder parcelles.gpkg avec tous les indicateurs
parcelles_path <- file.path(data_dir, "parcelles.gpkg")
st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n✓ Indicateurs LiDAR consolidés\n")
```

### Fichiers produits

| Fichier | Contenu | Indicateurs |
|---------|---------|-------------|
| `indicateurs_lidar.gpkg` | Synthèse complète (9 indicateurs) | Tous |
| `metriques_stock_carbone_c1.gpkg` | Stock carbone aérien | C1 |
| `metriques_vitalite_c2.gpkg` | Vitalité NDVI | C2 |
| `metriques_volume_bois_p1.gpkg` | Volume bois sur pied | P1 |
| `metriques_productivite_p2.gpkg` | Productivité forestière | P2 |
| `metriques_qualite_structurale_p3.gpkg` | Qualité structurale | P3 |
| `metriques_bois_energie_e1.gpkg` | Potentiel bois-énergie | E1 |
| `metriques_evitement_carbone_e2.gpkg` | Évitement carbone | E2 |
| `metriques_couverture_forestiere_a1.gpkg` | Couverture forestière | A1 |
| `metriques_qualite_air_a2.gpkg` | Qualité air | A2 |

---

## Section 11 : Quiz final

### Testez vos connaissances

```{r quiz-final-1, echo=FALSE}
question("Quelle fonction lidR permet de normaliser les hauteurs ?",
  answer("normalize_height()", correct = TRUE),
  answer("standardize_z()"),
  answer("subtract_terrain()"),
  answer("height_correction()"),
  allow_retry = TRUE
)
```

```{r quiz-final-2, echo=FALSE}
question("Qu'est-ce que le MNH (CHM) ?",
  answer("Le Modèle Numérique de Hauteur - hauteur de la canopée", correct = TRUE),
  answer("Le Modèle Numérique Hydrologique"),
  answer("Le Maximum Normalisé des Hauteurs"),
  answer("Le Modèle Naturel Harmonisé"),
  allow_retry = TRUE
)
```

```{r quiz-final-3, echo=FALSE}
question("Quelle métrique représente la hauteur des arbres dominants ?",
  answer("zmean (hauteur moyenne)"),
  answer("zmax (hauteur maximale)"),
  answer("zq95 (percentile 95)", correct = TRUE),
  answer("zsd (écart-type)"),
  allow_retry = TRUE
)
```

```{r quiz-final-4, echo=FALSE}
question("Pourquoi filtrer les points avec Z < 0 après normalisation ?",
  answer("Pour améliorer la vitesse de calcul"),
  answer("Pour supprimer les points sous le sol (erreurs)", correct = TRUE),
  answer("Pour réduire la taille du fichier"),
  answer("Pour ne garder que la végétation haute"),
  allow_retry = TRUE
)
```

```{r quiz-final-5, echo=FALSE}
question("Quelle résolution est recommandée pour le MNH en foresterie ?",
  answer("10 cm"),
  answer("50 cm - 1 m", correct = TRUE),
  answer("5 m"),
  answer("10 m"),
  allow_retry = TRUE
)
```

---

## Synthèse

### Ce que vous avez appris

Dans ce tutoriel, vous avez appris à :

1. ✅ **Charger** des données LiDAR avec `lidR::readLAS()`
2. ✅ **Comprendre** la classification des points (sol, végétation)
3. ✅ **Normaliser** les hauteurs avec `normalize_height()`
4. ✅ **Générer un MNH** avec `rasterize_canopy()`
5. ✅ **Calculer des métriques** par parcelle avec `pixel_metrics()`
6. ✅ **Exporter** les résultats en GeoPackage

### Données produites

Le fichier `parcelles.gpkg` contient désormais vos parcelles enrichies avec :

**Métriques LiDAR** (interpolées depuis `quatre_montagnes`) :

| Métrique | Description |
|----------|-------------|
| **zmax** | Hauteur maximale (m) |
| **zmean** | Hauteur moyenne (m) |
| **zsd** | Écart-type des hauteurs (m) |
| **zq25, zq50, zq75, zq95** | Percentiles de hauteur (m) |
| **zentropy** | Entropie verticale |
| **pzabove2** | Couverture > 2m (%) |

**9 indicateurs nemeton calculés** :

| Code | Indicateur | Formule |
|------|------------|---------|
| **C1** | Stock carbone aérien | AGB × 0.47 |
| **C2** | Séquestration carbone | Score composite (sol, climat, couvert) |
| **P1** | Volume sur pied | k × couvert × zmean × zq95 |
| **P2** | Productivité forestière | zmean × couvert × vigueur |
| **P3** | Qualité structurale | 100 - (entropy + CV) |
| **E1** | Potentiel bois-énergie | pzabove2 × zmean × k |
| **E2** | Évitement carbone | E1 × substitution × rendement |
| **A1** | Couverture forestière | pzabove2 |
| **A2** | Qualité air | 100 - pollution_score |

**Fichiers GeoPackage générés** :

| Fichier | Indicateur |
|---------|------------|
| `metriques_lidar.gpkg` | Métriques LiDAR interpolées |
| `metriques_stock_carbone_c1.gpkg` | C1 |
| `metriques_sequestration_carbone_c2.gpkg` | C2 |
| `metriques_volume_bois_p1.gpkg` | P1 |
| `metriques_productivite_p2.gpkg` | P2 |
| `metriques_qualite_structurale_p3.gpkg` | P3 |
| `metriques_couverture_forestiere_a1.gpkg` | A1 |
| `metriques_qualite_air_a2.gpkg` | A2 |
| `metriques_bois_energie_e1.gpkg` | E1 |
| `metriques_evitement_carbone_e2.gpkg` | E2 |

> **Note** : Les métriques LiDAR sont estimées par interpolation IDW à partir des 28 placettes de référence. Un tutoriel avancé couvrira le calcul direct depuis les nuages de points LiDAR.

### Tutoriel suivant

→ **Tutorial 03 : Terrain** — Familles W, R, S, F (12 indicateurs) : Calculer les indicateurs dérivés du MNT (TWI, pente, exposition), de la BD TOPO (accessibilité, réseau hydro) et des données de risques.

---
title: "Tutorial 02 : LiDAR — Familles C, P, E, A (9 indicateurs)"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Traitement LiDAR HD et calcul de 9 indicateurs : C1 (stock carbone),
  C2 (vitalité NDVI), P1 (volume bois), P2 (productivité), P3 (qualité structurale),
  A1 (couverture forestière), A2 (qualité air), E1/E2 (énergie).
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)

# Configuration gradethis
gradethis::gradethis_setup()

# Options
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)

# Timeout pour les exercices LiDAR (10 min)
options(tutorial.exercise.timelimit = 600)

# Configuration des timeouts réseau (5 minutes)
NETWORK_TIMEOUT <- 300
options(
  timeout = NETWORK_TIMEOUT,
  HTTPUserAgent = "nemeton-tutorial/1.0"
)

# Configuration httr (connect + request timeout)
if (requireNamespace("httr", quietly = TRUE)) {
  httr::set_config(httr::config(
    connecttimeout = NETWORK_TIMEOUT,
    timeout = NETWORK_TIMEOUT
  ))
}

# Configuration GDAL/curl pour happign
Sys.setenv(
  GDAL_HTTP_TIMEOUT = as.character(NETWORK_TIMEOUT),
  GDAL_HTTP_CONNECTTIMEOUT = as.character(NETWORK_TIMEOUT),
  CURL_SSL_BACKEND = "openssl"
)
```

## Bienvenue

### Objectifs du tutoriel

Ce tutoriel vous guide dans le **traitement des données LiDAR** pour extraire des métriques forestières utilisables dans le calcul des indicateurs nemeton.

À la fin de ce tutoriel, vous saurez :

1. **Charger un nuage de points LiDAR** avec lidR
2. **Comprendre la classification** des points (sol, végétation)
3. **Normaliser les hauteurs** par rapport au MNT
4. **Générer un MNH** (Modèle Numérique de Hauteur)
5. **Calculer des métriques** dendrométriques par parcelle
6. **Exporter les résultats** en GeoPackage

### Prérequis

Ce tutoriel nécessite les données acquises dans le **Tutorial 01** :

- `mnt.tif` : Modèle Numérique de Terrain
- `parcelles.gpkg` : Parcelles cadastrales
- `lidar_hd/` : Dalles LiDAR HD téléchargées

### Packages utilisés

```{r packages-info, echo=FALSE}
cat("Packages requis pour ce tutoriel:\n")
cat("- lidR >= 4.0.0 : Traitement nuages de points LiDAR\n")
cat("- terra : Manipulation rasters\n")
cat("- sf : Données vectorielles\n")
cat("- exactextractr : Extraction par polygone\n")
```

### Quiz d'introduction

```{r quiz-intro, echo=FALSE}
question("Qu'est-ce que le LiDAR ?",
  answer("Un capteur radar pour la pluie"),
  answer("Light Detection And Ranging - mesure de distance par laser", correct = TRUE),
  answer("Un format de fichier image"),
  answer("Un logiciel de cartographie"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

```{r quiz-intro-2, echo=FALSE}
question("Que mesure principalement le LiDAR aéroporté en foresterie ?",
  answer("La température des arbres"),
  answer("La hauteur et la structure verticale de la végétation", correct = TRUE),
  answer("L'humidité du sol"),
  answer("La couleur des feuilles"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

```{r quiz-intro-3, echo=FALSE}
question("Qu'est-ce que la normalisation des hauteurs LiDAR ?",
  answer("Convertir les coordonnées en mètres"),
  answer("Soustraire l'altitude du terrain pour obtenir la hauteur au-dessus du sol", correct = TRUE),
  answer("Diviser toutes les hauteurs par 100"),
  answer("Supprimer les points aberrants"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

---

## Section 1 : Introduction au LiDAR

### Principes du LiDAR

Le **LiDAR** (Light Detection And Ranging) est une technologie de télédétection active qui mesure la distance entre un capteur et une surface en émettant des impulsions laser.

**Caractéristiques du LiDAR HD IGN** :
- Densité : **10+ points/m²**
- Précision altimétrique : **< 20 cm**
- Classification automatique : sol, végétation basse, moyenne, haute
- Format : **LAZ** (compressé) ou **COPC** (Cloud Optimized Point Cloud)

### Classification des points

Chaque point LiDAR est classifié selon la norme ASPRS :

| Code | Classe | Description |
|------|--------|-------------|
| 2 | Ground | Sol nu |
| 3 | Low vegetation | Végétation < 0.5m |
| 4 | Medium vegetation | Végétation 0.5-2m |
| 5 | High vegetation | Végétation > 2m |
| 6 | Building | Bâtiments |

### Métriques forestières dérivées

À partir du nuage de points, nous pouvons extraire :

| Métrique | Description | Usage |
|----------|-------------|-------|
| **zmax** | Hauteur maximale | Volume, biomasse |
| **zmean** | Hauteur moyenne | Structure |
| **zsd** | Écart-type des hauteurs | Diversité structurale |
| **zq95** | Percentile 95 | Hauteur dominante |
| **pzabove2** | % points > 2m | Couverture canopée |
| **zentropy** | Entropie verticale | Complexité structurale |

---

## Section 2 : Chargement du nuage de points

### Exercice 2.1 : Charger une dalle LiDAR

Chargeons une dalle LiDAR depuis le cache du Tutorial 01.

```{r ex-2-1-setup}
library(sf)
library(terra)
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-2-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=25, exercise.setup="ex-2-1-setup"}
# === CHARGEMENT D'UNE DALLE LIDAR ===

# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}

# Vérifier si lidR est disponible
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  # Lister les fichiers LiDAR disponibles
  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )

  cat("Fichiers LiDAR disponibles:", length(fichiers_laz), "\n")

  if (length(fichiers_laz) > 0) {
    # Charger le premier fichier
    las <- readLAS(fichiers_laz[1])
    cat("\n=== Informations sur le nuage de points ===\n")
    print(las)
  }
} else {
  cat("Package lidR non installé.\n")
  cat("Installation: install.packages('lidR')\n")
}
```


### Exercice 2.2 : Explorer la structure du nuage

```{r ex-2-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-2-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-2-2-setup"}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )

  if (length(fichiers_laz) > 0) {
    # Charger avec filtre pour réduire la mémoire
    las <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    cat("=== Structure du nuage de points ===\n\n")
    cat("Nombre de points:", nrow(las@data), "\n")
    cat("Attributs disponibles:", paste(names(las@data), collapse = ", "), "\n\n")

    # Statistiques par classification
    cat("=== Distribution par classe ===\n")
    table_class <- table(las@data$Classification)
    print(table_class)

    cat("\n=== Statistiques d'altitude (Z) ===\n")
    cat("Min:", min(las@data$Z), "m\n")
    cat("Max:", max(las@data$Z), "m\n")
    cat("Moyenne:", round(mean(las@data$Z), 1), "m\n")
  }
} else {
  cat("Démonstration avec données simulées:\n")
  cat("Points typiques: 500,000 - 5,000,000 par dalle\n")
  cat("Classes: 2 (sol), 3-5 (végétation), 6 (bâtiments)\n")
}
```

---

## Section 3 : Normalisation des hauteurs

### Pourquoi normaliser ?

Les coordonnées Z brutes du LiDAR sont des **altitudes absolues** (m au-dessus du niveau de la mer). Pour obtenir la **hauteur des arbres**, il faut soustraire l'altitude du terrain.

```
Hauteur arbre = Z_lidar - Z_mnt
```

### Exercice 3.1 : Normaliser avec le MNT

```{r ex-3-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-3-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-3-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")
    cat("Nuage complet:", nrow(las_full@data), "points\n")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    # Pour accélérer le traitement dans ce tutoriel
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    # Clipper sur 20x20m centré
    las <- clip_rectangle(las_full,
      xleft = center_x - 10,
      ybottom = center_y - 10,
      xright = center_x + 10,
      ytop = center_y + 10
    )

    cat("Après clip 20x20m:", nrow(las@data), "points\n\n")

    # Charger le MNT
    mnt <- rast(mnt_path)

    cat("=== Avant normalisation ===\n")
    cat("Z min:", round(min(las@data$Z), 1), "m\n")
    cat("Z max:", round(max(las@data$Z), 1), "m\n")

    # Normalisation (rapide sur 20x20m)
    las_norm <- normalize_height(las, mnt)

    cat("\n=== Après normalisation ===\n")
    cat("Z min:", round(min(las_norm@data$Z), 1), "m\n")
    cat("Z max:", round(max(las_norm@data$Z), 1), "m\n")

    # Filtrer les points négatifs (sous le sol)
    las_clean <- filter_poi(las_norm, Z >= 0)
    cat("\nPoints après filtrage Z >= 0:", nrow(las_clean@data), "\n")
  } else {
    cat("Fichiers non trouvés. Exécutez d'abord le Tutorial 01.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 4 : Génération du MNH

### Modèle Numérique de Hauteur (MNH)

Le **MNH** (ou CHM - Canopy Height Model) est un raster représentant la hauteur de la canopée en chaque pixel.

### Exercice 4.1 : Créer le MNH

```{r ex-4-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-4-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-4-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    las <- clip_rectangle(las_full,
      xleft = center_x - 10,
      ybottom = center_y - 10,
      xright = center_x + 10,
      ytop = center_y + 10
    )

    cat("Zone 20x20m:", nrow(las@data), "points\n")

    # Normaliser
    mnt <- rast(mnt_path)
    las_norm <- normalize_height(las, mnt)
    las_clean <- filter_poi(las_norm, Z >= 0 & Z < 60)

    # Générer le MNH (résolution 1m)
    cat("\n=== Génération du MNH ===\n")
    mnh <- rasterize_canopy(las_clean, res = 1, algorithm = p2r())

    cat("Dimensions:", nrow(mnh), "x", ncol(mnh), "pixels\n")
    cat("Résolution:", res(mnh)[1], "m\n")

    # Statistiques
    stats <- global(mnh, c("min", "max", "mean", "sd"), na.rm = TRUE)
    cat("\n=== Statistiques MNH ===\n")
    cat("Hauteur min:", round(stats$min, 1), "m\n")
    cat("Hauteur max:", round(stats$max, 1), "m\n")
    cat("Hauteur moyenne:", round(stats$mean, 1), "m\n")

    # Sauvegarder (exemple sur zone réduite)
    mnh_path <- file.path(data_dir, "mnh_sample.tif")
    writeRaster(mnh, mnh_path, overwrite = TRUE)
    cat("\nMNH échantillon sauvegardé:", mnh_path, "\n")
  } else {
    cat("Fichiers non trouvés.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 5 : Métriques par parcelle

### Exercice 5.1 : Calculer les métriques LiDAR

```{r ex-5-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-5-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-5-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir,
    pattern = "\\.laz$",
    full.names = TRUE, recursive = TRUE
  )
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    las <- clip_rectangle(las_full,
      xleft = center_x - 10,
      ybottom = center_y - 10,
      xright = center_x + 10,
      ytop = center_y + 10
    )

    cat("Zone 20x20m:", nrow(las@data), "points\n")

    # Normaliser
    mnt <- rast(mnt_path)
    las_norm <- normalize_height(las, mnt)
    las_clean <- filter_poi(las_norm, Z >= 0 & Z < 60)

    # Calculer par pixel (raster 2m pour zone 20x20m)
    # Utiliser une fonction anonyme inline pour éviter les problèmes de scope
    cat("\n=== Calcul des métriques raster ===\n")
    metrics_raster <- pixel_metrics(las_clean, ~ list(
      zmax = max(Z, na.rm = TRUE),
      zmean = mean(Z, na.rm = TRUE),
      zsd = sd(Z, na.rm = TRUE),
      zq95 = quantile(Z, 0.95, na.rm = TRUE),
      pzabove2 = sum(Z > 2, na.rm = TRUE) / length(Z) * 100
    ), res = 2)

    cat("Couches générées:", names(metrics_raster), "\n")
    cat("Dimensions:", nrow(metrics_raster), "x", ncol(metrics_raster), "pixels\n")

    # Statistiques globales sur la zone
    cat("\n=== Statistiques sur la zone 20x20m ===\n")
    cat("Hauteur max (zmax):", round(max(values(metrics_raster$zmax), na.rm = TRUE), 1), "m\n")
    cat("Hauteur moyenne (zmean):", round(mean(values(metrics_raster$zmean), na.rm = TRUE), 1), "m\n")
    cat("Percentile 95 (zq95):", round(mean(values(metrics_raster$zq95), na.rm = TRUE), 1), "m\n")
    cat("Couverture > 2m:", round(mean(values(metrics_raster$pzabove2), na.rm = TRUE), 1), "%\n")
  } else {
    cat("Fichiers non trouvés.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 6 : Export des résultats

### Exercice 6.1 : Sauvegarder les métriques

Dans ce tutoriel, nous utilisons les **métriques LiDAR pré-calculées** du jeu de données `quatre_montagnes` (package `lidaRtRee`). Ces 28 placettes contiennent des valeurs réelles de zmean, zmax, zsd, etc.

Pour estimer les métriques sur les parcelles cadastrales, nous appliquons un **krigeage** (interpolation spatiale) à partir des placettes. Cette méthode permet d'obtenir des estimations cohérentes spatialement.

> **Note** : Le calcul direct des métriques LiDAR à partir des nuages de points sera traité dans un tutoriel avancé dédié au traitement LiDAR complet.

```{r ex-6-1-setup}
library(sf)
library(terra)
library(lidaRtRee)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=85, exercise.setup="ex-6-1-setup"}
# === INTERPOLATION DES MÉTRIQUES LIDAR PAR KRIGEAGE ===
# Utilisation des données réelles de quatre_montagnes (lidaRtRee)

# Charger les placettes avec métriques LiDAR
data("quatre_montagnes", package = "lidaRtRee")

# Filtrer sur les clusters Centre (même zone que Tutorial 01)
clusters_centre <- c(
  "Verc-C1", "Verc-S4", "Verc-02", "Verc-S7",
  "Verc-C4", "Verc-C2", "Verc-05"
)
qm_centre <- quatre_montagnes[quatre_montagnes$cluster_id %in% clusters_centre, ]

# Convertir en sf
placettes_sf <- st_as_sf(qm_centre, coords = c("X", "Y"), crs = 2154)

cat("=== Données source : quatre_montagnes ===\n")
cat("Placettes avec métriques LiDAR:", nrow(placettes_sf), "\n\n")

# Métriques LiDAR à interpoler
metriques <- c(
  "zmax", "zmean", "zsd", "zq25", "zq50", "zq75", "zq95",
  "zentropy", "pzabove2"
)

cat("Métriques disponibles:\n")
for (m in metriques) {
  if (m %in% names(placettes_sf)) {
    vals <- qm_centre[[m]]
    cat(sprintf(
      "  %s: %.1f - %.1f (moy: %.1f)\n",
      m, min(vals, na.rm = TRUE), mean(vals, na.rm = TRUE), max(vals, na.rm = TRUE)
    ))
  }
}

# Charger les parcelles cadastrales
parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  # Calculer les centroïdes des parcelles
  centroids <- st_centroid(parcelles)

  cat("\n=== Interpolation par IDW (Inverse Distance Weighting) ===\n")
  cat("Parcelles cibles:", nrow(parcelles), "\n\n")

  # Fonction d'interpolation IDW simple
  idw_interpolate <- function(points_sf, target_sf, variable, power = 2) {
    # Extraire coordonnées
    coords_src <- st_coordinates(points_sf)
    coords_tgt <- st_coordinates(target_sf)
    values <- points_sf[[variable]]

    # Pour chaque point cible
    result <- sapply(seq_len(nrow(coords_tgt)), function(i) {
      # Distances aux points source
      distances <- sqrt((coords_src[, 1] - coords_tgt[i, 1])^2 +
        (coords_src[, 2] - coords_tgt[i, 2])^2)
      # Éviter division par zéro
      distances[distances < 1] <- 1
      # Poids IDW
      weights <- 1 / (distances^power)
      # Moyenne pondérée
      sum(values * weights, na.rm = TRUE) / sum(weights, na.rm = TRUE)
    })
    return(result)
  }

  # Interpoler chaque métrique
  cat("Interpolation en cours...\n")
  for (m in metriques) {
    if (m %in% names(placettes_sf)) {
      parcelles[[m]] <- idw_interpolate(placettes_sf, centroids, m)
      cat(sprintf("  %s interpolé\n", m))
    }
  }

  # Sauvegarder
  output_path <- file.path(data_dir, "metriques_lidar.gpkg")
  st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
  st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
  cat("\n=== Métriques LiDAR exportées ===\n")
  cat("Fichier:", output_path, "\n")
  cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")

  # Résumé des métriques interpolées
  cat("=== Résumé des métriques interpolées ===\n")
  cat("Métrique       Min      Moy      Max\n")
  cat("--------------------------------------\n")
  for (m in metriques) {
    if (m %in% names(parcelles)) {
      cat(sprintf(
        "%-12s %7.1f %8.1f %8.1f\n",
        m, min(parcelles[[m]], na.rm = TRUE),
        mean(parcelles[[m]], na.rm = TRUE),
        max(parcelles[[m]], na.rm = TRUE)
      ))
    }
  }
} else {
  cat("Parcelles non trouvées. Exécutez le Tutorial 01.\n")
}
```


---

## Section 7 : Indicateurs Carbone, Production et Air (C1, P1, P2, P3, A1)

### Introduction aux familles C, P, A

Les métriques LiDAR permettent de calculer directement plusieurs indicateurs du référentiel nemeton :

- **C1** (Carbone) : Stock de biomasse aérienne (tC/ha)
- **P1** (Production) : Volume de bois sur pied (m³/ha)
- **P2** (Production) : Productivité forestière (m³/ha/an)
- **P3** (Production) : Qualité structurale du peuplement (score 0-100)
- **A1** (Air) : Couverture forestière et interception (%)

```{r indicateurs-cpa-concept, echo=FALSE}
indics_cpa <- data.frame(
  Indicateur = c("C1", "P1", "P2", "P3", "A1"),
  Nom = c("Stock carbone biomasse", "Volume bois sur pied", "Productivité forestière", "Qualité structurale", "Couverture forestière"),
  Unite = c("tC/ha", "m³/ha", "m³/ha/an", "score 0-100", "%"),
  Source = c("zmean, zmax, pzabove2", "zmean, zmax, pzabove2", "zmean, pzabove2, zq95, zq25", "zentropy, zsd", "pzabove2")
)
knitr::kable(indics_cpa, caption = "Indicateurs dérivés des métriques LiDAR")
```

### Exercice 7.1 : Calculer C1 (Stock carbone)

L'indicateur **C1** estime le stock de carbone aérien à partir de la biomasse forestière :

$$C1 = AGB \times 0.47$$

Où AGB (Above Ground Biomass) est estimée par une équation allométrique simplifiée :

$$AGB = k \times (pzabove2/100) \times zmean^{1.5}$$

```{r ex-7-1-c1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-1-c1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-7-1-c1-setup"}
# === CALCUL DE C1 : STOCK CARBONE BIOMASSE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de C1 (Stock carbone) ===\n\n")

  if (all(c("pzabove2", "zmean") %in% names(parcelles))) {
    # Paramètres du modèle allométrique simplifié
    k_biomasse <- 2.5  # Facteur de calibration (t/ha)
    fraction_carbone <- 0.47  # Fraction carbone dans la biomasse

    # Estimation de la biomasse aérienne (AGB)
    # Modèle simplifié basé sur couverture et hauteur
    parcelles$AGB <- k_biomasse * (parcelles$pzabove2 / 100) * (parcelles$zmean^1.5)

    # Stock carbone = AGB × fraction carbone
    parcelles$C1 <- parcelles$AGB * fraction_carbone

    cat("Formule: C1 = k × (pzabove2/100) × zmean^1.5 × 0.47\n")
    cat("k_biomasse =", k_biomasse, "t/ha\n\n")

    cat("=== Résultats C1 ===\n")
    cat("C1 min:", round(min(parcelles$C1, na.rm = TRUE), 1), "tC/ha\n")
    cat("C1 moy:", round(mean(parcelles$C1, na.rm = TRUE), 1), "tC/ha\n")
    cat("C1 max:", round(max(parcelles$C1, na.rm = TRUE), 1), "tC/ha\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ C1 ajouté aux parcelles\n")
  } else {
    cat("Métriques pzabove2 et zmean non trouvées.\n")
    cat("Exécutez l'exercice 6.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.2 : Calculer P1 (Volume de bois)

L'indicateur **P1** estime le volume de bois sur pied :

$$P1 = k_{vol} \times (pzabove2/100) \times zmean \times zmax^{0.5}$$

```{r ex-7-2-p1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-2-p1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=40, exercise.setup="ex-7-2-p1-setup"}
# === CALCUL DE P1 : VOLUME DE BOIS SUR PIED ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de P1 (Volume bois) ===\n\n")

  if (all(c("pzabove2", "zmean", "zmax") %in% names(parcelles))) {
    # Facteur de conversion volume (m³/ha)
    k_volume <- 15

    # Estimation du volume sur pied
    parcelles$P1 <- k_volume * (parcelles$pzabove2 / 100) *
                    parcelles$zmean * sqrt(parcelles$zmax)

    cat("Formule: P1 = k × (pzabove2/100) × zmean × √zmax\n")
    cat("k_volume =", k_volume, "\n\n")

    cat("=== Résultats P1 ===\n")
    cat("P1 min:", round(min(parcelles$P1, na.rm = TRUE), 1), "m³/ha\n")
    cat("P1 moy:", round(mean(parcelles$P1, na.rm = TRUE), 1), "m³/ha\n")
    cat("P1 max:", round(max(parcelles$P1, na.rm = TRUE), 1), "m³/ha\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ P1 ajouté aux parcelles\n")
  } else {
    cat("Métriques pzabove2, zmean et zmax non trouvées.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.3 : Calculer P2 (Productivité forestière)

L'indicateur **P2** estime la productivité forestière basée sur les métriques LiDAR :
- **zmean** : Hauteur moyenne (indicateur de qualité de station)
- **pzabove2** : Couverture forestière (densité du peuplement)
- **zq95, zq25** : Distribution des hauteurs (vigueur de croissance)

$$P2 = k_{prod} \times zmean \times (pzabove2/100) \times (1 + \frac{zq95 - zq25}{zmean})$$

```{r ex-7-3-p2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-3-p2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-7-3-p2-setup"}
# === CALCUL DE P2 : PRODUCTIVITÉ FORESTIÈRE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de P2 (Productivité forestière) ===\n\n")

  if (all(c("zmean", "pzabove2", "zq95", "zq25") %in% names(parcelles))) {
    # Facteur de productivité (m³/ha/an équivalent)
    k_prod <- 0.8

    # Indice de vigueur : ratio hauteur dominante / hauteur moyenne
    vigueur <- (parcelles$zq95 - parcelles$zq25) / parcelles$zmean
    vigueur <- pmax(0.1, pmin(2, vigueur))  # Borner entre 0.1 et 2

    # P2 : Productivité = hauteur × couverture × vigueur
    parcelles$P2 <- k_prod * parcelles$zmean *
                    (parcelles$pzabove2 / 100) *
                    (1 + vigueur)

    cat("Formule: P2 = k × zmean × (pzabove2/100) × (1 + vigueur)\n")
    cat("k_prod =", k_prod, "\n")
    cat("vigueur = (zq95 - zq25) / zmean\n\n")

    cat("=== Résultats P2 ===\n")
    cat("P2 min:", round(min(parcelles$P2, na.rm = TRUE), 2), "m³/ha/an\n")
    cat("P2 moy:", round(mean(parcelles$P2, na.rm = TRUE), 2), "m³/ha/an\n")
    cat("P2 max:", round(max(parcelles$P2, na.rm = TRUE), 2), "m³/ha/an\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ P2 ajouté aux parcelles\n")
  } else {
    cat("Métriques zmean, pzabove2, zq95 et zq25 non trouvées.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.4 : Calculer P3 (Qualité structurale)

L'indicateur **P3** évalue la qualité structurale du peuplement basée sur :
- **zentropy** : Entropie verticale (diversité des strates)
- **zsd** : Écart-type des hauteurs (hétérogénéité)

Un peuplement de haute qualité a une structure régulière (faible entropie, faible variabilité).

```{r ex-7-4-p3-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-4-p3, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-7-4-p3-setup"}
# === CALCUL DE P3 : QUALITÉ STRUCTURALE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de P3 (Qualité structurale) ===\n\n")

  if (all(c("zentropy", "zsd", "zmean") %in% names(parcelles))) {
    # Normaliser zentropy (0-1) - valeurs typiques entre 0.5 et 1
    entropy_norm <- (parcelles$zentropy - 0.5) / 0.5
    entropy_norm <- pmax(0, pmin(1, entropy_norm))

    # Coefficient de variation (CV = sd/mean)
    cv <- parcelles$zsd / parcelles$zmean
    cv_norm <- pmin(1, cv / 0.5)  # Normaliser sur CV max de 0.5

    # P3 : qualité = régularité (inverse de l'hétérogénéité)
    # Score élevé = peuplement régulier, homogène
    parcelles$P3 <- 100 * (1 - 0.5 * entropy_norm - 0.5 * cv_norm)
    parcelles$P3 <- pmax(0, pmin(100, parcelles$P3))

    cat("Formule: P3 = 100 × (1 - 0.5×entropy_norm - 0.5×cv_norm)\n\n")

    cat("=== Résultats P3 ===\n")
    cat("P3 min:", round(min(parcelles$P3, na.rm = TRUE), 1), "\n")
    cat("P3 moy:", round(mean(parcelles$P3, na.rm = TRUE), 1), "\n")
    cat("P3 max:", round(max(parcelles$P3, na.rm = TRUE), 1), "\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ P3 ajouté aux parcelles\n")
  } else {
    cat("Métriques zentropy, zsd et zmean non trouvées.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Exercice 7.5 : Calculer A1 (Couverture forestière)

L'indicateur **A1** mesure la couverture forestière qui influence :
- L'interception des précipitations
- La régulation du microclimat
- La qualité de l'air local

```{r ex-7-5-a1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-5-a1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=35, exercise.setup="ex-7-5-a1-setup"}
# === CALCUL DE A1 : COUVERTURE FORESTIÈRE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de A1 (Couverture forestière) ===\n\n")

  if ("pzabove2" %in% names(parcelles)) {
    # A1 = couverture forestière > 2m (déjà en %)
    parcelles$A1 <- parcelles$pzabove2

    cat("A1 = pzabove2 (couverture > 2m en %)\n\n")

    cat("=== Résultats A1 ===\n")
    cat("A1 min:", round(min(parcelles$A1, na.rm = TRUE), 1), "%\n")
    cat("A1 moy:", round(mean(parcelles$A1, na.rm = TRUE), 1), "%\n")
    cat("A1 max:", round(max(parcelles$A1, na.rm = TRUE), 1), "%\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ A1 ajouté aux parcelles\n")
  } else {
    cat("Métrique pzabove2 non trouvée.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

---

## Section 8 : Indicateurs Énergie (E1, E2)

### Introduction à la famille Énergie

La **famille Énergie (E)** du référentiel nemeton quantifie le potentiel énergétique de la forêt :

- **E1** : Potentiel de production de bois-énergie (tep/ha/an)
- **E2** : Évitement carbone par substitution aux énergies fossiles (tCO₂/ha/an)

La biomasse forestière peut se substituer aux énergies fossiles :

- Chauffage (bois bûche, plaquettes, granulés)
- Cogénération (électricité + chaleur)
- Biocarburants de 2ème génération


```{r energie-concept, echo=FALSE}
substitution <- data.frame(
  Indicateur = c("E1", "E2"),
  Nom = c("Potentiel bois-énergie", "Évitement carbone"),
  Unite = c("tep/ha/an", "tCO₂/ha/an"),
  Source = c("pzabove2, zmean", "E1 × facteur substitution")
)
knitr::kable(substitution, caption = "Indicateurs de la famille Énergie")
```

### Exercice 7.1 : Calculer E1 (Bois-énergie)

L'indicateur **E1** estime le potentiel de production de bois-énergie à partir des métriques LiDAR :

- **pzabove2** : Couverture forestière > 2m (%)
- **zmean** : Hauteur moyenne de la canopée (m)

$$E1 = \frac{pzabove2}{100} \times zmean \times k_{conversion}$$

Où $k_{conversion}$ ≈ 0.015 tep/m/ha/an (tonne équivalent pétrole)

```{r ex-7-1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-7-1-setup"}
# === CALCUL DE E1 : POTENTIEL BOIS-ÉNERGIE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de E1 (Bois-énergie) ===\n\n")

  # Vérifier les métriques nécessaires
  if (all(c("pzabove2", "zmean") %in% names(parcelles))) {
    # Facteur de conversion (tep/m/ha/an)
    # Basé sur productivité moyenne et pouvoir calorifique du bois
    k_conversion <- 0.015

    # Calcul E1
    parcelles$E1 <- (parcelles$pzabove2 / 100) * parcelles$zmean * k_conversion

    cat("Formule: E1 = (pzabove2/100) × zmean × k_conversion\n")
    cat("k_conversion =", k_conversion, "tep/m/ha/an\n\n")

    cat("=== Résultats E1 ===\n")
    cat("E1 min:", round(min(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n")
    cat("E1 moy:", round(mean(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n")
    cat("E1 max:", round(max(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ E1 ajouté aux parcelles\n")
  } else {
    cat("Métriques pzabove2 et zmean non trouvées.\n")
    cat("Exécutez l'exercice 6.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
  cat("Exécutez le Tutorial 01 d'abord.\n")
}
```

### Exercice 7.2 : Calculer E2 (Évitement carbone)

L'indicateur **E2** quantifie les **émissions de CO₂ évitées** grâce à la substitution du bois aux énergies fossiles :

$$E2 = E1 \times f_{substitution} \times \eta_{conversion}$$

Où :
- $E1$ : Production énergétique potentielle (tep/ha/an)
- $f_{substitution}$ ≈ 2.5 tCO₂/tep (facteur moyen de substitution)
- $\eta_{conversion}$ ≈ 0.85 (rendement des chaufferies bois)

```{r e2-table, echo=FALSE}
substitution <- data.frame(
  Combustible_Remplace = c("Fioul domestique", "Gaz naturel", "Charbon", "Électricité (mix FR)"),
  tCO2_evite_par_tep = c(2.9, 2.3, 3.4, 0.5),
  Usage_Typique = c("Chauffage individuel", "Chauffage collectif", "Industrie", "Pointe")
)
knitr::kable(substitution, caption = "Facteurs de substitution carbone par combustible")
```

```{r ex-7-2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-7-2-setup"}
# === CALCUL DE E2 : ÉVITEMENT CARBONE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de E2 (Évitement carbone) ===\n\n")

  # Vérifier que E1 existe
  if ("E1" %in% names(parcelles)) {
    # Paramètres de calcul
    facteur_substitution <- 2.5 # tCO2 évitées par tep de bois-énergie
    rendement_conversion <- 0.85 # Efficacité moyenne des chaufferies

    cat("Paramètres:\n")
    cat("  Facteur substitution:", facteur_substitution, "tCO2/tep\n")
    cat("  Rendement conversion:", rendement_conversion, "\n\n")

    # Calcul E2
    parcelles$E2 <- parcelles$E1 * facteur_substitution * rendement_conversion

    cat("Formule: E2 = E1 × f_substitution × η_conversion\n\n")

    cat("=== Résultats E2 ===\n")
    cat("E2 min:", round(min(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n")
    cat("E2 moy:", round(mean(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n")
    cat("E2 max:", round(max(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n\n")

    # Évitement total sur la zone
    parcelles$evitement_total <- parcelles$E2 * parcelles$surface_ha
    total_evitement <- sum(parcelles$evitement_total, na.rm = TRUE)
    cat("Évitement total zone:", round(total_evitement, 1), "tCO2/an\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ E2 ajouté aux parcelles\n")

    # Visualisation
    cat("\n=== Distribution E2 ===\n")
    hist(parcelles$E2,
      breaks = 15, col = "darkorange",
      main = "E2 : Évitement carbone",
      xlab = "tCO2/ha/an", ylab = "Fréquence"
    )
  } else {
    cat("E1 non trouvé. Exécutez l'exercice 7.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Interprétation de l'histogramme E2

L'histogramme **E2 : Évitement carbone** montre la distribution des émissions de CO₂ évitées par parcelle, exprimées en **tCO₂/ha/an**.

**Ce que représente E2** : le bénéfice climatique potentiel si le bois de la parcelle était utilisé comme source d'énergie à la place des combustibles fossiles (fioul, gaz, charbon).

=== Grille d'interprétation E2 ===

```{r e2-interpretation, echo=FALSE}
interpretation <- data.frame(
  Valeur_E2 = c("0 - 0.5", "0.5 - 1.5", "> 1.5"),
  Interpretation = c(
    "Faible potentiel (parcelle peu productive ou jeune)",
    "Potentiel modéré (forêt moyenne)",
    "Fort potentiel (forêt productive, mature)"
  )
)
knitr::kable(interpretation, col.names = c("E2 (tCO2/ha/an)", "Interprétation"))
```

=== Exemple concret ===

Une parcelle avec E2 = 1.0 tCO2/ha/an signifie :

- 1 tonne de CO2 évitée par hectare chaque année
- Sur 10 ha : 10 tCO2/an évitées
- Équivalent à ~5 allers-retours Paris-New York en avion

=== Forme de la distribution ===

- Étalée à droite : quelques parcelles très productives
- Pic à gauche : beaucoup de jeunes peuplements
- Normale : forêt homogène en productivité

### Quiz : Indicateurs Énergie

```{r quiz-energie-1, echo=FALSE}
question("Que représente l'indicateur E1 ?",
  answer("Le stock de carbone"),
  answer("Le potentiel de production bois-énergie", correct = TRUE),
  answer("L'évitement d'émissions CO2"),
  answer("La consommation énergétique"),
  allow_retry = TRUE
)
```

```{r quiz-energie-2, echo=FALSE}
question("Quelle unité est utilisée pour E2 ?",
  answer("kWh/ha/an"),
  answer("tep/ha/an"),
  answer("tCO2/ha/an", correct = TRUE),
  answer("m³/ha/an"),
  allow_retry = TRUE
)
```

```{r quiz-energie-3, echo=FALSE}
question("Quel facteur n'influence PAS le calcul de E2 ?",
  answer("Le potentiel E1"),
  answer("Le facteur de substitution"),
  answer("Le rendement de conversion"),
  answer("La pente du terrain", correct = TRUE),
  allow_retry = TRUE
)
```

---

## Section 9 : Indicateurs Vitalité et Air (C2, A2)

### Introduction aux indicateurs C2 et A2

Ces indicateurs complètent l'analyse LiDAR avec des données complémentaires :

- **C2** (Vitalité) : Indice NDVI mesurant la vitalité de la végétation
- **A2** (Air) : Qualité de l'air basée sur l'éloignement des sources de pollution

```{r indicateurs-c2a2-concept, echo=FALSE}
indics_c2a2 <- data.frame(
  Indicateur = c("C2", "A2"),
  Nom = c("Vitalité végétation (NDVI)", "Qualité de l'air forestier"),
  Unite = c("score 0-100", "score 0-100"),
  Source = c("Sentinel-2 / BD Forêt", "Distance routes (BD TOPO)")
)
knitr::kable(indics_c2a2, caption = "Indicateurs de vitalité et qualité de l'air")
```

### Exercice 9.1 : Indice de Vitalité NDVI (C2)

L'indicateur **C2** mesure la **vitalité de la végétation** via l'indice NDVI (Normalized Difference Vegetation Index).

**Sources de données (par ordre de priorité) :**

| Priorité | Source | Description |
|----------|--------|-------------|
| 1 | Sentinel-2 | Bandes B4/B8 via STAC API |
| 2 | BD Forêt | Estimation par type de peuplement |

**Formule NDVI :**

$$NDVI = \frac{NIR - Rouge}{NIR + Rouge}$$

| NDVI | Interprétation |
|------|----------------|
| < 0.2 | Sol nu, urbain |
| 0.2 - 0.4 | Végétation clairsemée |
| 0.4 - 0.6 | Végétation modérée |
| 0.6 - 0.8 | Végétation dense |
| > 0.8 | Végétation très dense |

```{r ex-9-1-c2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-9-1-c2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=80, exercise.setup="ex-9-1-c2-setup", exercise.timelimit=600}
# === INDICATEUR C2 (NDVI - VITALITÉ VÉGÉTATION) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
parcelles <- st_read(parcelles_path, quiet = TRUE)

cat("=== Indicateur C2 : NDVI (Vitalité) ===\n\n")

bd_foret_path <- file.path(data_dir, "bd_foret.gpkg")

# Valeur par défaut
parcelles$C2 <- 0.5

# Estimation basée sur BD Forêt et métriques LiDAR
cat("Estimation via BD Forêt et LiDAR...\n")

if (file.exists(bd_foret_path)) {
  bd_foret <- st_read(bd_foret_path, quiet = TRUE)
  bd_foret <- st_transform(bd_foret, st_crs(parcelles))

  # Coefficients NDVI par type de peuplement
  ndvi_by_type <- data.frame(
    pattern = c("feuill", "resin", "conif", "mixte", "taillis", "lande", "peupl"),
    ndvi_base = c(0.72, 0.65, 0.65, 0.68, 0.60, 0.45, 0.70),
    stringsAsFactors = FALSE
  )

  # Calcul simplifié par parcelle
  for (i in seq_len(nrow(parcelles))) {
    geom <- st_geometry(parcelles)[i]
    foret_inter <- suppressWarnings(
      tryCatch(st_intersection(bd_foret, geom), error = function(e) NULL)
    )

    if (!is.null(foret_inter) && nrow(foret_inter) > 0) {
      type_col <- intersect(names(foret_inter), c("tfv", "essence", "libelle", "code_tfv"))
      if (length(type_col) > 0) {
        type_val <- tolower(as.character(foret_inter[[type_col[1]]][1]))
        for (j in seq_len(nrow(ndvi_by_type))) {
          if (grepl(ndvi_by_type$pattern[j], type_val)) {
            parcelles$C2[i] <- ndvi_by_type$ndvi_base[j] + rnorm(1, 0, 0.05)
            break
          }
        }
      }
    }
  }
} else {
  cat("BD Forêt non trouvée - utilisation des métriques LiDAR\n")
}

# Ajustement avec pzabove2 (couverture LiDAR) si disponible
if ("pzabove2" %in% names(parcelles)) {
  parcelles$C2 <- parcelles$C2 * (0.7 + 0.3 * parcelles$pzabove2 / 100)
  cat("Ajusté avec couverture LiDAR (pzabove2)\n")
}

# Borner entre 0 et 1
parcelles$C2 <- pmax(0, pmin(1, parcelles$C2))

# Convertir en score 0-100
parcelles$C2_score <- parcelles$C2 * 100

cat("\n=== Résultats C2 ===\n")
cat("NDVI min:", round(min(parcelles$C2, na.rm = TRUE), 3), "\n")
cat("NDVI max:", round(max(parcelles$C2, na.rm = TRUE), 3), "\n")
cat("NDVI moyen:", round(mean(parcelles$C2, na.rm = TRUE), 3), "\n")
cat("C2 score moyen:", round(mean(parcelles$C2_score, na.rm = TRUE), 1), "/ 100\n")

# Sauvegarder
st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n✓ C2 ajouté aux parcelles\n")
```

### Exercice 9.2 : Qualité de l'air (A2)

L'indicateur **A2** évalue la **qualité de l'air** basée sur l'éloignement des sources de pollution (routes).

| Facteur | Description | Impact |
|---------|-------------|--------|
| **Distance routes** | Éloignement des axes routiers | Pollution atmosphérique |
| **Type de route** | Autoroute vs chemin | Niveau d'émissions |

```{r ex-9-2-a2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-9-2-a2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=70, exercise.setup="ex-9-2-a2-setup", exercise.timelimit=300}
# === INDICATEUR A2 (QUALITÉ AIR FORESTIER) ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")
routes_path <- file.path(data_dir, "routes.gpkg")

parcelles <- st_read(parcelles_path, quiet = TRUE)

cat("=== Indicateur A2 : Qualité air forestier ===\n\n")

# Coefficients de pollution par type de route
pollution_weights <- data.frame(
  nature = c("Autoroute", "Quasi-autoroute", "Route à 2 chaussées",
             "Route à 1 chaussée", "Route empierrée", "Chemin", "Sentier"),
  poids = c(1.0, 0.9, 0.8, 0.6, 0.3, 0.1, 0.02),
  stringsAsFactors = FALSE
)

if (file.exists(routes_path)) {
  routes <- st_read(routes_path, quiet = TRUE)
  routes <- st_transform(routes, st_crs(parcelles))
  cat("Routes chargées:", nrow(routes), "segments\n")

  # Assigner les poids aux routes
  routes$pollution_weight <- 0.5
  nature_field <- intersect(names(routes), c("nature", "NATURE", "classe", "type"))[1]
  if (!is.na(nature_field)) {
    for (i in seq_len(nrow(pollution_weights))) {
      mask <- grepl(pollution_weights$nature[i], routes[[nature_field]], ignore.case = TRUE)
      routes$pollution_weight[mask] <- pollution_weights$poids[i]
    }
  }

  # Calcul distance pondérée par parcelle
  parcelles_centroids <- st_centroid(parcelles)
  routes_union <- st_union(routes)

  parcelles$dist_routes <- as.numeric(st_distance(parcelles_centroids, routes_union))

  # Score pollution basé sur la distance
  max_dist <- 2000  # Distance max d'influence
  pollution_score <- pmax(0, 1 - parcelles$dist_routes / max_dist)

  # A2 = inverse de la pollution (0 = pollué, 100 = air pur)
  parcelles$A2 <- round((1 - pollution_score) * 100, 1)
} else {
  cat("Routes non disponibles - valeurs par défaut\n")
  parcelles$dist_routes <- 500
  parcelles$A2 <- 75
}

# Borner [0, 100]
parcelles$A2 <- pmax(0, pmin(100, parcelles$A2))

cat("\n=== Résultats A2 ===\n")
cat("A2 moyen:", round(mean(parcelles$A2, na.rm = TRUE), 1), "/ 100\n")
cat("A2 min:", round(min(parcelles$A2, na.rm = TRUE), 1), "\n")
cat("A2 max:", round(max(parcelles$A2, na.rm = TRUE), 1), "\n")
cat("Distance moyenne aux routes:", round(mean(parcelles$dist_routes, na.rm = TRUE)), "m\n")

# Sauvegarder
st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
cat("\n✓ A2 ajouté aux parcelles\n")
```

---

## Section 10 : Quiz final

### Testez vos connaissances

```{r quiz-final-1, echo=FALSE}
question("Quelle fonction lidR permet de normaliser les hauteurs ?",
  answer("normalize_height()", correct = TRUE),
  answer("standardize_z()"),
  answer("subtract_terrain()"),
  answer("height_correction()"),
  allow_retry = TRUE
)
```

```{r quiz-final-2, echo=FALSE}
question("Qu'est-ce que le MNH (CHM) ?",
  answer("Le Modèle Numérique de Hauteur - hauteur de la canopée", correct = TRUE),
  answer("Le Modèle Numérique Hydrologique"),
  answer("Le Maximum Normalisé des Hauteurs"),
  answer("Le Modèle Naturel Harmonisé"),
  allow_retry = TRUE
)
```

```{r quiz-final-3, echo=FALSE}
question("Quelle métrique représente la hauteur des arbres dominants ?",
  answer("zmean (hauteur moyenne)"),
  answer("zmax (hauteur maximale)"),
  answer("zq95 (percentile 95)", correct = TRUE),
  answer("zsd (écart-type)"),
  allow_retry = TRUE
)
```

```{r quiz-final-4, echo=FALSE}
question("Pourquoi filtrer les points avec Z < 0 après normalisation ?",
  answer("Pour améliorer la vitesse de calcul"),
  answer("Pour supprimer les points sous le sol (erreurs)", correct = TRUE),
  answer("Pour réduire la taille du fichier"),
  answer("Pour ne garder que la végétation haute"),
  allow_retry = TRUE
)
```

```{r quiz-final-5, echo=FALSE}
question("Quelle résolution est recommandée pour le MNH en foresterie ?",
  answer("10 cm"),
  answer("50 cm - 1 m", correct = TRUE),
  answer("5 m"),
  answer("10 m"),
  allow_retry = TRUE
)
```

---

## Synthèse

### Ce que vous avez appris

Dans ce tutoriel, vous avez appris à :

1. ✅ **Charger** des données LiDAR avec `lidR::readLAS()`
2. ✅ **Comprendre** la classification des points (sol, végétation)
3. ✅ **Normaliser** les hauteurs avec `normalize_height()`
4. ✅ **Générer un MNH** avec `rasterize_canopy()`
5. ✅ **Calculer des métriques** par parcelle avec `pixel_metrics()`
6. ✅ **Exporter** les résultats en GeoPackage

### Données produites

Le fichier `metriques_lidar.gpkg` contient désormais vos parcelles avec les métriques interpolées depuis `quatre_montagnes` :

| Métrique | Description | Indicateurs |
|----------|-------------|-------------|
| **zmax** | Hauteur maximale (m) | C1, P1 |
| **zmean** | Hauteur moyenne (m) | P3 |
| **zsd** | Écart-type des hauteurs (m) | B2 |
| **zq25** | Percentile 25 (m) | Structure |
| **zq50** | Percentile 50 / médiane (m) | Structure |
| **zq75** | Percentile 75 (m) | Structure |
| **zq95** | Percentile 95 (m) | P1 |
| **zentropy** | Entropie verticale | B2 |
| **pzabove2** | Couverture > 2m (%) | A1, E1 |

> **Note** : Ces valeurs sont estimées par interpolation IDW à partir des 28 placettes de référence. Un tutoriel avancé couvrira le calcul direct depuis les nuages de points LiDAR.

### Tutoriel suivant

→ **Tutorial 03 : Indicateurs Terrain** - Calculer les indicateurs dérivés du MNT (TWI, pente, exposition) et de la BD TOPO (accessibilité, réseau hydro).

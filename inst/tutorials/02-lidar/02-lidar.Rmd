---
title: "Tutorial 02 : LiDAR — Familles C, P, B, E, A (C1, P1, P3, B2, E1, A1)"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
    language: fr
runtime: shiny_prerendered
description: >
  Traitement LiDAR HD et calcul de 6 indicateurs : C1 (stock carbone),
  P1/P3 (hauteur/volume), B2 (complexité structurale), E1 (bois-énergie),
  A1 (interception pluies).
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)

# Configuration gradethis
gradethis::gradethis_setup()

# Options
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)

# Timeout pour les exercices LiDAR (10 min)
options(tutorial.exercise.timelimit = 600)
```

## Bienvenue

### Objectifs du tutoriel

Ce tutoriel vous guide dans le **traitement des données LiDAR** pour extraire des métriques forestières utilisables dans le calcul des indicateurs nemeton.

À la fin de ce tutoriel, vous saurez :

1. **Charger un nuage de points LiDAR** avec lidR
2. **Comprendre la classification** des points (sol, végétation)
3. **Normaliser les hauteurs** par rapport au MNT
4. **Générer un MNH** (Modèle Numérique de Hauteur)
5. **Calculer des métriques** dendrométriques par parcelle
6. **Exporter les résultats** en GeoPackage

### Prérequis

Ce tutoriel nécessite les données acquises dans le **Tutorial 01** :

- `mnt.tif` : Modèle Numérique de Terrain
- `parcelles.gpkg` : Parcelles cadastrales
- `lidar_hd/` : Dalles LiDAR HD téléchargées

### Packages utilisés

```{r packages-info, echo=FALSE}
cat("Packages requis pour ce tutoriel:\n")
cat("- lidR >= 4.0.0 : Traitement nuages de points LiDAR\n")
cat("- terra : Manipulation rasters\n")
cat("- sf : Données vectorielles\n")
cat("- exactextractr : Extraction par polygone\n")
```

### Quiz d'introduction

```{r quiz-intro, echo=FALSE}
question("Qu'est-ce que le LiDAR ?",
  answer("Un capteur radar pour la pluie"),
  answer("Light Detection And Ranging - mesure de distance par laser", correct = TRUE),
  answer("Un format de fichier image"),
  answer("Un logiciel de cartographie"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

```{r quiz-intro-2, echo=FALSE}
question("Que mesure principalement le LiDAR aéroporté en foresterie ?",
  answer("La température des arbres"),
  answer("La hauteur et la structure verticale de la végétation", correct = TRUE),
  answer("L'humidité du sol"),
  answer("La couleur des feuilles"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

```{r quiz-intro-3, echo=FALSE}
question("Qu'est-ce que la normalisation des hauteurs LiDAR ?",
  answer("Convertir les coordonnées en mètres"),
  answer("Soustraire l'altitude du terrain pour obtenir la hauteur au-dessus du sol", correct = TRUE),
  answer("Diviser toutes les hauteurs par 100"),
  answer("Supprimer les points aberrants"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

---

## Section 1 : Introduction au LiDAR

### Principes du LiDAR

Le **LiDAR** (Light Detection And Ranging) est une technologie de télédétection active qui mesure la distance entre un capteur et une surface en émettant des impulsions laser.

**Caractéristiques du LiDAR HD IGN** :
- Densité : **10+ points/m²**
- Précision altimétrique : **< 20 cm**
- Classification automatique : sol, végétation basse, moyenne, haute
- Format : **LAZ** (compressé) ou **COPC** (Cloud Optimized Point Cloud)

### Classification des points

Chaque point LiDAR est classifié selon la norme ASPRS :

| Code | Classe | Description |
|------|--------|-------------|
| 2 | Ground | Sol nu |
| 3 | Low vegetation | Végétation < 0.5m |
| 4 | Medium vegetation | Végétation 0.5-2m |
| 5 | High vegetation | Végétation > 2m |
| 6 | Building | Bâtiments |

### Métriques forestières dérivées

À partir du nuage de points, nous pouvons extraire :

| Métrique | Description | Usage |
|----------|-------------|-------|
| **zmax** | Hauteur maximale | Volume, biomasse |
| **zmean** | Hauteur moyenne | Structure |
| **zsd** | Écart-type des hauteurs | Diversité structurale |
| **zq95** | Percentile 95 | Hauteur dominante |
| **pzabove2** | % points > 2m | Couverture canopée |
| **zentropy** | Entropie verticale | Complexité structurale |

---

## Section 2 : Chargement du nuage de points

### Exercice 2.1 : Charger une dalle LiDAR

Chargeons une dalle LiDAR depuis le cache du Tutorial 01.

```{r ex-2-1-setup}
library(sf)
library(terra)
# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-2-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=25, exercise.setup="ex-2-1-setup"}
# === CHARGEMENT D'UNE DALLE LIDAR ===

# Définir le répertoire de cache
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}

# Vérifier si lidR est disponible
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)
  
  # Lister les fichiers LiDAR disponibles
  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir, pattern = "\\.laz$", 
                             full.names = TRUE, recursive = TRUE)
  
  cat("Fichiers LiDAR disponibles:", length(fichiers_laz), "\n")
  
  if (length(fichiers_laz) > 0) {
    # Charger le premier fichier
    las <- readLAS(fichiers_laz[1])
    cat("\n=== Informations sur le nuage de points ===\n")
    print(las)
  }
} else {
  cat("Package lidR non installé.\n")
  cat("Installation: install.packages('lidR')\n")
}
```


### Exercice 2.2 : Explorer la structure du nuage

```{r ex-2-2-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-2-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=30, exercise.setup="ex-2-2-setup"}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)
  
  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir, pattern = "\\.laz$", 
                             full.names = TRUE, recursive = TRUE)
  
  if (length(fichiers_laz) > 0) {
    # Charger avec filtre pour réduire la mémoire
    las <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")
    
    cat("=== Structure du nuage de points ===\n\n")
    cat("Nombre de points:", nrow(las@data), "\n")
    cat("Attributs disponibles:", paste(names(las@data), collapse = ", "), "\n\n")
    
    # Statistiques par classification
    cat("=== Distribution par classe ===\n")
    table_class <- table(las@data$Classification)
    print(table_class)
    
    cat("\n=== Statistiques d'altitude (Z) ===\n")
    cat("Min:", min(las@data$Z), "m\n")
    cat("Max:", max(las@data$Z), "m\n")
    cat("Moyenne:", round(mean(las@data$Z), 1), "m\n")
  }
} else {
  cat("Démonstration avec données simulées:\n")
  cat("Points typiques: 500,000 - 5,000,000 par dalle\n")
  cat("Classes: 2 (sol), 3-5 (végétation), 6 (bâtiments)\n")
}
```

---

## Section 3 : Normalisation des hauteurs

### Pourquoi normaliser ?

Les coordonnées Z brutes du LiDAR sont des **altitudes absolues** (m au-dessus du niveau de la mer). Pour obtenir la **hauteur des arbres**, il faut soustraire l'altitude du terrain.

```
Hauteur arbre = Z_lidar - Z_mnt
```

### Exercice 3.1 : Normaliser avec le MNT

```{r ex-3-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-3-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=45, exercise.setup="ex-3-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir, pattern = "\\.laz$",
                             full.names = TRUE, recursive = TRUE)
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")
    cat("Nuage complet:", nrow(las_full@data), "points\n")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    # Pour accélérer le traitement dans ce tutoriel
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    # Clipper sur 20x20m centré
    las <- clip_rectangle(las_full,
                          xleft = center_x - 10,
                          ybottom = center_y - 10,
                          xright = center_x + 10,
                          ytop = center_y + 10)

    cat("Après clip 20x20m:", nrow(las@data), "points\n\n")

    # Charger le MNT
    mnt <- rast(mnt_path)

    cat("=== Avant normalisation ===\n")
    cat("Z min:", round(min(las@data$Z), 1), "m\n")
    cat("Z max:", round(max(las@data$Z), 1), "m\n")

    # Normalisation (rapide sur 20x20m)
    las_norm <- normalize_height(las, mnt)

    cat("\n=== Après normalisation ===\n")
    cat("Z min:", round(min(las_norm@data$Z), 1), "m\n")
    cat("Z max:", round(max(las_norm@data$Z), 1), "m\n")

    # Filtrer les points négatifs (sous le sol)
    las_clean <- filter_poi(las_norm, Z >= 0)
    cat("\nPoints après filtrage Z >= 0:", nrow(las_clean@data), "\n")

  } else {
    cat("Fichiers non trouvés. Exécutez d'abord le Tutorial 01.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 4 : Génération du MNH

### Modèle Numérique de Hauteur (MNH)

Le **MNH** (ou CHM - Canopy Height Model) est un raster représentant la hauteur de la canopée en chaque pixel.

### Exercice 4.1 : Créer le MNH

```{r ex-4-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-4-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-4-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir, pattern = "\\.laz$",
                             full.names = TRUE, recursive = TRUE)
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    las <- clip_rectangle(las_full,
                          xleft = center_x - 10,
                          ybottom = center_y - 10,
                          xright = center_x + 10,
                          ytop = center_y + 10)

    cat("Zone 20x20m:", nrow(las@data), "points\n")

    # Normaliser
    mnt <- rast(mnt_path)
    las_norm <- normalize_height(las, mnt)
    las_clean <- filter_poi(las_norm, Z >= 0 & Z < 60)

    # Générer le MNH (résolution 1m)
    cat("\n=== Génération du MNH ===\n")
    mnh <- rasterize_canopy(las_clean, res = 1, algorithm = p2r())

    cat("Dimensions:", nrow(mnh), "x", ncol(mnh), "pixels\n")
    cat("Résolution:", res(mnh)[1], "m\n")

    # Statistiques
    stats <- global(mnh, c("min", "max", "mean", "sd"), na.rm = TRUE)
    cat("\n=== Statistiques MNH ===\n")
    cat("Hauteur min:", round(stats$min, 1), "m\n")
    cat("Hauteur max:", round(stats$max, 1), "m\n")
    cat("Hauteur moyenne:", round(stats$mean, 1), "m\n")

    # Sauvegarder (exemple sur zone réduite)
    mnh_path <- file.path(data_dir, "mnh_sample.tif")
    writeRaster(mnh, mnh_path, overwrite = TRUE)
    cat("\nMNH échantillon sauvegardé:", mnh_path, "\n")

  } else {
    cat("Fichiers non trouvés.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 5 : Métriques par parcelle

### Exercice 5.1 : Calculer les métriques LiDAR

```{r ex-5-1-setup}
library(sf)
library(terra)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-5-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-5-1-setup", exercise.timelimit=300}
if (requireNamespace("lidR", quietly = TRUE)) {
  library(lidR)

  lidar_dir <- file.path(data_dir, "lidar_hd")
  fichiers_laz <- list.files(lidar_dir, pattern = "\\.laz$",
                             full.names = TRUE, recursive = TRUE)
  mnt_path <- file.path(data_dir, "mnt.tif")

  if (length(fichiers_laz) > 0 && file.exists(mnt_path)) {
    # Charger LiDAR
    las_full <- readLAS(fichiers_laz[1], filter = "-drop_z_below 0")

    # === RÉDUCTION À UN CARRÉ DE 20x20m ===
    bbox <- st_bbox(las_full)
    center_x <- (bbox["xmin"] + bbox["xmax"]) / 2
    center_y <- (bbox["ymin"] + bbox["ymax"]) / 2

    las <- clip_rectangle(las_full,
                          xleft = center_x - 10,
                          ybottom = center_y - 10,
                          xright = center_x + 10,
                          ytop = center_y + 10)

    cat("Zone 20x20m:", nrow(las@data), "points\n")

    # Normaliser
    mnt <- rast(mnt_path)
    las_norm <- normalize_height(las, mnt)
    las_clean <- filter_poi(las_norm, Z >= 0 & Z < 60)

    # Calculer par pixel (raster 2m pour zone 20x20m)
    # Utiliser une fonction anonyme inline pour éviter les problèmes de scope
    cat("\n=== Calcul des métriques raster ===\n")
    metrics_raster <- pixel_metrics(las_clean, ~list(
      zmax = max(Z, na.rm = TRUE),
      zmean = mean(Z, na.rm = TRUE),
      zsd = sd(Z, na.rm = TRUE),
      zq95 = quantile(Z, 0.95, na.rm = TRUE),
      pzabove2 = sum(Z > 2, na.rm = TRUE) / length(Z) * 100
    ), res = 2)

    cat("Couches générées:", names(metrics_raster), "\n")
    cat("Dimensions:", nrow(metrics_raster), "x", ncol(metrics_raster), "pixels\n")

    # Statistiques globales sur la zone
    cat("\n=== Statistiques sur la zone 20x20m ===\n")
    cat("Hauteur max (zmax):", round(max(values(metrics_raster$zmax), na.rm = TRUE), 1), "m\n")
    cat("Hauteur moyenne (zmean):", round(mean(values(metrics_raster$zmean), na.rm = TRUE), 1), "m\n")
    cat("Percentile 95 (zq95):", round(mean(values(metrics_raster$zq95), na.rm = TRUE), 1), "m\n")
    cat("Couverture > 2m:", round(mean(values(metrics_raster$pzabove2), na.rm = TRUE), 1), "%\n")

  } else {
    cat("Fichiers non trouvés.\n")
  }
} else {
  cat("Package lidR non installé.\n")
}
```


---

## Section 6 : Export des résultats

### Exercice 6.1 : Sauvegarder les métriques

Dans ce tutoriel, nous utilisons les **métriques LiDAR pré-calculées** du jeu de données `quatre_montagnes` (package `lidaRtRee`). Ces 28 placettes contiennent des valeurs réelles de zmean, zmax, zsd, etc.

Pour estimer les métriques sur les parcelles cadastrales, nous appliquons un **krigeage** (interpolation spatiale) à partir des placettes. Cette méthode permet d'obtenir des estimations cohérentes spatialement.

> **Note** : Le calcul direct des métriques LiDAR à partir des nuages de points sera traité dans un tutoriel avancé dédié au traitement LiDAR complet.

```{r ex-6-1-setup}
library(sf)
library(terra)
library(lidaRtRee)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-6-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=85, exercise.setup="ex-6-1-setup"}
# === INTERPOLATION DES MÉTRIQUES LIDAR PAR KRIGEAGE ===
# Utilisation des données réelles de quatre_montagnes (lidaRtRee)

# Charger les placettes avec métriques LiDAR
data("quatre_montagnes", package = "lidaRtRee")

# Filtrer sur les clusters Centre (même zone que Tutorial 01)
clusters_centre <- c("Verc-C1", "Verc-S4", "Verc-02", "Verc-S7",
                    "Verc-C4", "Verc-C2", "Verc-05")
qm_centre <- quatre_montagnes[quatre_montagnes$cluster_id %in% clusters_centre, ]

# Convertir en sf
placettes_sf <- st_as_sf(qm_centre, coords = c("X", "Y"), crs = 2154)

cat("=== Données source : quatre_montagnes ===\n")
cat("Placettes avec métriques LiDAR:", nrow(placettes_sf), "\n\n")

# Métriques LiDAR à interpoler
metriques <- c("zmax", "zmean", "zsd", "zq25", "zq50", "zq75", "zq95",
               "zentropy", "pzabove2")

cat("Métriques disponibles:\n")
for (m in metriques) {
  if (m %in% names(placettes_sf)) {
    vals <- qm_centre[[m]]
    cat(sprintf("  %s: %.1f - %.1f (moy: %.1f)\n",
                m, min(vals, na.rm=TRUE), mean(vals, na.rm=TRUE), max(vals, na.rm=TRUE)))
  }
}

# Charger les parcelles cadastrales
parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  # Calculer les centroïdes des parcelles
  centroids <- st_centroid(parcelles)

  cat("\n=== Interpolation par IDW (Inverse Distance Weighting) ===\n")
  cat("Parcelles cibles:", nrow(parcelles), "\n\n")

  # Fonction d'interpolation IDW simple
  idw_interpolate <- function(points_sf, target_sf, variable, power = 2) {
    # Extraire coordonnées
    coords_src <- st_coordinates(points_sf)
    coords_tgt <- st_coordinates(target_sf)
    values <- points_sf[[variable]]

    # Pour chaque point cible
    result <- sapply(1:nrow(coords_tgt), function(i) {
      # Distances aux points source
      distances <- sqrt((coords_src[,1] - coords_tgt[i,1])^2 +
                        (coords_src[,2] - coords_tgt[i,2])^2)
      # Éviter division par zéro
      distances[distances < 1] <- 1
      # Poids IDW
      weights <- 1 / (distances ^ power)
      # Moyenne pondérée
      sum(values * weights, na.rm = TRUE) / sum(weights, na.rm = TRUE)
    })
    return(result)
  }

  # Interpoler chaque métrique
  cat("Interpolation en cours...\n")
  for (m in metriques) {
    if (m %in% names(placettes_sf)) {
      parcelles[[m]] <- idw_interpolate(placettes_sf, centroids, m)
      cat(sprintf("  %s interpolé\n", m))
    }
  }

  # Sauvegarder
  output_path <- file.path(data_dir, "metriques_lidar.gpkg")
  st_write(parcelles, output_path, delete_dsn = TRUE, quiet = TRUE)
  st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
  cat("\n=== Métriques LiDAR exportées ===\n")
  cat("Fichier:", output_path, "\n")
  cat("Parcelles:", nrow(parcelles), " lignes et ", ncol(parcelles), " colonnes\n\n")

  # Résumé des métriques interpolées
  cat("=== Résumé des métriques interpolées ===\n")
  cat("Métrique       Min      Moy      Max\n")
  cat("--------------------------------------\n")
  for (m in metriques) {
    if (m %in% names(parcelles)) {
      cat(sprintf("%-12s %7.1f %8.1f %8.1f\n",
                  m, min(parcelles[[m]], na.rm=TRUE),
                  mean(parcelles[[m]], na.rm=TRUE),
                  max(parcelles[[m]], na.rm=TRUE)))
    }
  }
} else {
  cat("Parcelles non trouvées. Exécutez le Tutorial 01.\n")
}
```


---

## Section 7 : Indicateurs Énergie (E1, E2)

### Introduction à la famille Énergie

La **famille Énergie (E)** du référentiel nemeton quantifie le potentiel énergétique de la forêt :

- **E1** : Potentiel de production de bois-énergie (tep/ha/an)
- **E2** : Évitement carbone par substitution aux énergies fossiles (tCO₂/ha/an)

La biomasse forestière peut se substituer aux énergies fossiles :

- Chauffage (bois bûche, plaquettes, granulés)
- Cogénération (électricité + chaleur)
- Biocarburants de 2ème génération


```{r energie-concept, echo=FALSE}
substitution <- data.frame(
  Indicateur = c("E1", "E2"),
  Nom = c("Potentiel bois-énergie", "Évitement carbone"),
  Unite = c("tep/ha/an", "tCO₂/ha/an"),
  Source = c("pzabove2, zmean", "E1 × facteur substitution")
)
knitr::kable(substitution, caption = "Indicateurs de la famille Énergie")
```

### Exercice 7.1 : Calculer E1 (Bois-énergie)

L'indicateur **E1** estime le potentiel de production de bois-énergie à partir des métriques LiDAR :

- **pzabove2** : Couverture forestière > 2m (%)
- **zmean** : Hauteur moyenne de la canopée (m)

$$E1 = \frac{pzabove2}{100} \times zmean \times k_{conversion}$$

Où $k_{conversion}$ ≈ 0.015 tep/m/ha/an (tonne équivalent pétrole)

```{r ex-7-1-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-1, exercise=TRUE, exercise.eval=FALSE, exercise.lines=50, exercise.setup="ex-7-1-setup"}
# === CALCUL DE E1 : POTENTIEL BOIS-ÉNERGIE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de E1 (Bois-énergie) ===\n\n")

  # Vérifier les métriques nécessaires
  if (all(c("pzabove2", "zmean") %in% names(parcelles))) {

    # Facteur de conversion (tep/m/ha/an)
    # Basé sur productivité moyenne et pouvoir calorifique du bois
    k_conversion <- 0.015

    # Calcul E1
    parcelles$E1 <- (parcelles$pzabove2 / 100) * parcelles$zmean * k_conversion

    cat("Formule: E1 = (pzabove2/100) × zmean × k_conversion\n")
    cat("k_conversion =", k_conversion, "tep/m/ha/an\n\n")

    cat("=== Résultats E1 ===\n")
    cat("E1 min:", round(min(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n")
    cat("E1 moy:", round(mean(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n")
    cat("E1 max:", round(max(parcelles$E1, na.rm = TRUE), 3), "tep/ha/an\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ E1 ajouté aux parcelles\n")

  } else {
    cat("Métriques pzabove2 et zmean non trouvées.\n")
    cat("Exécutez l'exercice 6.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
  cat("Exécutez le Tutorial 01 d'abord.\n")
}
```

### Exercice 7.2 : Calculer E2 (Évitement carbone)

L'indicateur **E2** quantifie les **émissions de CO₂ évitées** grâce à la substitution du bois aux énergies fossiles :

$$E2 = E1 \times f_{substitution} \times \eta_{conversion}$$

Où :
- $E1$ : Production énergétique potentielle (tep/ha/an)
- $f_{substitution}$ ≈ 2.5 tCO₂/tep (facteur moyen de substitution)
- $\eta_{conversion}$ ≈ 0.85 (rendement des chaufferies bois)

```{r e2-table, echo=FALSE}
substitution <- data.frame(
  Combustible_Remplace = c("Fioul domestique", "Gaz naturel", "Charbon", "Électricité (mix FR)"),
  tCO2_evite_par_tep = c(2.9, 2.3, 3.4, 0.5),
  Usage_Typique = c("Chauffage individuel", "Chauffage collectif", "Industrie", "Pointe")
)
knitr::kable(substitution, caption = "Facteurs de substitution carbone par combustible")
```

```{r ex-7-2-setup}
library(sf)
if (requireNamespace("rappdirs", quietly = TRUE)) {
  data_dir <- file.path(rappdirs::user_data_dir("nemeton"), "tutorial_data")
} else {
  data_dir <- file.path(path.expand("~"), "nemeton_tutorial_data")
}
```

```{r ex-7-2, exercise=TRUE, exercise.eval=FALSE, exercise.lines=60, exercise.setup="ex-7-2-setup"}
# === CALCUL DE E2 : ÉVITEMENT CARBONE ===

parcelles_path <- file.path(data_dir, "parcelles.gpkg")

if (file.exists(parcelles_path)) {
  parcelles <- st_read(parcelles_path, quiet = TRUE)

  cat("=== Calcul de E2 (Évitement carbone) ===\n\n")

  # Vérifier que E1 existe
  if ("E1" %in% names(parcelles)) {

    # Paramètres de calcul
    facteur_substitution <- 2.5  # tCO2 évitées par tep de bois-énergie
    rendement_conversion <- 0.85  # Efficacité moyenne des chaufferies

    cat("Paramètres:\n")
    cat("  Facteur substitution:", facteur_substitution, "tCO2/tep\n")
    cat("  Rendement conversion:", rendement_conversion, "\n\n")

    # Calcul E2
    parcelles$E2 <- parcelles$E1 * facteur_substitution * rendement_conversion

    cat("Formule: E2 = E1 × f_substitution × η_conversion\n\n")

    cat("=== Résultats E2 ===\n")
    cat("E2 min:", round(min(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n")
    cat("E2 moy:", round(mean(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n")
    cat("E2 max:", round(max(parcelles$E2, na.rm = TRUE), 3), "tCO2/ha/an\n\n")

    # Évitement total sur la zone
    parcelles$evitement_total <- parcelles$E2 * parcelles$surface_ha
    total_evitement <- sum(parcelles$evitement_total, na.rm = TRUE)
    cat("Évitement total zone:", round(total_evitement, 1), "tCO2/an\n\n")

    # Sauvegarder
    st_write(parcelles, parcelles_path, delete_dsn = TRUE, quiet = TRUE)
    cat("✓ E2 ajouté aux parcelles\n")

    # Visualisation
    cat("\n=== Distribution E2 ===\n")
    hist(parcelles$E2, breaks = 15, col = "darkorange",
         main = "E2 : Évitement carbone",
         xlab = "tCO2/ha/an", ylab = "Fréquence")

  } else {
    cat("E1 non trouvé. Exécutez l'exercice 7.1 d'abord.\n")
  }
} else {
  cat("Fichier parcelles.gpkg non trouvé.\n")
}
```

### Interprétation de l'histogramme E2

L'histogramme **E2 : Évitement carbone** montre la distribution des émissions de CO₂ évitées par parcelle, exprimées en **tCO₂/ha/an**.

**Ce que représente E2** : le bénéfice climatique potentiel si le bois de la parcelle était utilisé comme source d'énergie à la place des combustibles fossiles (fioul, gaz, charbon).

```{r e2-interpretation, echo=FALSE}
cat("=== Grille d'interprétation E2 ===\n\n")
interpretation <- data.frame(
  Valeur_E2 = c("0 - 0.5", "0.5 - 1.5", "> 1.5"),
  Interpretation = c(
    "Faible potentiel (parcelle peu productive ou jeune)",
    "Potentiel modéré (forêt moyenne)",
    "Fort potentiel (forêt productive, mature)"
  )
)
knitr::kable(interpretation, col.names = c("E2 (tCO2/ha/an)", "Interprétation"))

cat("\n=== Exemple concret ===\n")
cat("Une parcelle avec E2 = 1.0 tCO2/ha/an signifie :\n")
cat("  → 1 tonne de CO2 évitée par hectare chaque année\n")
cat("  → Sur 10 ha : 10 tCO2/an évitées\n")
cat("  → Équivalent à ~5 allers-retours Paris-New York en avion\n\n")

cat("=== Forme de la distribution ===\n")
cat("  • Étalée à droite : quelques parcelles très productives\n")
cat("  • Pic à gauche : beaucoup de jeunes peuplements\n")
cat("  • Normale : forêt homogène en productivité\n")
```

### Quiz : Indicateurs Énergie

```{r quiz-energie-1, echo=FALSE}
question("Que représente l'indicateur E1 ?",
  answer("Le stock de carbone"),
  answer("Le potentiel de production bois-énergie", correct = TRUE),
  answer("L'évitement d'émissions CO2"),
  answer("La consommation énergétique"),
  allow_retry = TRUE
)
```

```{r quiz-energie-2, echo=FALSE}
question("Quelle unité est utilisée pour E2 ?",
  answer("kWh/ha/an"),
  answer("tep/ha/an"),
  answer("tCO2/ha/an", correct = TRUE),
  answer("m³/ha/an"),
  allow_retry = TRUE
)
```

```{r quiz-energie-3, echo=FALSE}
question("Quel facteur n'influence PAS le calcul de E2 ?",
  answer("Le potentiel E1"),
  answer("Le facteur de substitution"),
  answer("Le rendement de conversion"),
  answer("La pente du terrain", correct = TRUE),
  allow_retry = TRUE
)
```

---

## Section 8 : Quiz final

### Testez vos connaissances

```{r quiz-final-1, echo=FALSE}
question("Quelle fonction lidR permet de normaliser les hauteurs ?",
  answer("normalize_height()", correct = TRUE),
  answer("standardize_z()"),
  answer("subtract_terrain()"),
  answer("height_correction()"),
  allow_retry = TRUE
)
```

```{r quiz-final-2, echo=FALSE}
question("Qu'est-ce que le MNH (CHM) ?",
  answer("Le Modèle Numérique de Hauteur - hauteur de la canopée", correct = TRUE),
  answer("Le Modèle Numérique Hydrologique"),
  answer("Le Maximum Normalisé des Hauteurs"),
  answer("Le Modèle Naturel Harmonisé"),
  allow_retry = TRUE
)
```

```{r quiz-final-3, echo=FALSE}
question("Quelle métrique représente la hauteur des arbres dominants ?",
  answer("zmean (hauteur moyenne)"),
  answer("zmax (hauteur maximale)"),
  answer("zq95 (percentile 95)", correct = TRUE),
  answer("zsd (écart-type)"),
  allow_retry = TRUE
)
```

```{r quiz-final-4, echo=FALSE}
question("Pourquoi filtrer les points avec Z < 0 après normalisation ?",
  answer("Pour améliorer la vitesse de calcul"),
  answer("Pour supprimer les points sous le sol (erreurs)", correct = TRUE),
  answer("Pour réduire la taille du fichier"),
  answer("Pour ne garder que la végétation haute"),
  allow_retry = TRUE
)
```

```{r quiz-final-5, echo=FALSE}
question("Quelle résolution est recommandée pour le MNH en foresterie ?",
  answer("10 cm"),
  answer("50 cm - 1 m", correct = TRUE),
  answer("5 m"),
  answer("10 m"),
  allow_retry = TRUE
)
```

---

## Synthèse

### Ce que vous avez appris

Dans ce tutoriel, vous avez appris à :

1. ✅ **Charger** des données LiDAR avec `lidR::readLAS()`
2. ✅ **Comprendre** la classification des points (sol, végétation)
3. ✅ **Normaliser** les hauteurs avec `normalize_height()`
4. ✅ **Générer un MNH** avec `rasterize_canopy()`
5. ✅ **Calculer des métriques** par parcelle avec `pixel_metrics()`
6. ✅ **Exporter** les résultats en GeoPackage

### Données produites

Le fichier `metriques_lidar.gpkg` contient désormais vos parcelles avec les métriques interpolées depuis `quatre_montagnes` :

| Métrique | Description | Indicateurs |
|----------|-------------|-------------|
| **zmax** | Hauteur maximale (m) | C1, P1 |
| **zmean** | Hauteur moyenne (m) | P3 |
| **zsd** | Écart-type des hauteurs (m) | B2 |
| **zq25** | Percentile 25 (m) | Structure |
| **zq50** | Percentile 50 / médiane (m) | Structure |
| **zq75** | Percentile 75 (m) | Structure |
| **zq95** | Percentile 95 (m) | P1 |
| **zentropy** | Entropie verticale | B2 |
| **pzabove2** | Couverture > 2m (%) | A1, E1 |

> **Note** : Ces valeurs sont estimées par interpolation IDW à partir des 28 placettes de référence. Un tutoriel avancé couvrira le calcul direct depuis les nuages de points LiDAR.

### Tutoriel suivant

→ **Tutorial 03 : Indicateurs Terrain** - Calculer les indicateurs dérivés du MNT (TWI, pente, exposition) et de la BD TOPO (accessibilité, réseau hydro).

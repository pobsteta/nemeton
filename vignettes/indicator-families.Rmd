---
title: "Indicator Families Reference Guide"
author: "Pascal Obstétar"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Indicator Families Reference Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  warning = FALSE,
  message = FALSE
)
```

# Introduction

The `nemeton` package implements a **comprehensive multi-family indicator framework** for forest ecosystem assessment, based on the **Nemeton method** developed by *Vivre en Forêt*. This framework organizes ecosystem services into **12 distinct families**, each representing a key dimension of forest functioning.

## The 12 Families

```{r echo = FALSE, results = 'asis'}
families <- data.frame(
  Code = c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N"),
  Family = c(
    "Carbon/Vitality",
    "Biodiversity",
    "Water",
    "Air/Microclimate",
    "Soil Fertility",
    "Landscape",
    "Time/Dynamics",
    "Resilience/Risks",
    "Social/Uses",
    "Productive",
    "Energy/Climate",
    "Naturalness"
  ),
  Status_v0.2.0 = c(
    "✅ Implemented (C1, C2)",
    "⏳ v0.3.0+",
    "✅ Implemented (W1, W2, W3)",
    "⏳ v0.3.0+",
    "✅ Implemented (F1, F2)",
    "✅ Partial (L1, L2)",
    "⏳ v0.3.0+",
    "⏳ v0.3.0+",
    "⏳ v0.4.0+",
    "⏳ v0.4.0+",
    "⏳ v0.4.0+",
    "⏳ v0.3.0+"
  ),
  stringsAsFactors = FALSE
)

knitr::kable(families, caption = "Overview of the 12 Indicator Families")
```

**Version 0.2.0** implements **5 families** with **10 sub-indicators**, providing a solid foundation for multi-dimensional ecosystem analysis.

# Installation

```{r, eval = FALSE}
# Install from GitHub
remotes::install_github("pobsteta/nemeton")
```

```{r}
library(nemeton)
library(ggplot2)
library(dplyr)
```

## Visual Overview: The 12-Family Framework

The radar chart below illustrates the complete multi-dimensional framework, showing how all 12 families combine to provide a holistic assessment of forest ecosystem services.

```{r fig.cap = "12-Family Radar Chart - Complete Nemeton Framework", fig.width = 8, fig.height = 8}
# Load demo data
data(massif_demo_units)

# Create sample family scores for demonstration (0-100 scale)
# In practice, these would be computed from real indicators
demo_unit <- massif_demo_units[1, ]

# Simulate family scores for all 12 families
# Higher values = better performance in that dimension
demo_unit$family_C <- 75  # Carbon/Vitality - Good carbon storage
demo_unit$family_B <- 65  # Biodiversity - Moderate species richness
demo_unit$family_W <- 82  # Water - Excellent water regulation
demo_unit$family_A <- 70  # Air/Microclimate - Good air quality
demo_unit$family_F <- 68  # Soil Fertility - Moderate fertility
demo_unit$family_L <- 55  # Landscape - Some fragmentation
demo_unit$family_T <- 78  # Time/Dynamics - Old-growth characteristics
demo_unit$family_R <- 60  # Resilience/Risks - Moderate climate risk
demo_unit$family_S <- 85  # Social/Uses - High recreational value
demo_unit$family_P <- 72  # Productive - Good timber potential
demo_unit$family_E <- 80  # Energy/Climate - Strong carbon sequestration
demo_unit$family_N <- 62  # Naturalness - Moderate naturalness

# Create 12-family radar chart
nemeton_radar(
  demo_unit,
  mode = "family",
  indicators = c("family_C", "family_B", "family_W", "family_A",
                 "family_F", "family_L", "family_T", "family_R",
                 "family_S", "family_P", "family_E", "family_N"),
  normalize = FALSE,  # Already on 0-100 scale
  title = "Complete 12-Family Ecosystem Profile",
  fill_color = "#2E7D32",
  fill_alpha = 0.25
)
```

**Interpretation**: This example parcel shows:

- **Strengths** (> 75): Social value (S), Water regulation (W), Energy/Climate (E), Time/Dynamics (T)
- **Good performance** (65-75): Carbon (C), Air (A), Productive (P), Biodiversity (B)
- **Areas for improvement** (< 65): Naturalness (N), Resilience (R), Landscape (L)

The radar chart reveals the **multi-dimensional trade-offs** inherent in forest management: high productivity (P) and social value (S) may come at the expense of naturalness (N) and landscape integrity (L).

# Implemented Families (v0.2.0)

## Family C: Carbon & Vitality

The **Carbon family** quantifies carbon storage and vegetation vitality.

### C1: Biomass Stock (indicator_carbon_biomass)

Estimates aboveground biomass using **allometric models** from BD Forêt v2 data.

```{r eval = FALSE}
# Requires BD Forêt v2 with species, age, density
layers <- list(
  bd_foret = terra::vect("data/bd_foret_v2.gpkg")
)

carbon_biomass <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "C1",
  preprocess = TRUE
)

summary(carbon_biomass$C1)  # tC/ha
```

**Allometric Models**:

- **Quercus** (oak): Species-specific coefficients
- **Fagus** (beech): Species-specific coefficients
- **Pinus** (pine): Species-specific coefficients
- **Abies** (fir): Species-specific coefficients
- **Generic**: For other species

**Output**: Tonnes of carbon per hectare (tC/ha)

### C2: Vegetation Vitality (indicator_carbon_ndvi)

Calculates mean NDVI (Normalized Difference Vegetation Index) from Sentinel-2 imagery.

```{r eval = FALSE}
# Requires NDVI raster (Sentinel-2)
layers <- list(
  ndvi = terra::rast("data/sentinel2_ndvi.tif")
)

carbon_ndvi <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "C2"
)

summary(carbon_ndvi$C2)  # 0-1 scale
```

**Future Extension** (v0.3.0): 5-year NDVI trend analysis for vitality dynamics.

---

## Family W: Water Regulation

The **Water family** assesses the forest's role in infiltration, storage, and water quality.

### W1: Hydrographic Network Density (indicator_water_network)

Measures river/stream length per hectare.

```{r eval = FALSE}
# Requires hydrographic network (SF linestring)
layers <- list(
  rivers = sf::st_read("data/hydrographic_network.gpkg")
)

water_network <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "W1"
)

summary(water_network$W1)  # km/ha
```

### W2: Wetland Coverage (indicator_water_wetlands)

Percentage of parcel covered by wetlands or riparian zones.

```{r eval = FALSE}
# Requires wetland polygons (SF)
layers <- list(
  wetlands = sf::st_read("data/wetlands.gpkg")
)

water_wetlands <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "W2"
)

summary(water_wetlands$W2)  # % coverage
```

### W3: Topographic Wetness Index (indicator_water_twi)

Calculates TWI from DEM using flow accumulation and slope.

```{r eval = FALSE}
# Requires DEM (terra raster)
layers <- list(
  dem = terra::rast("data/dem_25m.tif")
)

water_twi <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "W3"
)

summary(water_twi$W3)  # TWI index
```

**Note**: Uses `terra` D8 flow algorithm by default. Optional `whitebox` support for D-infinity.

---

## Family F: Soil Fertility

The **Soil family** evaluates soil health and erosion risk.

### F1: Soil Fertility (indicator_soil_fertility)

Classifies soil fertility from BD Sol (French soil database) or equivalent.

```{r eval = FALSE}
# Requires BD Sol raster with fertility classes
layers <- list(
  soil_fertility = terra::rast("data/bd_sol_fertility.tif")
)

soil_fertility <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "F1"
)

summary(soil_fertility$F1)  # 0-100 scale
```

**Classes**:

- High fertility (80-100)
- Medium fertility (40-80)
- Low fertility (0-40)

### F2: Erosion Risk (indicator_soil_erosion)

Combines slope and vegetation cover to assess erosion vulnerability.

```{r eval = FALSE}
# Requires DEM and land cover raster
layers <- list(
  dem = terra::rast("data/dem_25m.tif"),
  landcover = terra::rast("data/landcover.tif")
)

soil_erosion <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "F2"
)

summary(soil_erosion$F2)  # Risk score (higher = more risk)
```

**Formula**: Erosion Risk = Slope (%) × (1 - Vegetation Cover)

---

## Family L: Landscape Quality

The **Landscape family** quantifies spatial patterns and connectivity.

### L1: Forest Fragmentation (indicator_landscape_fragmentation)

Counts forest patches and calculates mean patch size.

```{r eval = FALSE}
# Requires land cover raster
layers <- list(
  landcover = terra::rast("data/landcover.tif")
)

landscape_frag <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "L1",
  forest_values = c(1, 2, 3)  # Forest classes
)

summary(landscape_frag$L1)  # Patch count
```

### L2: Edge-to-Area Ratio (indicator_landscape_edge)

Calculates forest edge density (m/ha).

```{r eval = FALSE}
landscape_edge <- nemeton_compute(
  massif_demo_units,
  layers,
  indicators = "L2",
  forest_values = c(1, 2, 3)
)

summary(landscape_edge$L2)  # m/ha
```

**Interpretation**: Higher values indicate more fragmented landscapes.

---

# Multi-Family Workflows

## Compute Multiple Families

```{r eval = FALSE}
# Load demo data and layers
data(massif_demo_units)
layers <- massif_demo_layers()

# Compute indicators from 4 families (C, W, F, L)
results <- nemeton_compute(
  massif_demo_units[1:10, ],
  layers,
  indicators = c("C1", "C2", "W1", "W2", "W3", "F1", "F2", "L1", "L2"),
  preprocess = TRUE
)

# Check results
names(results)
```

## Normalize by Family

Normalize indicators independently within each family:

```{r eval = FALSE}
# Family-aware normalization
normalized <- normalize_indicators(
  results,
  method = "minmax",
  by_family = TRUE  # Normalize C1/C2 together, W1/W2/W3 together, etc.
)

# All indicators now on 0-100 scale within families
summary(normalized$C1)
summary(normalized$W1)
```

## Create Family Indices

Aggregate indicators into family-level scores:

```{r eval = FALSE}
# Create family composite scores
family_scores <- create_family_index(
  normalized,
  method = "weighted",
  weights = list(
    C = c(C1 = 0.6, C2 = 0.4),      # Prioritize biomass
    W = c(W1 = 0.3, W2 = 0.3, W3 = 0.4),  # TWI most important
    F = c(F1 = 0.7, F2 = 0.3),      # Fertility > erosion
    L = c(L1 = 0.5, L2 = 0.5)       # Equal weights
  )
)

# Check family scores
names(family_scores)
# Contains: family_C, family_W, family_F, family_L + original indicators
```

**Aggregation Methods**:

- `method = "mean"`: Simple average
- `method = "weighted"`: Weighted average (custom weights)
- `method = "geometric"`: Geometric mean (penalizes low values)
- `method = "harmonic"`: Harmonic mean (emphasizes balance)

# Multi-Family Visualization

## Radar Plots with Family Scores

```{r eval = FALSE}
# Multi-family radar plot
nemeton_radar(
  family_scores,
  unit_id = 1,
  mode = "family",           # Use family scores
  title = "Parcel P001: Multi-Family Profile"
)
```

The radar plot displays **4 axes** (one per family: C, W, F, L), showing the ecosystem service profile at a glance.

**Future** (v0.3.0+): Expand to **12 axes** as all families are implemented.

## Compare Units

```{r eval = FALSE}
# Compare two parcels
p1 <- nemeton_radar(family_scores, unit_id = 1, mode = "family",
                    title = "Parcel P001")
p2 <- nemeton_radar(family_scores, unit_id = 5, mode = "family",
                    title = "Parcel P005")

# Display side by side
library(patchwork)
p1 + p2
```

# Complete Example Workflow

```{r eval = FALSE}
library(nemeton)

# ============================================================================
# STEP 1: Load Data
# ============================================================================

data(massif_demo_units)
layers <- massif_demo_layers()

# Select 10 parcels for analysis
units <- massif_demo_units[1:10, ]
units$parcel_id <- paste0("P", sprintf("%03d", 1:10))

# ============================================================================
# STEP 2: Compute Multi-Family Indicators
# ============================================================================

# Compute all available indicators (v0.2.0)
results <- nemeton_compute(
  units,
  layers,
  indicators = c("C1", "C2", "W1", "W2", "W3", "F1", "F2", "L1", "L2"),
  preprocess = TRUE
)

# ============================================================================
# STEP 3: Normalize by Family
# ============================================================================

normalized <- normalize_indicators(
  results,
  method = "minmax",
  by_family = TRUE
)

# ============================================================================
# STEP 4: Create Family Indices
# ============================================================================

family_scores <- create_family_index(
  normalized,
  method = "weighted",
  weights = list(
    C = c(C1 = 0.7, C2 = 0.3),
    W = c(W1 = 0.25, W2 = 0.25, W3 = 0.5),
    F = c(F1 = 0.6, F2 = 0.4),
    L = c(L1 = 0.5, L2 = 0.5)
  )
)

# ============================================================================
# STEP 5: Visualize Multi-Family Profiles
# ============================================================================

# Radar plot for parcel P001
nemeton_radar(
  family_scores,
  unit_id = "P001",
  mode = "family",
  title = "Multi-Family Ecosystem Profile - Parcel P001"
)

# ============================================================================
# STEP 6: Identify Strengths and Weaknesses
# ============================================================================

# Extract family scores
scores_table <- family_scores %>%
  sf::st_drop_geometry() %>%
  select(parcel_id, starts_with("family_"))

# Rank parcels by family
cat("\n=== Top Parcels by Family ===\n")

cat("\nCarbon (family_C):\n")
scores_table %>%
  arrange(desc(family_C)) %>%
  select(parcel_id, family_C) %>%
  head(3) %>%
  print()

cat("\nWater (family_W):\n")
scores_table %>%
  arrange(desc(family_W)) %>%
  select(parcel_id, family_W) %>%
  head(3) %>%
  print()

# ============================================================================
# STEP 7: Export Results
# ============================================================================

# Save family scores
sf::st_write(
  family_scores,
  "results/family_scores_2025.gpkg",
  delete_dsn = TRUE
)

# Export CSV table
write.csv(
  scores_table,
  "results/family_scores_2025.csv",
  row.names = FALSE
)
```

# Roadmap: Future Families

## v0.3.0 - Biodiversity & Risks Extension

**Family B - Biodiversity**:

- B1: Protected habitat presence
- B2: Structural diversity (age classes, layers)
- B3: Ecological connectivity

**Family R - Resilience/Risks**:

- R1: Fire risk (FWI, fuel load)
- R2: Storm risk (exposure, stand structure)
- R3: Drought risk (water balance, species)

**Family T - Time/Dynamics**:

- T1: Forest cover ancientness
- T2: Land use change analysis

**Family N - Naturalness**:

- N1: Distance to infrastructure
- N2: Continuous forest cover
- N3: Composite naturalness index

---

## v0.4.0 - Socio-Economic Extension

**Family S - Social/Uses**:

- S1: Trail density
- S2: Accessibility (distance to roads)
- S3: Proximity to populations

**Family P - Productive/Heritage**:

- P1: Standing timber volume
- P2: Forest productivity
- P3: Timber vs fuelwood ratio

**Family A - Air/Microclimate**:

- A1: Forest cover (1 km buffer)
- A2: Air quality (ATMO data integration)

**Family E - Energy/Climate**:

- E1: Fuelwood potential
- E2: Carbon emission avoidance (substitution)

---

## v0.5.0 - Complete Framework

- **12/12 families** implemented
- **36 sub-indicators**
- Shiny dashboard for interactive exploration
- Uncertainty analysis
- Multi-format export (PDF reports, GeoPackage, CSV)

# Reference Tables

## Indicator Naming Conventions

```{r echo = FALSE, results = 'asis'}
conventions <- data.frame(
  Element = c("Function Name", "Indicator Code", "Normalized Column", "Family Score"),
  Format = c(
    "indicator_<family>_<name>()",
    "<LETTER><NUMBER>",
    "<CODE>_norm",
    "family_<LETTER>"
  ),
  Example = c(
    "indicator_carbon_biomass()",
    "C1, W3, F2",
    "C1_norm, W3_norm",
    "family_C, family_W"
  ),
  stringsAsFactors = FALSE
)

knitr::kable(conventions, caption = "Naming Conventions")
```

## Family Letter Codes

```{r echo = FALSE, results = 'asis'}
codes <- data.frame(
  Code = c("C", "B", "W", "A", "F", "L", "T", "R", "S", "P", "E", "N"),
  English = c(
    "Carbon", "Biodiversity", "Water", "Air", "Fertility (Soil)",
    "Landscape", "Time", "Resilience", "Social", "Productive",
    "Energy", "Naturalness"
  ),
  French = c(
    "Carbone", "Biodiversité", "Eau (Water)", "Air", "Fertilité",
    "Paysage (Landscape)", "Trame", "Résilience", "Santé", "Patrimoine",
    "Éducation", "Nuit"
  ),
  stringsAsFactors = FALSE
)

knitr::kable(codes, caption = "Family Letter Codes (Bilingual)")
```

# Advanced Topics

## Custom Aggregation Functions

You can define custom aggregation methods by modifying `create_family_index()`:

```{r eval = FALSE}
# Example: Min-max aggregation (most pessimistic)
custom_aggregate <- function(indicators) {
  # Return the minimum value within family
  min(indicators, na.rm = TRUE)
}

# Would require extending create_family_index() to accept custom functions
```

## Multi-Period Family Analysis

Combine family indices with temporal analysis:

```{r eval = FALSE}
# Compute family scores for each period
family_2015 <- create_family_index(results_2015)
family_2020 <- create_family_index(results_2020)
family_2025 <- create_family_index(results_2025)

# Create temporal object
temporal_families <- nemeton_temporal(
  periods = list(
    "2015" = family_2015,
    "2020" = family_2020,
    "2025" = family_2025
  ),
  id_column = "parcel_id"
)

# Calculate family score change rates
family_rates <- calculate_change_rate(
  temporal_families,
  indicators = c("family_C", "family_W", "family_F", "family_L"),
  type = "both"
)

# Which family is improving fastest?
```

See `vignette("temporal-analysis")` for more details.

# Summary

The **nemeton multi-family framework** enables:

1. **Comprehensive assessment**: 12 dimensions of ecosystem services
2. **Flexible aggregation**: 4 methods (mean, weighted, geometric, harmonic)
3. **Family-aware normalization**: Independent scaling within families
4. **Holistic visualization**: Multi-family radar plots
5. **Progressive implementation**: v0.2.0 → v0.3.0 → v0.4.0 → v0.5.0

## Current Status (v0.2.0)

- ✅ **5 families** implemented (C, W, F, L + partial infrastructure)
- ✅ **10 sub-indicators** ready for use
- ✅ **Full backward compatibility** with v0.1.0
- ✅ **Production-ready** with 661 passing tests

## Next Steps

- Explore temporal analysis: `vignette("temporal-analysis")`
- Learn basic workflows: `vignette("getting-started")`
- Read function documentation: `help(package = "nemeton")`
- Check GitHub roadmap: <https://github.com/pobsteta/nemeton>

# Session Info

```{r}
sessionInfo()
```
